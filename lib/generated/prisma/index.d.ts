
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model TaskAssignment
 * 
 */
export type TaskAssignment = $Result.DefaultSelection<Prisma.$TaskAssignmentPayload>
/**
 * Model TaskComment
 * 
 */
export type TaskComment = $Result.DefaultSelection<Prisma.$TaskCommentPayload>
/**
 * Model TaskTimeLog
 * 
 */
export type TaskTimeLog = $Result.DefaultSelection<Prisma.$TaskTimeLogPayload>
/**
 * Model AttendanceRecord
 * 
 */
export type AttendanceRecord = $Result.DefaultSelection<Prisma.$AttendanceRecordPayload>
/**
 * Model Leave
 * 
 */
export type Leave = $Result.DefaultSelection<Prisma.$LeavePayload>
/**
 * Model ChatMessage
 * 
 */
export type ChatMessage = $Result.DefaultSelection<Prisma.$ChatMessagePayload>
/**
 * Model ChatGroup
 * 
 */
export type ChatGroup = $Result.DefaultSelection<Prisma.$ChatGroupPayload>
/**
 * Model ChatGroupMember
 * 
 */
export type ChatGroupMember = $Result.DefaultSelection<Prisma.$ChatGroupMemberPayload>
/**
 * Model Announcement
 * 
 */
export type Announcement = $Result.DefaultSelection<Prisma.$AnnouncementPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model CompanyDocument
 * 
 */
export type CompanyDocument = $Result.DefaultSelection<Prisma.$CompanyDocumentPayload>
/**
 * Model Expense
 * 
 */
export type Expense = $Result.DefaultSelection<Prisma.$ExpensePayload>
/**
 * Model Asset
 * 
 */
export type Asset = $Result.DefaultSelection<Prisma.$AssetPayload>
/**
 * Model Payroll
 * 
 */
export type Payroll = $Result.DefaultSelection<Prisma.$PayrollPayload>
/**
 * Model PerformanceReview
 * 
 */
export type PerformanceReview = $Result.DefaultSelection<Prisma.$PerformanceReviewPayload>
/**
 * Model JobPost
 * 
 */
export type JobPost = $Result.DefaultSelection<Prisma.$JobPostPayload>
/**
 * Model Application
 * 
 */
export type Application = $Result.DefaultSelection<Prisma.$ApplicationPayload>
/**
 * Model TrainingProgram
 * 
 */
export type TrainingProgram = $Result.DefaultSelection<Prisma.$TrainingProgramPayload>
/**
 * Model TrainingEnrollment
 * 
 */
export type TrainingEnrollment = $Result.DefaultSelection<Prisma.$TrainingEnrollmentPayload>
/**
 * Model CalendarEvent
 * 
 */
export type CalendarEvent = $Result.DefaultSelection<Prisma.$CalendarEventPayload>
/**
 * Model CalendarAttendee
 * 
 */
export type CalendarAttendee = $Result.DefaultSelection<Prisma.$CalendarAttendeePayload>
/**
 * Model UserPreference
 * 
 */
export type UserPreference = $Result.DefaultSelection<Prisma.$UserPreferencePayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  EMPLOYEE: 'EMPLOYEE',
  MANAGER: 'MANAGER',
  HR: 'HR',
  ADMIN: 'ADMIN'
};

export type Role = (typeof Role)[keyof typeof Role]


export const EmploymentStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  TERMINATED: 'TERMINATED'
};

export type EmploymentStatus = (typeof EmploymentStatus)[keyof typeof EmploymentStatus]


export const TaskPriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type TaskPriority = (typeof TaskPriority)[keyof typeof TaskPriority]


export const TaskStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  OVERDUE: 'OVERDUE'
};

export type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus]


export const LeaveStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type LeaveStatus = (typeof LeaveStatus)[keyof typeof LeaveStatus]


export const AttendanceStatus: {
  PRESENT: 'PRESENT',
  ABSENT: 'ABSENT',
  LEAVE: 'LEAVE'
};

export type AttendanceStatus = (typeof AttendanceStatus)[keyof typeof AttendanceStatus]


export const ExpenseStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type ExpenseStatus = (typeof ExpenseStatus)[keyof typeof ExpenseStatus]


export const AssetStatus: {
  AVAILABLE: 'AVAILABLE',
  ASSIGNED: 'ASSIGNED',
  MAINTENANCE: 'MAINTENANCE',
  RETIRED: 'RETIRED',
  LOST: 'LOST'
};

export type AssetStatus = (typeof AssetStatus)[keyof typeof AssetStatus]


export const PayrollStatus: {
  DRAFT: 'DRAFT',
  PROCESSED: 'PROCESSED',
  PAID: 'PAID',
  CANCELLED: 'CANCELLED'
};

export type PayrollStatus = (typeof PayrollStatus)[keyof typeof PayrollStatus]


export const ApplicationStatus: {
  APPLIED: 'APPLIED',
  UNDER_REVIEW: 'UNDER_REVIEW',
  INTERVIEW_SCHEDULED: 'INTERVIEW_SCHEDULED',
  OFFERED: 'OFFERED',
  REJECTED: 'REJECTED',
  WITHDRAWN: 'WITHDRAWN'
};

export type ApplicationStatus = (typeof ApplicationStatus)[keyof typeof ApplicationStatus]


export const JobType: {
  FULL_TIME: 'FULL_TIME',
  PART_TIME: 'PART_TIME',
  INTERN: 'INTERN',
  CONTRACT: 'CONTRACT'
};

export type JobType = (typeof JobType)[keyof typeof JobType]


export const TrainingStatus: {
  PLANNED: 'PLANNED',
  ONGOING: 'ONGOING',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type TrainingStatus = (typeof TrainingStatus)[keyof typeof TrainingStatus]


export const EventSource: {
  INTERNAL: 'INTERNAL',
  GOOGLE: 'GOOGLE',
  OUTLOOK: 'OUTLOOK'
};

export type EventSource = (typeof EventSource)[keyof typeof EventSource]


export const NotificationType: {
  GENERAL: 'GENERAL',
  TASK: 'TASK',
  LEAVE: 'LEAVE',
  ATTENDANCE: 'ATTENDANCE',
  PAYROLL: 'PAYROLL',
  EXPENSE: 'EXPENSE',
  ASSET: 'ASSET',
  ANNOUNCEMENT: 'ANNOUNCEMENT',
  CHAT: 'CHAT'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type EmploymentStatus = $Enums.EmploymentStatus

export const EmploymentStatus: typeof $Enums.EmploymentStatus

export type TaskPriority = $Enums.TaskPriority

export const TaskPriority: typeof $Enums.TaskPriority

export type TaskStatus = $Enums.TaskStatus

export const TaskStatus: typeof $Enums.TaskStatus

export type LeaveStatus = $Enums.LeaveStatus

export const LeaveStatus: typeof $Enums.LeaveStatus

export type AttendanceStatus = $Enums.AttendanceStatus

export const AttendanceStatus: typeof $Enums.AttendanceStatus

export type ExpenseStatus = $Enums.ExpenseStatus

export const ExpenseStatus: typeof $Enums.ExpenseStatus

export type AssetStatus = $Enums.AssetStatus

export const AssetStatus: typeof $Enums.AssetStatus

export type PayrollStatus = $Enums.PayrollStatus

export const PayrollStatus: typeof $Enums.PayrollStatus

export type ApplicationStatus = $Enums.ApplicationStatus

export const ApplicationStatus: typeof $Enums.ApplicationStatus

export type JobType = $Enums.JobType

export const JobType: typeof $Enums.JobType

export type TrainingStatus = $Enums.TrainingStatus

export const TrainingStatus: typeof $Enums.TrainingStatus

export type EventSource = $Enums.EventSource

export const EventSource: typeof $Enums.EventSource

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskAssignment`: Exposes CRUD operations for the **TaskAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskAssignments
    * const taskAssignments = await prisma.taskAssignment.findMany()
    * ```
    */
  get taskAssignment(): Prisma.TaskAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskComment`: Exposes CRUD operations for the **TaskComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskComments
    * const taskComments = await prisma.taskComment.findMany()
    * ```
    */
  get taskComment(): Prisma.TaskCommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskTimeLog`: Exposes CRUD operations for the **TaskTimeLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskTimeLogs
    * const taskTimeLogs = await prisma.taskTimeLog.findMany()
    * ```
    */
  get taskTimeLog(): Prisma.TaskTimeLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendanceRecord`: Exposes CRUD operations for the **AttendanceRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttendanceRecords
    * const attendanceRecords = await prisma.attendanceRecord.findMany()
    * ```
    */
  get attendanceRecord(): Prisma.AttendanceRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leave`: Exposes CRUD operations for the **Leave** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leaves
    * const leaves = await prisma.leave.findMany()
    * ```
    */
  get leave(): Prisma.LeaveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatMessage`: Exposes CRUD operations for the **ChatMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatMessages
    * const chatMessages = await prisma.chatMessage.findMany()
    * ```
    */
  get chatMessage(): Prisma.ChatMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatGroup`: Exposes CRUD operations for the **ChatGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatGroups
    * const chatGroups = await prisma.chatGroup.findMany()
    * ```
    */
  get chatGroup(): Prisma.ChatGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatGroupMember`: Exposes CRUD operations for the **ChatGroupMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatGroupMembers
    * const chatGroupMembers = await prisma.chatGroupMember.findMany()
    * ```
    */
  get chatGroupMember(): Prisma.ChatGroupMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.announcement`: Exposes CRUD operations for the **Announcement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Announcements
    * const announcements = await prisma.announcement.findMany()
    * ```
    */
  get announcement(): Prisma.AnnouncementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companyDocument`: Exposes CRUD operations for the **CompanyDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyDocuments
    * const companyDocuments = await prisma.companyDocument.findMany()
    * ```
    */
  get companyDocument(): Prisma.CompanyDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.expense`: Exposes CRUD operations for the **Expense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expenses
    * const expenses = await prisma.expense.findMany()
    * ```
    */
  get expense(): Prisma.ExpenseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.asset`: Exposes CRUD operations for the **Asset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assets
    * const assets = await prisma.asset.findMany()
    * ```
    */
  get asset(): Prisma.AssetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payroll`: Exposes CRUD operations for the **Payroll** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payrolls
    * const payrolls = await prisma.payroll.findMany()
    * ```
    */
  get payroll(): Prisma.PayrollDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.performanceReview`: Exposes CRUD operations for the **PerformanceReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PerformanceReviews
    * const performanceReviews = await prisma.performanceReview.findMany()
    * ```
    */
  get performanceReview(): Prisma.PerformanceReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobPost`: Exposes CRUD operations for the **JobPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobPosts
    * const jobPosts = await prisma.jobPost.findMany()
    * ```
    */
  get jobPost(): Prisma.JobPostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.application`: Exposes CRUD operations for the **Application** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Applications
    * const applications = await prisma.application.findMany()
    * ```
    */
  get application(): Prisma.ApplicationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainingProgram`: Exposes CRUD operations for the **TrainingProgram** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingPrograms
    * const trainingPrograms = await prisma.trainingProgram.findMany()
    * ```
    */
  get trainingProgram(): Prisma.TrainingProgramDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainingEnrollment`: Exposes CRUD operations for the **TrainingEnrollment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingEnrollments
    * const trainingEnrollments = await prisma.trainingEnrollment.findMany()
    * ```
    */
  get trainingEnrollment(): Prisma.TrainingEnrollmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.calendarEvent`: Exposes CRUD operations for the **CalendarEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CalendarEvents
    * const calendarEvents = await prisma.calendarEvent.findMany()
    * ```
    */
  get calendarEvent(): Prisma.CalendarEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.calendarAttendee`: Exposes CRUD operations for the **CalendarAttendee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CalendarAttendees
    * const calendarAttendees = await prisma.calendarAttendee.findMany()
    * ```
    */
  get calendarAttendee(): Prisma.CalendarAttendeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPreference`: Exposes CRUD operations for the **UserPreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPreferences
    * const userPreferences = await prisma.userPreference.findMany()
    * ```
    */
  get userPreference(): Prisma.UserPreferenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.14.0
   * Query Engine version: 717184b7b35ea05dfa71a3236b7af656013e1e49
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Department: 'Department',
    Task: 'Task',
    TaskAssignment: 'TaskAssignment',
    TaskComment: 'TaskComment',
    TaskTimeLog: 'TaskTimeLog',
    AttendanceRecord: 'AttendanceRecord',
    Leave: 'Leave',
    ChatMessage: 'ChatMessage',
    ChatGroup: 'ChatGroup',
    ChatGroupMember: 'ChatGroupMember',
    Announcement: 'Announcement',
    Notification: 'Notification',
    Document: 'Document',
    CompanyDocument: 'CompanyDocument',
    Expense: 'Expense',
    Asset: 'Asset',
    Payroll: 'Payroll',
    PerformanceReview: 'PerformanceReview',
    JobPost: 'JobPost',
    Application: 'Application',
    TrainingProgram: 'TrainingProgram',
    TrainingEnrollment: 'TrainingEnrollment',
    CalendarEvent: 'CalendarEvent',
    CalendarAttendee: 'CalendarAttendee',
    UserPreference: 'UserPreference',
    AuditLog: 'AuditLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "department" | "task" | "taskAssignment" | "taskComment" | "taskTimeLog" | "attendanceRecord" | "leave" | "chatMessage" | "chatGroup" | "chatGroupMember" | "announcement" | "notification" | "document" | "companyDocument" | "expense" | "asset" | "payroll" | "performanceReview" | "jobPost" | "application" | "trainingProgram" | "trainingEnrollment" | "calendarEvent" | "calendarAttendee" | "userPreference" | "auditLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      TaskAssignment: {
        payload: Prisma.$TaskAssignmentPayload<ExtArgs>
        fields: Prisma.TaskAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>
          }
          findFirst: {
            args: Prisma.TaskAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>
          }
          findMany: {
            args: Prisma.TaskAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>[]
          }
          create: {
            args: Prisma.TaskAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>
          }
          createMany: {
            args: Prisma.TaskAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TaskAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>
          }
          update: {
            args: Prisma.TaskAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.TaskAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>
          }
          aggregate: {
            args: Prisma.TaskAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskAssignment>
          }
          groupBy: {
            args: Prisma.TaskAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<TaskAssignmentCountAggregateOutputType> | number
          }
        }
      }
      TaskComment: {
        payload: Prisma.$TaskCommentPayload<ExtArgs>
        fields: Prisma.TaskCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCommentPayload>
          }
          findFirst: {
            args: Prisma.TaskCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCommentPayload>
          }
          findMany: {
            args: Prisma.TaskCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCommentPayload>[]
          }
          create: {
            args: Prisma.TaskCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCommentPayload>
          }
          createMany: {
            args: Prisma.TaskCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TaskCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCommentPayload>
          }
          update: {
            args: Prisma.TaskCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCommentPayload>
          }
          deleteMany: {
            args: Prisma.TaskCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCommentPayload>
          }
          aggregate: {
            args: Prisma.TaskCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskComment>
          }
          groupBy: {
            args: Prisma.TaskCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCommentCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCommentCountAggregateOutputType> | number
          }
        }
      }
      TaskTimeLog: {
        payload: Prisma.$TaskTimeLogPayload<ExtArgs>
        fields: Prisma.TaskTimeLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskTimeLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTimeLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskTimeLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTimeLogPayload>
          }
          findFirst: {
            args: Prisma.TaskTimeLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTimeLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskTimeLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTimeLogPayload>
          }
          findMany: {
            args: Prisma.TaskTimeLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTimeLogPayload>[]
          }
          create: {
            args: Prisma.TaskTimeLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTimeLogPayload>
          }
          createMany: {
            args: Prisma.TaskTimeLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TaskTimeLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTimeLogPayload>
          }
          update: {
            args: Prisma.TaskTimeLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTimeLogPayload>
          }
          deleteMany: {
            args: Prisma.TaskTimeLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskTimeLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskTimeLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTimeLogPayload>
          }
          aggregate: {
            args: Prisma.TaskTimeLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskTimeLog>
          }
          groupBy: {
            args: Prisma.TaskTimeLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskTimeLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskTimeLogCountArgs<ExtArgs>
            result: $Utils.Optional<TaskTimeLogCountAggregateOutputType> | number
          }
        }
      }
      AttendanceRecord: {
        payload: Prisma.$AttendanceRecordPayload<ExtArgs>
        fields: Prisma.AttendanceRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          findFirst: {
            args: Prisma.AttendanceRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          findMany: {
            args: Prisma.AttendanceRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>[]
          }
          create: {
            args: Prisma.AttendanceRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          createMany: {
            args: Prisma.AttendanceRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AttendanceRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          update: {
            args: Prisma.AttendanceRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          deleteMany: {
            args: Prisma.AttendanceRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AttendanceRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          aggregate: {
            args: Prisma.AttendanceRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendanceRecord>
          }
          groupBy: {
            args: Prisma.AttendanceRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceRecordCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceRecordCountAggregateOutputType> | number
          }
        }
      }
      Leave: {
        payload: Prisma.$LeavePayload<ExtArgs>
        fields: Prisma.LeaveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          findFirst: {
            args: Prisma.LeaveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          findMany: {
            args: Prisma.LeaveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>[]
          }
          create: {
            args: Prisma.LeaveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          createMany: {
            args: Prisma.LeaveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LeaveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          update: {
            args: Prisma.LeaveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          deleteMany: {
            args: Prisma.LeaveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LeaveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          aggregate: {
            args: Prisma.LeaveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeave>
          }
          groupBy: {
            args: Prisma.LeaveGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaveGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaveCountArgs<ExtArgs>
            result: $Utils.Optional<LeaveCountAggregateOutputType> | number
          }
        }
      }
      ChatMessage: {
        payload: Prisma.$ChatMessagePayload<ExtArgs>
        fields: Prisma.ChatMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findFirst: {
            args: Prisma.ChatMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findMany: {
            args: Prisma.ChatMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          create: {
            args: Prisma.ChatMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          createMany: {
            args: Prisma.ChatMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ChatMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          update: {
            args: Prisma.ChatMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          deleteMany: {
            args: Prisma.ChatMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChatMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          aggregate: {
            args: Prisma.ChatMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatMessage>
          }
          groupBy: {
            args: Prisma.ChatMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatMessageCountArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageCountAggregateOutputType> | number
          }
        }
      }
      ChatGroup: {
        payload: Prisma.$ChatGroupPayload<ExtArgs>
        fields: Prisma.ChatGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupPayload>
          }
          findFirst: {
            args: Prisma.ChatGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupPayload>
          }
          findMany: {
            args: Prisma.ChatGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupPayload>[]
          }
          create: {
            args: Prisma.ChatGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupPayload>
          }
          createMany: {
            args: Prisma.ChatGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ChatGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupPayload>
          }
          update: {
            args: Prisma.ChatGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupPayload>
          }
          deleteMany: {
            args: Prisma.ChatGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChatGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupPayload>
          }
          aggregate: {
            args: Prisma.ChatGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatGroup>
          }
          groupBy: {
            args: Prisma.ChatGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatGroupCountArgs<ExtArgs>
            result: $Utils.Optional<ChatGroupCountAggregateOutputType> | number
          }
        }
      }
      ChatGroupMember: {
        payload: Prisma.$ChatGroupMemberPayload<ExtArgs>
        fields: Prisma.ChatGroupMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatGroupMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatGroupMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupMemberPayload>
          }
          findFirst: {
            args: Prisma.ChatGroupMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatGroupMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupMemberPayload>
          }
          findMany: {
            args: Prisma.ChatGroupMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupMemberPayload>[]
          }
          create: {
            args: Prisma.ChatGroupMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupMemberPayload>
          }
          createMany: {
            args: Prisma.ChatGroupMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ChatGroupMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupMemberPayload>
          }
          update: {
            args: Prisma.ChatGroupMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupMemberPayload>
          }
          deleteMany: {
            args: Prisma.ChatGroupMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatGroupMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChatGroupMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupMemberPayload>
          }
          aggregate: {
            args: Prisma.ChatGroupMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatGroupMember>
          }
          groupBy: {
            args: Prisma.ChatGroupMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatGroupMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatGroupMemberCountArgs<ExtArgs>
            result: $Utils.Optional<ChatGroupMemberCountAggregateOutputType> | number
          }
        }
      }
      Announcement: {
        payload: Prisma.$AnnouncementPayload<ExtArgs>
        fields: Prisma.AnnouncementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnnouncementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnnouncementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          findFirst: {
            args: Prisma.AnnouncementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnnouncementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          findMany: {
            args: Prisma.AnnouncementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
          }
          create: {
            args: Prisma.AnnouncementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          createMany: {
            args: Prisma.AnnouncementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AnnouncementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          update: {
            args: Prisma.AnnouncementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          deleteMany: {
            args: Prisma.AnnouncementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnnouncementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AnnouncementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          aggregate: {
            args: Prisma.AnnouncementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnnouncement>
          }
          groupBy: {
            args: Prisma.AnnouncementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnnouncementCountArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      CompanyDocument: {
        payload: Prisma.$CompanyDocumentPayload<ExtArgs>
        fields: Prisma.CompanyDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyDocumentPayload>
          }
          findFirst: {
            args: Prisma.CompanyDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyDocumentPayload>
          }
          findMany: {
            args: Prisma.CompanyDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyDocumentPayload>[]
          }
          create: {
            args: Prisma.CompanyDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyDocumentPayload>
          }
          createMany: {
            args: Prisma.CompanyDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CompanyDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyDocumentPayload>
          }
          update: {
            args: Prisma.CompanyDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyDocumentPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyDocumentPayload>
          }
          aggregate: {
            args: Prisma.CompanyDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyDocument>
          }
          groupBy: {
            args: Prisma.CompanyDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyDocumentCountAggregateOutputType> | number
          }
        }
      }
      Expense: {
        payload: Prisma.$ExpensePayload<ExtArgs>
        fields: Prisma.ExpenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findFirst: {
            args: Prisma.ExpenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findMany: {
            args: Prisma.ExpenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          create: {
            args: Prisma.ExpenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          createMany: {
            args: Prisma.ExpenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ExpenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          update: {
            args: Prisma.ExpenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          deleteMany: {
            args: Prisma.ExpenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExpenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          aggregate: {
            args: Prisma.ExpenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpense>
          }
          groupBy: {
            args: Prisma.ExpenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCountAggregateOutputType> | number
          }
        }
      }
      Asset: {
        payload: Prisma.$AssetPayload<ExtArgs>
        fields: Prisma.AssetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          findFirst: {
            args: Prisma.AssetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          findMany: {
            args: Prisma.AssetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          create: {
            args: Prisma.AssetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          createMany: {
            args: Prisma.AssetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AssetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          update: {
            args: Prisma.AssetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          deleteMany: {
            args: Prisma.AssetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AssetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          aggregate: {
            args: Prisma.AssetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAsset>
          }
          groupBy: {
            args: Prisma.AssetGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssetGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssetCountArgs<ExtArgs>
            result: $Utils.Optional<AssetCountAggregateOutputType> | number
          }
        }
      }
      Payroll: {
        payload: Prisma.$PayrollPayload<ExtArgs>
        fields: Prisma.PayrollFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PayrollFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PayrollFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          findFirst: {
            args: Prisma.PayrollFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PayrollFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          findMany: {
            args: Prisma.PayrollFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>[]
          }
          create: {
            args: Prisma.PayrollCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          createMany: {
            args: Prisma.PayrollCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PayrollDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          update: {
            args: Prisma.PayrollUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          deleteMany: {
            args: Prisma.PayrollDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PayrollUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PayrollUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          aggregate: {
            args: Prisma.PayrollAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayroll>
          }
          groupBy: {
            args: Prisma.PayrollGroupByArgs<ExtArgs>
            result: $Utils.Optional<PayrollGroupByOutputType>[]
          }
          count: {
            args: Prisma.PayrollCountArgs<ExtArgs>
            result: $Utils.Optional<PayrollCountAggregateOutputType> | number
          }
        }
      }
      PerformanceReview: {
        payload: Prisma.$PerformanceReviewPayload<ExtArgs>
        fields: Prisma.PerformanceReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PerformanceReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PerformanceReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>
          }
          findFirst: {
            args: Prisma.PerformanceReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PerformanceReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>
          }
          findMany: {
            args: Prisma.PerformanceReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>[]
          }
          create: {
            args: Prisma.PerformanceReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>
          }
          createMany: {
            args: Prisma.PerformanceReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PerformanceReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>
          }
          update: {
            args: Prisma.PerformanceReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>
          }
          deleteMany: {
            args: Prisma.PerformanceReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PerformanceReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PerformanceReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>
          }
          aggregate: {
            args: Prisma.PerformanceReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerformanceReview>
          }
          groupBy: {
            args: Prisma.PerformanceReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<PerformanceReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.PerformanceReviewCountArgs<ExtArgs>
            result: $Utils.Optional<PerformanceReviewCountAggregateOutputType> | number
          }
        }
      }
      JobPost: {
        payload: Prisma.$JobPostPayload<ExtArgs>
        fields: Prisma.JobPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload>
          }
          findFirst: {
            args: Prisma.JobPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload>
          }
          findMany: {
            args: Prisma.JobPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload>[]
          }
          create: {
            args: Prisma.JobPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload>
          }
          createMany: {
            args: Prisma.JobPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.JobPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload>
          }
          update: {
            args: Prisma.JobPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload>
          }
          deleteMany: {
            args: Prisma.JobPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JobPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload>
          }
          aggregate: {
            args: Prisma.JobPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobPost>
          }
          groupBy: {
            args: Prisma.JobPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobPostCountArgs<ExtArgs>
            result: $Utils.Optional<JobPostCountAggregateOutputType> | number
          }
        }
      }
      Application: {
        payload: Prisma.$ApplicationPayload<ExtArgs>
        fields: Prisma.ApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          findFirst: {
            args: Prisma.ApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          findMany: {
            args: Prisma.ApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>[]
          }
          create: {
            args: Prisma.ApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          createMany: {
            args: Prisma.ApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          update: {
            args: Prisma.ApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          deleteMany: {
            args: Prisma.ApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          aggregate: {
            args: Prisma.ApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApplication>
          }
          groupBy: {
            args: Prisma.ApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<ApplicationCountAggregateOutputType> | number
          }
        }
      }
      TrainingProgram: {
        payload: Prisma.$TrainingProgramPayload<ExtArgs>
        fields: Prisma.TrainingProgramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingProgramFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingProgramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingProgramFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingProgramPayload>
          }
          findFirst: {
            args: Prisma.TrainingProgramFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingProgramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingProgramFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingProgramPayload>
          }
          findMany: {
            args: Prisma.TrainingProgramFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingProgramPayload>[]
          }
          create: {
            args: Prisma.TrainingProgramCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingProgramPayload>
          }
          createMany: {
            args: Prisma.TrainingProgramCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TrainingProgramDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingProgramPayload>
          }
          update: {
            args: Prisma.TrainingProgramUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingProgramPayload>
          }
          deleteMany: {
            args: Prisma.TrainingProgramDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingProgramUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TrainingProgramUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingProgramPayload>
          }
          aggregate: {
            args: Prisma.TrainingProgramAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingProgram>
          }
          groupBy: {
            args: Prisma.TrainingProgramGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingProgramGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingProgramCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingProgramCountAggregateOutputType> | number
          }
        }
      }
      TrainingEnrollment: {
        payload: Prisma.$TrainingEnrollmentPayload<ExtArgs>
        fields: Prisma.TrainingEnrollmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingEnrollmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingEnrollmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingEnrollmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingEnrollmentPayload>
          }
          findFirst: {
            args: Prisma.TrainingEnrollmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingEnrollmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingEnrollmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingEnrollmentPayload>
          }
          findMany: {
            args: Prisma.TrainingEnrollmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingEnrollmentPayload>[]
          }
          create: {
            args: Prisma.TrainingEnrollmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingEnrollmentPayload>
          }
          createMany: {
            args: Prisma.TrainingEnrollmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TrainingEnrollmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingEnrollmentPayload>
          }
          update: {
            args: Prisma.TrainingEnrollmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingEnrollmentPayload>
          }
          deleteMany: {
            args: Prisma.TrainingEnrollmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingEnrollmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TrainingEnrollmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingEnrollmentPayload>
          }
          aggregate: {
            args: Prisma.TrainingEnrollmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingEnrollment>
          }
          groupBy: {
            args: Prisma.TrainingEnrollmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingEnrollmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingEnrollmentCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingEnrollmentCountAggregateOutputType> | number
          }
        }
      }
      CalendarEvent: {
        payload: Prisma.$CalendarEventPayload<ExtArgs>
        fields: Prisma.CalendarEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CalendarEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CalendarEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          findFirst: {
            args: Prisma.CalendarEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CalendarEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          findMany: {
            args: Prisma.CalendarEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>[]
          }
          create: {
            args: Prisma.CalendarEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          createMany: {
            args: Prisma.CalendarEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CalendarEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          update: {
            args: Prisma.CalendarEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          deleteMany: {
            args: Prisma.CalendarEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CalendarEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CalendarEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          aggregate: {
            args: Prisma.CalendarEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCalendarEvent>
          }
          groupBy: {
            args: Prisma.CalendarEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<CalendarEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.CalendarEventCountArgs<ExtArgs>
            result: $Utils.Optional<CalendarEventCountAggregateOutputType> | number
          }
        }
      }
      CalendarAttendee: {
        payload: Prisma.$CalendarAttendeePayload<ExtArgs>
        fields: Prisma.CalendarAttendeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CalendarAttendeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarAttendeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CalendarAttendeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarAttendeePayload>
          }
          findFirst: {
            args: Prisma.CalendarAttendeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarAttendeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CalendarAttendeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarAttendeePayload>
          }
          findMany: {
            args: Prisma.CalendarAttendeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarAttendeePayload>[]
          }
          create: {
            args: Prisma.CalendarAttendeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarAttendeePayload>
          }
          createMany: {
            args: Prisma.CalendarAttendeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CalendarAttendeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarAttendeePayload>
          }
          update: {
            args: Prisma.CalendarAttendeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarAttendeePayload>
          }
          deleteMany: {
            args: Prisma.CalendarAttendeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CalendarAttendeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CalendarAttendeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarAttendeePayload>
          }
          aggregate: {
            args: Prisma.CalendarAttendeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCalendarAttendee>
          }
          groupBy: {
            args: Prisma.CalendarAttendeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CalendarAttendeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.CalendarAttendeeCountArgs<ExtArgs>
            result: $Utils.Optional<CalendarAttendeeCountAggregateOutputType> | number
          }
        }
      }
      UserPreference: {
        payload: Prisma.$UserPreferencePayload<ExtArgs>
        fields: Prisma.UserPreferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPreferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPreferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>
          }
          findFirst: {
            args: Prisma.UserPreferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPreferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>
          }
          findMany: {
            args: Prisma.UserPreferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>[]
          }
          create: {
            args: Prisma.UserPreferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>
          }
          createMany: {
            args: Prisma.UserPreferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserPreferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>
          }
          update: {
            args: Prisma.UserPreferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>
          }
          deleteMany: {
            args: Prisma.UserPreferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPreferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserPreferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>
          }
          aggregate: {
            args: Prisma.UserPreferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPreference>
          }
          groupBy: {
            args: Prisma.UserPreferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPreferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPreferenceCountArgs<ExtArgs>
            result: $Utils.Optional<UserPreferenceCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    department?: DepartmentOmit
    task?: TaskOmit
    taskAssignment?: TaskAssignmentOmit
    taskComment?: TaskCommentOmit
    taskTimeLog?: TaskTimeLogOmit
    attendanceRecord?: AttendanceRecordOmit
    leave?: LeaveOmit
    chatMessage?: ChatMessageOmit
    chatGroup?: ChatGroupOmit
    chatGroupMember?: ChatGroupMemberOmit
    announcement?: AnnouncementOmit
    notification?: NotificationOmit
    document?: DocumentOmit
    companyDocument?: CompanyDocumentOmit
    expense?: ExpenseOmit
    asset?: AssetOmit
    payroll?: PayrollOmit
    performanceReview?: PerformanceReviewOmit
    jobPost?: JobPostOmit
    application?: ApplicationOmit
    trainingProgram?: TrainingProgramOmit
    trainingEnrollment?: TrainingEnrollmentOmit
    calendarEvent?: CalendarEventOmit
    calendarAttendee?: CalendarAttendeeOmit
    userPreference?: UserPreferenceOmit
    auditLog?: AuditLogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    reports: number
    tasksCreated: number
    taskAssignments: number
    taskComments: number
    timeLogs: number
    attendance: number
    leaves: number
    leavesToApprove: number
    messagesSent: number
    messagesRecv: number
    chatGroups: number
    notifications: number
    documents: number
    companyDocs: number
    expenses: number
    expensesApproved: number
    payrolls: number
    generatedPays: number
    performanceReviewsGiven: number
    performanceReviewsGot: number
    assetsOwned: number
    jobPosts: number
    applications: number
    eventsOrganized: number
    eventAttendees: number
    trainingEnrollments: number
    announcementsMade: number
    auditLogs: number
    headedDepartments: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reports?: boolean | UserCountOutputTypeCountReportsArgs
    tasksCreated?: boolean | UserCountOutputTypeCountTasksCreatedArgs
    taskAssignments?: boolean | UserCountOutputTypeCountTaskAssignmentsArgs
    taskComments?: boolean | UserCountOutputTypeCountTaskCommentsArgs
    timeLogs?: boolean | UserCountOutputTypeCountTimeLogsArgs
    attendance?: boolean | UserCountOutputTypeCountAttendanceArgs
    leaves?: boolean | UserCountOutputTypeCountLeavesArgs
    leavesToApprove?: boolean | UserCountOutputTypeCountLeavesToApproveArgs
    messagesSent?: boolean | UserCountOutputTypeCountMessagesSentArgs
    messagesRecv?: boolean | UserCountOutputTypeCountMessagesRecvArgs
    chatGroups?: boolean | UserCountOutputTypeCountChatGroupsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    documents?: boolean | UserCountOutputTypeCountDocumentsArgs
    companyDocs?: boolean | UserCountOutputTypeCountCompanyDocsArgs
    expenses?: boolean | UserCountOutputTypeCountExpensesArgs
    expensesApproved?: boolean | UserCountOutputTypeCountExpensesApprovedArgs
    payrolls?: boolean | UserCountOutputTypeCountPayrollsArgs
    generatedPays?: boolean | UserCountOutputTypeCountGeneratedPaysArgs
    performanceReviewsGiven?: boolean | UserCountOutputTypeCountPerformanceReviewsGivenArgs
    performanceReviewsGot?: boolean | UserCountOutputTypeCountPerformanceReviewsGotArgs
    assetsOwned?: boolean | UserCountOutputTypeCountAssetsOwnedArgs
    jobPosts?: boolean | UserCountOutputTypeCountJobPostsArgs
    applications?: boolean | UserCountOutputTypeCountApplicationsArgs
    eventsOrganized?: boolean | UserCountOutputTypeCountEventsOrganizedArgs
    eventAttendees?: boolean | UserCountOutputTypeCountEventAttendeesArgs
    trainingEnrollments?: boolean | UserCountOutputTypeCountTrainingEnrollmentsArgs
    announcementsMade?: boolean | UserCountOutputTypeCountAnnouncementsMadeArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    headedDepartments?: boolean | UserCountOutputTypeCountHeadedDepartmentsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTasksCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTaskAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAssignmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTaskCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTimeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskTimeLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceRecordWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLeavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLeavesToApproveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesRecvArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChatGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatGroupMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCompanyDocsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyDocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExpensesApprovedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPayrollsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGeneratedPaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPerformanceReviewsGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPerformanceReviewsGotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssetsOwnedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountJobPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobPostWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEventsOrganizedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarEventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEventAttendeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarAttendeeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTrainingEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingEnrollmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAnnouncementsMadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHeadedDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
  }


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    users: number
    Announcement: number
    JobPost: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | DepartmentCountOutputTypeCountUsersArgs
    Announcement?: boolean | DepartmentCountOutputTypeCountAnnouncementArgs
    JobPost?: boolean | DepartmentCountOutputTypeCountJobPostArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountAnnouncementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountJobPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobPostWhereInput
  }


  /**
   * Count Type TaskCountOutputType
   */

  export type TaskCountOutputType = {
    assignments: number
    comments: number
    timeLogs: number
  }

  export type TaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | TaskCountOutputTypeCountAssignmentsArgs
    comments?: boolean | TaskCountOutputTypeCountCommentsArgs
    timeLogs?: boolean | TaskCountOutputTypeCountTimeLogsArgs
  }

  // Custom InputTypes
  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCountOutputType
     */
    select?: TaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAssignmentWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskCommentWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountTimeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskTimeLogWhereInput
  }


  /**
   * Count Type ChatGroupCountOutputType
   */

  export type ChatGroupCountOutputType = {
    messages: number
    members: number
  }

  export type ChatGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ChatGroupCountOutputTypeCountMessagesArgs
    members?: boolean | ChatGroupCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * ChatGroupCountOutputType without action
   */
  export type ChatGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroupCountOutputType
     */
    select?: ChatGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatGroupCountOutputType without action
   */
  export type ChatGroupCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
  }

  /**
   * ChatGroupCountOutputType without action
   */
  export type ChatGroupCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatGroupMemberWhereInput
  }


  /**
   * Count Type JobPostCountOutputType
   */

  export type JobPostCountOutputType = {
    applications: number
  }

  export type JobPostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applications?: boolean | JobPostCountOutputTypeCountApplicationsArgs
  }

  // Custom InputTypes
  /**
   * JobPostCountOutputType without action
   */
  export type JobPostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostCountOutputType
     */
    select?: JobPostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JobPostCountOutputType without action
   */
  export type JobPostCountOutputTypeCountApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationWhereInput
  }


  /**
   * Count Type TrainingProgramCountOutputType
   */

  export type TrainingProgramCountOutputType = {
    enrollments: number
  }

  export type TrainingProgramCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollments?: boolean | TrainingProgramCountOutputTypeCountEnrollmentsArgs
  }

  // Custom InputTypes
  /**
   * TrainingProgramCountOutputType without action
   */
  export type TrainingProgramCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingProgramCountOutputType
     */
    select?: TrainingProgramCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TrainingProgramCountOutputType without action
   */
  export type TrainingProgramCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingEnrollmentWhereInput
  }


  /**
   * Count Type CalendarEventCountOutputType
   */

  export type CalendarEventCountOutputType = {
    attendees: number
  }

  export type CalendarEventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendees?: boolean | CalendarEventCountOutputTypeCountAttendeesArgs
  }

  // Custom InputTypes
  /**
   * CalendarEventCountOutputType without action
   */
  export type CalendarEventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventCountOutputType
     */
    select?: CalendarEventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CalendarEventCountOutputType without action
   */
  export type CalendarEventCountOutputTypeCountAttendeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarAttendeeWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    salary: Decimal | null
  }

  export type UserSumAggregateOutputType = {
    salary: Decimal | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
    employment: $Enums.EmploymentStatus | null
    phone: string | null
    address: string | null
    joinDate: Date | null
    salary: Decimal | null
    notes: string | null
    departmentId: string | null
    managerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
    employment: $Enums.EmploymentStatus | null
    phone: string | null
    address: string | null
    joinDate: Date | null
    salary: Decimal | null
    notes: string | null
    departmentId: string | null
    managerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    role: number
    employment: number
    phone: number
    address: number
    joinDate: number
    salary: number
    notes: number
    departmentId: number
    managerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    salary?: true
  }

  export type UserSumAggregateInputType = {
    salary?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    employment?: true
    phone?: true
    address?: true
    joinDate?: true
    salary?: true
    notes?: true
    departmentId?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    employment?: true
    phone?: true
    address?: true
    joinDate?: true
    salary?: true
    notes?: true
    departmentId?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    employment?: true
    phone?: true
    address?: true
    joinDate?: true
    salary?: true
    notes?: true
    departmentId?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    password: string
    role: $Enums.Role
    employment: $Enums.EmploymentStatus
    phone: string | null
    address: string | null
    joinDate: Date | null
    salary: Decimal | null
    notes: string | null
    departmentId: string | null
    managerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    employment?: boolean
    phone?: boolean
    address?: boolean
    joinDate?: boolean
    salary?: boolean
    notes?: boolean
    departmentId?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | User$departmentArgs<ExtArgs>
    manager?: boolean | User$managerArgs<ExtArgs>
    reports?: boolean | User$reportsArgs<ExtArgs>
    tasksCreated?: boolean | User$tasksCreatedArgs<ExtArgs>
    taskAssignments?: boolean | User$taskAssignmentsArgs<ExtArgs>
    taskComments?: boolean | User$taskCommentsArgs<ExtArgs>
    timeLogs?: boolean | User$timeLogsArgs<ExtArgs>
    attendance?: boolean | User$attendanceArgs<ExtArgs>
    leaves?: boolean | User$leavesArgs<ExtArgs>
    leavesToApprove?: boolean | User$leavesToApproveArgs<ExtArgs>
    messagesSent?: boolean | User$messagesSentArgs<ExtArgs>
    messagesRecv?: boolean | User$messagesRecvArgs<ExtArgs>
    chatGroups?: boolean | User$chatGroupsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    documents?: boolean | User$documentsArgs<ExtArgs>
    companyDocs?: boolean | User$companyDocsArgs<ExtArgs>
    expenses?: boolean | User$expensesArgs<ExtArgs>
    expensesApproved?: boolean | User$expensesApprovedArgs<ExtArgs>
    payrolls?: boolean | User$payrollsArgs<ExtArgs>
    generatedPays?: boolean | User$generatedPaysArgs<ExtArgs>
    performanceReviewsGiven?: boolean | User$performanceReviewsGivenArgs<ExtArgs>
    performanceReviewsGot?: boolean | User$performanceReviewsGotArgs<ExtArgs>
    assetsOwned?: boolean | User$assetsOwnedArgs<ExtArgs>
    jobPosts?: boolean | User$jobPostsArgs<ExtArgs>
    applications?: boolean | User$applicationsArgs<ExtArgs>
    eventsOrganized?: boolean | User$eventsOrganizedArgs<ExtArgs>
    eventAttendees?: boolean | User$eventAttendeesArgs<ExtArgs>
    trainingEnrollments?: boolean | User$trainingEnrollmentsArgs<ExtArgs>
    announcementsMade?: boolean | User$announcementsMadeArgs<ExtArgs>
    preferences?: boolean | User$preferencesArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    headedDepartments?: boolean | User$headedDepartmentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    employment?: boolean
    phone?: boolean
    address?: boolean
    joinDate?: boolean
    salary?: boolean
    notes?: boolean
    departmentId?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password" | "role" | "employment" | "phone" | "address" | "joinDate" | "salary" | "notes" | "departmentId" | "managerId" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | User$departmentArgs<ExtArgs>
    manager?: boolean | User$managerArgs<ExtArgs>
    reports?: boolean | User$reportsArgs<ExtArgs>
    tasksCreated?: boolean | User$tasksCreatedArgs<ExtArgs>
    taskAssignments?: boolean | User$taskAssignmentsArgs<ExtArgs>
    taskComments?: boolean | User$taskCommentsArgs<ExtArgs>
    timeLogs?: boolean | User$timeLogsArgs<ExtArgs>
    attendance?: boolean | User$attendanceArgs<ExtArgs>
    leaves?: boolean | User$leavesArgs<ExtArgs>
    leavesToApprove?: boolean | User$leavesToApproveArgs<ExtArgs>
    messagesSent?: boolean | User$messagesSentArgs<ExtArgs>
    messagesRecv?: boolean | User$messagesRecvArgs<ExtArgs>
    chatGroups?: boolean | User$chatGroupsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    documents?: boolean | User$documentsArgs<ExtArgs>
    companyDocs?: boolean | User$companyDocsArgs<ExtArgs>
    expenses?: boolean | User$expensesArgs<ExtArgs>
    expensesApproved?: boolean | User$expensesApprovedArgs<ExtArgs>
    payrolls?: boolean | User$payrollsArgs<ExtArgs>
    generatedPays?: boolean | User$generatedPaysArgs<ExtArgs>
    performanceReviewsGiven?: boolean | User$performanceReviewsGivenArgs<ExtArgs>
    performanceReviewsGot?: boolean | User$performanceReviewsGotArgs<ExtArgs>
    assetsOwned?: boolean | User$assetsOwnedArgs<ExtArgs>
    jobPosts?: boolean | User$jobPostsArgs<ExtArgs>
    applications?: boolean | User$applicationsArgs<ExtArgs>
    eventsOrganized?: boolean | User$eventsOrganizedArgs<ExtArgs>
    eventAttendees?: boolean | User$eventAttendeesArgs<ExtArgs>
    trainingEnrollments?: boolean | User$trainingEnrollmentsArgs<ExtArgs>
    announcementsMade?: boolean | User$announcementsMadeArgs<ExtArgs>
    preferences?: boolean | User$preferencesArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    headedDepartments?: boolean | User$headedDepartmentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      manager: Prisma.$UserPayload<ExtArgs> | null
      reports: Prisma.$UserPayload<ExtArgs>[]
      tasksCreated: Prisma.$TaskPayload<ExtArgs>[]
      taskAssignments: Prisma.$TaskAssignmentPayload<ExtArgs>[]
      taskComments: Prisma.$TaskCommentPayload<ExtArgs>[]
      timeLogs: Prisma.$TaskTimeLogPayload<ExtArgs>[]
      attendance: Prisma.$AttendanceRecordPayload<ExtArgs>[]
      leaves: Prisma.$LeavePayload<ExtArgs>[]
      leavesToApprove: Prisma.$LeavePayload<ExtArgs>[]
      messagesSent: Prisma.$ChatMessagePayload<ExtArgs>[]
      messagesRecv: Prisma.$ChatMessagePayload<ExtArgs>[]
      chatGroups: Prisma.$ChatGroupMemberPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      companyDocs: Prisma.$CompanyDocumentPayload<ExtArgs>[]
      expenses: Prisma.$ExpensePayload<ExtArgs>[]
      expensesApproved: Prisma.$ExpensePayload<ExtArgs>[]
      payrolls: Prisma.$PayrollPayload<ExtArgs>[]
      generatedPays: Prisma.$PayrollPayload<ExtArgs>[]
      performanceReviewsGiven: Prisma.$PerformanceReviewPayload<ExtArgs>[]
      performanceReviewsGot: Prisma.$PerformanceReviewPayload<ExtArgs>[]
      assetsOwned: Prisma.$AssetPayload<ExtArgs>[]
      jobPosts: Prisma.$JobPostPayload<ExtArgs>[]
      applications: Prisma.$ApplicationPayload<ExtArgs>[]
      eventsOrganized: Prisma.$CalendarEventPayload<ExtArgs>[]
      eventAttendees: Prisma.$CalendarAttendeePayload<ExtArgs>[]
      trainingEnrollments: Prisma.$TrainingEnrollmentPayload<ExtArgs>[]
      announcementsMade: Prisma.$AnnouncementPayload<ExtArgs>[]
      preferences: Prisma.$UserPreferencePayload<ExtArgs> | null
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      headedDepartments: Prisma.$DepartmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      password: string
      role: $Enums.Role
      employment: $Enums.EmploymentStatus
      phone: string | null
      address: string | null
      joinDate: Date | null
      salary: Prisma.Decimal | null
      notes: string | null
      departmentId: string | null
      managerId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends User$departmentArgs<ExtArgs> = {}>(args?: Subset<T, User$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    manager<T extends User$managerArgs<ExtArgs> = {}>(args?: Subset<T, User$managerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reports<T extends User$reportsArgs<ExtArgs> = {}>(args?: Subset<T, User$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasksCreated<T extends User$tasksCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$tasksCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taskAssignments<T extends User$taskAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$taskAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taskComments<T extends User$taskCommentsArgs<ExtArgs> = {}>(args?: Subset<T, User$taskCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    timeLogs<T extends User$timeLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$timeLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTimeLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendance<T extends User$attendanceArgs<ExtArgs> = {}>(args?: Subset<T, User$attendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leaves<T extends User$leavesArgs<ExtArgs> = {}>(args?: Subset<T, User$leavesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leavesToApprove<T extends User$leavesToApproveArgs<ExtArgs> = {}>(args?: Subset<T, User$leavesToApproveArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messagesSent<T extends User$messagesSentArgs<ExtArgs> = {}>(args?: Subset<T, User$messagesSentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messagesRecv<T extends User$messagesRecvArgs<ExtArgs> = {}>(args?: Subset<T, User$messagesRecvArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chatGroups<T extends User$chatGroupsArgs<ExtArgs> = {}>(args?: Subset<T, User$chatGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatGroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends User$documentsArgs<ExtArgs> = {}>(args?: Subset<T, User$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    companyDocs<T extends User$companyDocsArgs<ExtArgs> = {}>(args?: Subset<T, User$companyDocsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    expenses<T extends User$expensesArgs<ExtArgs> = {}>(args?: Subset<T, User$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    expensesApproved<T extends User$expensesApprovedArgs<ExtArgs> = {}>(args?: Subset<T, User$expensesApprovedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payrolls<T extends User$payrollsArgs<ExtArgs> = {}>(args?: Subset<T, User$payrollsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    generatedPays<T extends User$generatedPaysArgs<ExtArgs> = {}>(args?: Subset<T, User$generatedPaysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    performanceReviewsGiven<T extends User$performanceReviewsGivenArgs<ExtArgs> = {}>(args?: Subset<T, User$performanceReviewsGivenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    performanceReviewsGot<T extends User$performanceReviewsGotArgs<ExtArgs> = {}>(args?: Subset<T, User$performanceReviewsGotArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assetsOwned<T extends User$assetsOwnedArgs<ExtArgs> = {}>(args?: Subset<T, User$assetsOwnedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    jobPosts<T extends User$jobPostsArgs<ExtArgs> = {}>(args?: Subset<T, User$jobPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    applications<T extends User$applicationsArgs<ExtArgs> = {}>(args?: Subset<T, User$applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    eventsOrganized<T extends User$eventsOrganizedArgs<ExtArgs> = {}>(args?: Subset<T, User$eventsOrganizedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    eventAttendees<T extends User$eventAttendeesArgs<ExtArgs> = {}>(args?: Subset<T, User$eventAttendeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarAttendeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    trainingEnrollments<T extends User$trainingEnrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$trainingEnrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingEnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    announcementsMade<T extends User$announcementsMadeArgs<ExtArgs> = {}>(args?: Subset<T, User$announcementsMadeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    preferences<T extends User$preferencesArgs<ExtArgs> = {}>(args?: Subset<T, User$preferencesArgs<ExtArgs>>): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    headedDepartments<T extends User$headedDepartmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$headedDepartmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly employment: FieldRef<"User", 'EmploymentStatus'>
    readonly phone: FieldRef<"User", 'String'>
    readonly address: FieldRef<"User", 'String'>
    readonly joinDate: FieldRef<"User", 'DateTime'>
    readonly salary: FieldRef<"User", 'Decimal'>
    readonly notes: FieldRef<"User", 'String'>
    readonly departmentId: FieldRef<"User", 'String'>
    readonly managerId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.department
   */
  export type User$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * User.manager
   */
  export type User$managerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.reports
   */
  export type User$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.tasksCreated
   */
  export type User$tasksCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * User.taskAssignments
   */
  export type User$taskAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    where?: TaskAssignmentWhereInput
    orderBy?: TaskAssignmentOrderByWithRelationInput | TaskAssignmentOrderByWithRelationInput[]
    cursor?: TaskAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskAssignmentScalarFieldEnum | TaskAssignmentScalarFieldEnum[]
  }

  /**
   * User.taskComments
   */
  export type User$taskCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskComment
     */
    omit?: TaskCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentInclude<ExtArgs> | null
    where?: TaskCommentWhereInput
    orderBy?: TaskCommentOrderByWithRelationInput | TaskCommentOrderByWithRelationInput[]
    cursor?: TaskCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskCommentScalarFieldEnum | TaskCommentScalarFieldEnum[]
  }

  /**
   * User.timeLogs
   */
  export type User$timeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTimeLog
     */
    select?: TaskTimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTimeLog
     */
    omit?: TaskTimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTimeLogInclude<ExtArgs> | null
    where?: TaskTimeLogWhereInput
    orderBy?: TaskTimeLogOrderByWithRelationInput | TaskTimeLogOrderByWithRelationInput[]
    cursor?: TaskTimeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskTimeLogScalarFieldEnum | TaskTimeLogScalarFieldEnum[]
  }

  /**
   * User.attendance
   */
  export type User$attendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    where?: AttendanceRecordWhereInput
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    cursor?: AttendanceRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * User.leaves
   */
  export type User$leavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    where?: LeaveWhereInput
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    cursor?: LeaveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * User.leavesToApprove
   */
  export type User$leavesToApproveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    where?: LeaveWhereInput
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    cursor?: LeaveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * User.messagesSent
   */
  export type User$messagesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * User.messagesRecv
   */
  export type User$messagesRecvArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * User.chatGroups
   */
  export type User$chatGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroupMember
     */
    select?: ChatGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroupMember
     */
    omit?: ChatGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupMemberInclude<ExtArgs> | null
    where?: ChatGroupMemberWhereInput
    orderBy?: ChatGroupMemberOrderByWithRelationInput | ChatGroupMemberOrderByWithRelationInput[]
    cursor?: ChatGroupMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatGroupMemberScalarFieldEnum | ChatGroupMemberScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.documents
   */
  export type User$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * User.companyDocs
   */
  export type User$companyDocsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentInclude<ExtArgs> | null
    where?: CompanyDocumentWhereInput
    orderBy?: CompanyDocumentOrderByWithRelationInput | CompanyDocumentOrderByWithRelationInput[]
    cursor?: CompanyDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyDocumentScalarFieldEnum | CompanyDocumentScalarFieldEnum[]
  }

  /**
   * User.expenses
   */
  export type User$expensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * User.expensesApproved
   */
  export type User$expensesApprovedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * User.payrolls
   */
  export type User$payrollsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    where?: PayrollWhereInput
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    cursor?: PayrollWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * User.generatedPays
   */
  export type User$generatedPaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    where?: PayrollWhereInput
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    cursor?: PayrollWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * User.performanceReviewsGiven
   */
  export type User$performanceReviewsGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    where?: PerformanceReviewWhereInput
    orderBy?: PerformanceReviewOrderByWithRelationInput | PerformanceReviewOrderByWithRelationInput[]
    cursor?: PerformanceReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PerformanceReviewScalarFieldEnum | PerformanceReviewScalarFieldEnum[]
  }

  /**
   * User.performanceReviewsGot
   */
  export type User$performanceReviewsGotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    where?: PerformanceReviewWhereInput
    orderBy?: PerformanceReviewOrderByWithRelationInput | PerformanceReviewOrderByWithRelationInput[]
    cursor?: PerformanceReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PerformanceReviewScalarFieldEnum | PerformanceReviewScalarFieldEnum[]
  }

  /**
   * User.assetsOwned
   */
  export type User$assetsOwnedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    cursor?: AssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * User.jobPosts
   */
  export type User$jobPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPost
     */
    omit?: JobPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostInclude<ExtArgs> | null
    where?: JobPostWhereInput
    orderBy?: JobPostOrderByWithRelationInput | JobPostOrderByWithRelationInput[]
    cursor?: JobPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobPostScalarFieldEnum | JobPostScalarFieldEnum[]
  }

  /**
   * User.applications
   */
  export type User$applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    where?: ApplicationWhereInput
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    cursor?: ApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * User.eventsOrganized
   */
  export type User$eventsOrganizedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    where?: CalendarEventWhereInput
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    cursor?: CalendarEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarEventScalarFieldEnum | CalendarEventScalarFieldEnum[]
  }

  /**
   * User.eventAttendees
   */
  export type User$eventAttendeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarAttendee
     */
    select?: CalendarAttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarAttendee
     */
    omit?: CalendarAttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarAttendeeInclude<ExtArgs> | null
    where?: CalendarAttendeeWhereInput
    orderBy?: CalendarAttendeeOrderByWithRelationInput | CalendarAttendeeOrderByWithRelationInput[]
    cursor?: CalendarAttendeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarAttendeeScalarFieldEnum | CalendarAttendeeScalarFieldEnum[]
  }

  /**
   * User.trainingEnrollments
   */
  export type User$trainingEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingEnrollment
     */
    select?: TrainingEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingEnrollment
     */
    omit?: TrainingEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingEnrollmentInclude<ExtArgs> | null
    where?: TrainingEnrollmentWhereInput
    orderBy?: TrainingEnrollmentOrderByWithRelationInput | TrainingEnrollmentOrderByWithRelationInput[]
    cursor?: TrainingEnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingEnrollmentScalarFieldEnum | TrainingEnrollmentScalarFieldEnum[]
  }

  /**
   * User.announcementsMade
   */
  export type User$announcementsMadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    where?: AnnouncementWhereInput
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    cursor?: AnnouncementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * User.preferences
   */
  export type User$preferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    where?: UserPreferenceWhereInput
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.headedDepartments
   */
  export type User$headedDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    cursor?: DepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    headId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    headId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    name: number
    description: number
    headId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepartmentMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    headId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    headId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    headId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: string
    name: string
    description: string | null
    headId: string | null
    createdAt: Date
    updatedAt: Date
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    headId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    head?: boolean | Department$headArgs<ExtArgs>
    users?: boolean | Department$usersArgs<ExtArgs>
    Announcement?: boolean | Department$AnnouncementArgs<ExtArgs>
    JobPost?: boolean | Department$JobPostArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>



  export type DepartmentSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    headId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepartmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "headId" | "createdAt" | "updatedAt", ExtArgs["result"]["department"]>
  export type DepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    head?: boolean | Department$headArgs<ExtArgs>
    users?: boolean | Department$usersArgs<ExtArgs>
    Announcement?: boolean | Department$AnnouncementArgs<ExtArgs>
    JobPost?: boolean | Department$JobPostArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {
      head: Prisma.$UserPayload<ExtArgs> | null
      users: Prisma.$UserPayload<ExtArgs>[]
      Announcement: Prisma.$AnnouncementPayload<ExtArgs>[]
      JobPost: Prisma.$JobPostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      headId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    head<T extends Department$headArgs<ExtArgs> = {}>(args?: Subset<T, Department$headArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends Department$usersArgs<ExtArgs> = {}>(args?: Subset<T, Department$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Announcement<T extends Department$AnnouncementArgs<ExtArgs> = {}>(args?: Subset<T, Department$AnnouncementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    JobPost<T extends Department$JobPostArgs<ExtArgs> = {}>(args?: Subset<T, Department$JobPostArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */
  interface DepartmentFieldRefs {
    readonly id: FieldRef<"Department", 'String'>
    readonly name: FieldRef<"Department", 'String'>
    readonly description: FieldRef<"Department", 'String'>
    readonly headId: FieldRef<"Department", 'String'>
    readonly createdAt: FieldRef<"Department", 'DateTime'>
    readonly updatedAt: FieldRef<"Department", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to delete.
     */
    limit?: number
  }

  /**
   * Department.head
   */
  export type Department$headArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Department.users
   */
  export type Department$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Department.Announcement
   */
  export type Department$AnnouncementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    where?: AnnouncementWhereInput
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    cursor?: AnnouncementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Department.JobPost
   */
  export type Department$JobPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPost
     */
    omit?: JobPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostInclude<ExtArgs> | null
    where?: JobPostWhereInput
    orderBy?: JobPostOrderByWithRelationInput | JobPostOrderByWithRelationInput[]
    cursor?: JobPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobPostScalarFieldEnum | JobPostScalarFieldEnum[]
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    priority: $Enums.TaskPriority | null
    status: $Enums.TaskStatus | null
    dueDate: Date | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    priority: $Enums.TaskPriority | null
    status: $Enums.TaskStatus | null
    dueDate: Date | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    title: number
    description: number
    priority: number
    status: number
    dueDate: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaskMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    priority?: true
    status?: true
    dueDate?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    priority?: true
    status?: true
    dueDate?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    priority?: true
    status?: true
    dueDate?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    title: string
    description: string | null
    priority: $Enums.TaskPriority
    status: $Enums.TaskStatus
    dueDate: Date | null
    createdById: string
    createdAt: Date
    updatedAt: Date
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    status?: boolean
    dueDate?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    assignments?: boolean | Task$assignmentsArgs<ExtArgs>
    comments?: boolean | Task$commentsArgs<ExtArgs>
    timeLogs?: boolean | Task$timeLogsArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>



  export type TaskSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    status?: boolean
    dueDate?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "priority" | "status" | "dueDate" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["task"]>
  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    assignments?: boolean | Task$assignmentsArgs<ExtArgs>
    comments?: boolean | Task$commentsArgs<ExtArgs>
    timeLogs?: boolean | Task$timeLogsArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      assignments: Prisma.$TaskAssignmentPayload<ExtArgs>[]
      comments: Prisma.$TaskCommentPayload<ExtArgs>[]
      timeLogs: Prisma.$TaskTimeLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      priority: $Enums.TaskPriority
      status: $Enums.TaskStatus
      dueDate: Date | null
      createdById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignments<T extends Task$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Task$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends Task$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Task$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    timeLogs<T extends Task$timeLogsArgs<ExtArgs> = {}>(args?: Subset<T, Task$timeLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTimeLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly title: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly priority: FieldRef<"Task", 'TaskPriority'>
    readonly status: FieldRef<"Task", 'TaskStatus'>
    readonly dueDate: FieldRef<"Task", 'DateTime'>
    readonly createdById: FieldRef<"Task", 'String'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
    readonly updatedAt: FieldRef<"Task", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to delete.
     */
    limit?: number
  }

  /**
   * Task.assignments
   */
  export type Task$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    where?: TaskAssignmentWhereInput
    orderBy?: TaskAssignmentOrderByWithRelationInput | TaskAssignmentOrderByWithRelationInput[]
    cursor?: TaskAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskAssignmentScalarFieldEnum | TaskAssignmentScalarFieldEnum[]
  }

  /**
   * Task.comments
   */
  export type Task$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskComment
     */
    omit?: TaskCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentInclude<ExtArgs> | null
    where?: TaskCommentWhereInput
    orderBy?: TaskCommentOrderByWithRelationInput | TaskCommentOrderByWithRelationInput[]
    cursor?: TaskCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskCommentScalarFieldEnum | TaskCommentScalarFieldEnum[]
  }

  /**
   * Task.timeLogs
   */
  export type Task$timeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTimeLog
     */
    select?: TaskTimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTimeLog
     */
    omit?: TaskTimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTimeLogInclude<ExtArgs> | null
    where?: TaskTimeLogWhereInput
    orderBy?: TaskTimeLogOrderByWithRelationInput | TaskTimeLogOrderByWithRelationInput[]
    cursor?: TaskTimeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskTimeLogScalarFieldEnum | TaskTimeLogScalarFieldEnum[]
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model TaskAssignment
   */

  export type AggregateTaskAssignment = {
    _count: TaskAssignmentCountAggregateOutputType | null
    _min: TaskAssignmentMinAggregateOutputType | null
    _max: TaskAssignmentMaxAggregateOutputType | null
  }

  export type TaskAssignmentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    taskId: string | null
    assignedAt: Date | null
  }

  export type TaskAssignmentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    taskId: string | null
    assignedAt: Date | null
  }

  export type TaskAssignmentCountAggregateOutputType = {
    id: number
    userId: number
    taskId: number
    assignedAt: number
    _all: number
  }


  export type TaskAssignmentMinAggregateInputType = {
    id?: true
    userId?: true
    taskId?: true
    assignedAt?: true
  }

  export type TaskAssignmentMaxAggregateInputType = {
    id?: true
    userId?: true
    taskId?: true
    assignedAt?: true
  }

  export type TaskAssignmentCountAggregateInputType = {
    id?: true
    userId?: true
    taskId?: true
    assignedAt?: true
    _all?: true
  }

  export type TaskAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskAssignment to aggregate.
     */
    where?: TaskAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAssignments to fetch.
     */
    orderBy?: TaskAssignmentOrderByWithRelationInput | TaskAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskAssignments
    **/
    _count?: true | TaskAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskAssignmentMaxAggregateInputType
  }

  export type GetTaskAssignmentAggregateType<T extends TaskAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskAssignment[P]>
      : GetScalarType<T[P], AggregateTaskAssignment[P]>
  }




  export type TaskAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAssignmentWhereInput
    orderBy?: TaskAssignmentOrderByWithAggregationInput | TaskAssignmentOrderByWithAggregationInput[]
    by: TaskAssignmentScalarFieldEnum[] | TaskAssignmentScalarFieldEnum
    having?: TaskAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskAssignmentCountAggregateInputType | true
    _min?: TaskAssignmentMinAggregateInputType
    _max?: TaskAssignmentMaxAggregateInputType
  }

  export type TaskAssignmentGroupByOutputType = {
    id: string
    userId: string
    taskId: string
    assignedAt: Date
    _count: TaskAssignmentCountAggregateOutputType | null
    _min: TaskAssignmentMinAggregateOutputType | null
    _max: TaskAssignmentMaxAggregateOutputType | null
  }

  type GetTaskAssignmentGroupByPayload<T extends TaskAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], TaskAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type TaskAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    taskId?: boolean
    assignedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskAssignment"]>



  export type TaskAssignmentSelectScalar = {
    id?: boolean
    userId?: boolean
    taskId?: boolean
    assignedAt?: boolean
  }

  export type TaskAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "taskId" | "assignedAt", ExtArgs["result"]["taskAssignment"]>
  export type TaskAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }

  export type $TaskAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskAssignment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      task: Prisma.$TaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      taskId: string
      assignedAt: Date
    }, ExtArgs["result"]["taskAssignment"]>
    composites: {}
  }

  type TaskAssignmentGetPayload<S extends boolean | null | undefined | TaskAssignmentDefaultArgs> = $Result.GetResult<Prisma.$TaskAssignmentPayload, S>

  type TaskAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskAssignmentCountAggregateInputType | true
    }

  export interface TaskAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskAssignment'], meta: { name: 'TaskAssignment' } }
    /**
     * Find zero or one TaskAssignment that matches the filter.
     * @param {TaskAssignmentFindUniqueArgs} args - Arguments to find a TaskAssignment
     * @example
     * // Get one TaskAssignment
     * const taskAssignment = await prisma.taskAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskAssignmentFindUniqueArgs>(args: SelectSubset<T, TaskAssignmentFindUniqueArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskAssignmentFindUniqueOrThrowArgs} args - Arguments to find a TaskAssignment
     * @example
     * // Get one TaskAssignment
     * const taskAssignment = await prisma.taskAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssignmentFindFirstArgs} args - Arguments to find a TaskAssignment
     * @example
     * // Get one TaskAssignment
     * const taskAssignment = await prisma.taskAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskAssignmentFindFirstArgs>(args?: SelectSubset<T, TaskAssignmentFindFirstArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssignmentFindFirstOrThrowArgs} args - Arguments to find a TaskAssignment
     * @example
     * // Get one TaskAssignment
     * const taskAssignment = await prisma.taskAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskAssignments
     * const taskAssignments = await prisma.taskAssignment.findMany()
     * 
     * // Get first 10 TaskAssignments
     * const taskAssignments = await prisma.taskAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskAssignmentWithIdOnly = await prisma.taskAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskAssignmentFindManyArgs>(args?: SelectSubset<T, TaskAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskAssignment.
     * @param {TaskAssignmentCreateArgs} args - Arguments to create a TaskAssignment.
     * @example
     * // Create one TaskAssignment
     * const TaskAssignment = await prisma.taskAssignment.create({
     *   data: {
     *     // ... data to create a TaskAssignment
     *   }
     * })
     * 
     */
    create<T extends TaskAssignmentCreateArgs>(args: SelectSubset<T, TaskAssignmentCreateArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskAssignments.
     * @param {TaskAssignmentCreateManyArgs} args - Arguments to create many TaskAssignments.
     * @example
     * // Create many TaskAssignments
     * const taskAssignment = await prisma.taskAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskAssignmentCreateManyArgs>(args?: SelectSubset<T, TaskAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TaskAssignment.
     * @param {TaskAssignmentDeleteArgs} args - Arguments to delete one TaskAssignment.
     * @example
     * // Delete one TaskAssignment
     * const TaskAssignment = await prisma.taskAssignment.delete({
     *   where: {
     *     // ... filter to delete one TaskAssignment
     *   }
     * })
     * 
     */
    delete<T extends TaskAssignmentDeleteArgs>(args: SelectSubset<T, TaskAssignmentDeleteArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskAssignment.
     * @param {TaskAssignmentUpdateArgs} args - Arguments to update one TaskAssignment.
     * @example
     * // Update one TaskAssignment
     * const taskAssignment = await prisma.taskAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskAssignmentUpdateArgs>(args: SelectSubset<T, TaskAssignmentUpdateArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskAssignments.
     * @param {TaskAssignmentDeleteManyArgs} args - Arguments to filter TaskAssignments to delete.
     * @example
     * // Delete a few TaskAssignments
     * const { count } = await prisma.taskAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskAssignmentDeleteManyArgs>(args?: SelectSubset<T, TaskAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskAssignments
     * const taskAssignment = await prisma.taskAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskAssignmentUpdateManyArgs>(args: SelectSubset<T, TaskAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskAssignment.
     * @param {TaskAssignmentUpsertArgs} args - Arguments to update or create a TaskAssignment.
     * @example
     * // Update or create a TaskAssignment
     * const taskAssignment = await prisma.taskAssignment.upsert({
     *   create: {
     *     // ... data to create a TaskAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskAssignment we want to update
     *   }
     * })
     */
    upsert<T extends TaskAssignmentUpsertArgs>(args: SelectSubset<T, TaskAssignmentUpsertArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssignmentCountArgs} args - Arguments to filter TaskAssignments to count.
     * @example
     * // Count the number of TaskAssignments
     * const count = await prisma.taskAssignment.count({
     *   where: {
     *     // ... the filter for the TaskAssignments we want to count
     *   }
     * })
    **/
    count<T extends TaskAssignmentCountArgs>(
      args?: Subset<T, TaskAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAssignmentAggregateArgs>(args: Subset<T, TaskAssignmentAggregateArgs>): Prisma.PrismaPromise<GetTaskAssignmentAggregateType<T>>

    /**
     * Group by TaskAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: TaskAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskAssignment model
   */
  readonly fields: TaskAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskAssignment model
   */
  interface TaskAssignmentFieldRefs {
    readonly id: FieldRef<"TaskAssignment", 'String'>
    readonly userId: FieldRef<"TaskAssignment", 'String'>
    readonly taskId: FieldRef<"TaskAssignment", 'String'>
    readonly assignedAt: FieldRef<"TaskAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskAssignment findUnique
   */
  export type TaskAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignment to fetch.
     */
    where: TaskAssignmentWhereUniqueInput
  }

  /**
   * TaskAssignment findUniqueOrThrow
   */
  export type TaskAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignment to fetch.
     */
    where: TaskAssignmentWhereUniqueInput
  }

  /**
   * TaskAssignment findFirst
   */
  export type TaskAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignment to fetch.
     */
    where?: TaskAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAssignments to fetch.
     */
    orderBy?: TaskAssignmentOrderByWithRelationInput | TaskAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskAssignments.
     */
    cursor?: TaskAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskAssignments.
     */
    distinct?: TaskAssignmentScalarFieldEnum | TaskAssignmentScalarFieldEnum[]
  }

  /**
   * TaskAssignment findFirstOrThrow
   */
  export type TaskAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignment to fetch.
     */
    where?: TaskAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAssignments to fetch.
     */
    orderBy?: TaskAssignmentOrderByWithRelationInput | TaskAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskAssignments.
     */
    cursor?: TaskAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskAssignments.
     */
    distinct?: TaskAssignmentScalarFieldEnum | TaskAssignmentScalarFieldEnum[]
  }

  /**
   * TaskAssignment findMany
   */
  export type TaskAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignments to fetch.
     */
    where?: TaskAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAssignments to fetch.
     */
    orderBy?: TaskAssignmentOrderByWithRelationInput | TaskAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskAssignments.
     */
    cursor?: TaskAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAssignments.
     */
    skip?: number
    distinct?: TaskAssignmentScalarFieldEnum | TaskAssignmentScalarFieldEnum[]
  }

  /**
   * TaskAssignment create
   */
  export type TaskAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskAssignment.
     */
    data: XOR<TaskAssignmentCreateInput, TaskAssignmentUncheckedCreateInput>
  }

  /**
   * TaskAssignment createMany
   */
  export type TaskAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskAssignments.
     */
    data: TaskAssignmentCreateManyInput | TaskAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskAssignment update
   */
  export type TaskAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskAssignment.
     */
    data: XOR<TaskAssignmentUpdateInput, TaskAssignmentUncheckedUpdateInput>
    /**
     * Choose, which TaskAssignment to update.
     */
    where: TaskAssignmentWhereUniqueInput
  }

  /**
   * TaskAssignment updateMany
   */
  export type TaskAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskAssignments.
     */
    data: XOR<TaskAssignmentUpdateManyMutationInput, TaskAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which TaskAssignments to update
     */
    where?: TaskAssignmentWhereInput
    /**
     * Limit how many TaskAssignments to update.
     */
    limit?: number
  }

  /**
   * TaskAssignment upsert
   */
  export type TaskAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskAssignment to update in case it exists.
     */
    where: TaskAssignmentWhereUniqueInput
    /**
     * In case the TaskAssignment found by the `where` argument doesn't exist, create a new TaskAssignment with this data.
     */
    create: XOR<TaskAssignmentCreateInput, TaskAssignmentUncheckedCreateInput>
    /**
     * In case the TaskAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskAssignmentUpdateInput, TaskAssignmentUncheckedUpdateInput>
  }

  /**
   * TaskAssignment delete
   */
  export type TaskAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * Filter which TaskAssignment to delete.
     */
    where: TaskAssignmentWhereUniqueInput
  }

  /**
   * TaskAssignment deleteMany
   */
  export type TaskAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskAssignments to delete
     */
    where?: TaskAssignmentWhereInput
    /**
     * Limit how many TaskAssignments to delete.
     */
    limit?: number
  }

  /**
   * TaskAssignment without action
   */
  export type TaskAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model TaskComment
   */

  export type AggregateTaskComment = {
    _count: TaskCommentCountAggregateOutputType | null
    _min: TaskCommentMinAggregateOutputType | null
    _max: TaskCommentMaxAggregateOutputType | null
  }

  export type TaskCommentMinAggregateOutputType = {
    id: string | null
    taskId: string | null
    userId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type TaskCommentMaxAggregateOutputType = {
    id: string | null
    taskId: string | null
    userId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type TaskCommentCountAggregateOutputType = {
    id: number
    taskId: number
    userId: number
    content: number
    createdAt: number
    _all: number
  }


  export type TaskCommentMinAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    content?: true
    createdAt?: true
  }

  export type TaskCommentMaxAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    content?: true
    createdAt?: true
  }

  export type TaskCommentCountAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type TaskCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskComment to aggregate.
     */
    where?: TaskCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskComments to fetch.
     */
    orderBy?: TaskCommentOrderByWithRelationInput | TaskCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskComments
    **/
    _count?: true | TaskCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskCommentMaxAggregateInputType
  }

  export type GetTaskCommentAggregateType<T extends TaskCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskComment[P]>
      : GetScalarType<T[P], AggregateTaskComment[P]>
  }




  export type TaskCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskCommentWhereInput
    orderBy?: TaskCommentOrderByWithAggregationInput | TaskCommentOrderByWithAggregationInput[]
    by: TaskCommentScalarFieldEnum[] | TaskCommentScalarFieldEnum
    having?: TaskCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCommentCountAggregateInputType | true
    _min?: TaskCommentMinAggregateInputType
    _max?: TaskCommentMaxAggregateInputType
  }

  export type TaskCommentGroupByOutputType = {
    id: string
    taskId: string
    userId: string
    content: string
    createdAt: Date
    _count: TaskCommentCountAggregateOutputType | null
    _min: TaskCommentMinAggregateOutputType | null
    _max: TaskCommentMaxAggregateOutputType | null
  }

  type GetTaskCommentGroupByPayload<T extends TaskCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskCommentGroupByOutputType[P]>
            : GetScalarType<T[P], TaskCommentGroupByOutputType[P]>
        }
      >
    >


  export type TaskCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskComment"]>



  export type TaskCommentSelectScalar = {
    id?: boolean
    taskId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type TaskCommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskId" | "userId" | "content" | "createdAt", ExtArgs["result"]["taskComment"]>
  export type TaskCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TaskCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskComment"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskId: string
      userId: string
      content: string
      createdAt: Date
    }, ExtArgs["result"]["taskComment"]>
    composites: {}
  }

  type TaskCommentGetPayload<S extends boolean | null | undefined | TaskCommentDefaultArgs> = $Result.GetResult<Prisma.$TaskCommentPayload, S>

  type TaskCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskCommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCommentCountAggregateInputType | true
    }

  export interface TaskCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskComment'], meta: { name: 'TaskComment' } }
    /**
     * Find zero or one TaskComment that matches the filter.
     * @param {TaskCommentFindUniqueArgs} args - Arguments to find a TaskComment
     * @example
     * // Get one TaskComment
     * const taskComment = await prisma.taskComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskCommentFindUniqueArgs>(args: SelectSubset<T, TaskCommentFindUniqueArgs<ExtArgs>>): Prisma__TaskCommentClient<$Result.GetResult<Prisma.$TaskCommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskComment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskCommentFindUniqueOrThrowArgs} args - Arguments to find a TaskComment
     * @example
     * // Get one TaskComment
     * const taskComment = await prisma.taskComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskCommentClient<$Result.GetResult<Prisma.$TaskCommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCommentFindFirstArgs} args - Arguments to find a TaskComment
     * @example
     * // Get one TaskComment
     * const taskComment = await prisma.taskComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskCommentFindFirstArgs>(args?: SelectSubset<T, TaskCommentFindFirstArgs<ExtArgs>>): Prisma__TaskCommentClient<$Result.GetResult<Prisma.$TaskCommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCommentFindFirstOrThrowArgs} args - Arguments to find a TaskComment
     * @example
     * // Get one TaskComment
     * const taskComment = await prisma.taskComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskCommentClient<$Result.GetResult<Prisma.$TaskCommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskComments
     * const taskComments = await prisma.taskComment.findMany()
     * 
     * // Get first 10 TaskComments
     * const taskComments = await prisma.taskComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskCommentWithIdOnly = await prisma.taskComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskCommentFindManyArgs>(args?: SelectSubset<T, TaskCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskComment.
     * @param {TaskCommentCreateArgs} args - Arguments to create a TaskComment.
     * @example
     * // Create one TaskComment
     * const TaskComment = await prisma.taskComment.create({
     *   data: {
     *     // ... data to create a TaskComment
     *   }
     * })
     * 
     */
    create<T extends TaskCommentCreateArgs>(args: SelectSubset<T, TaskCommentCreateArgs<ExtArgs>>): Prisma__TaskCommentClient<$Result.GetResult<Prisma.$TaskCommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskComments.
     * @param {TaskCommentCreateManyArgs} args - Arguments to create many TaskComments.
     * @example
     * // Create many TaskComments
     * const taskComment = await prisma.taskComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCommentCreateManyArgs>(args?: SelectSubset<T, TaskCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TaskComment.
     * @param {TaskCommentDeleteArgs} args - Arguments to delete one TaskComment.
     * @example
     * // Delete one TaskComment
     * const TaskComment = await prisma.taskComment.delete({
     *   where: {
     *     // ... filter to delete one TaskComment
     *   }
     * })
     * 
     */
    delete<T extends TaskCommentDeleteArgs>(args: SelectSubset<T, TaskCommentDeleteArgs<ExtArgs>>): Prisma__TaskCommentClient<$Result.GetResult<Prisma.$TaskCommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskComment.
     * @param {TaskCommentUpdateArgs} args - Arguments to update one TaskComment.
     * @example
     * // Update one TaskComment
     * const taskComment = await prisma.taskComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskCommentUpdateArgs>(args: SelectSubset<T, TaskCommentUpdateArgs<ExtArgs>>): Prisma__TaskCommentClient<$Result.GetResult<Prisma.$TaskCommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskComments.
     * @param {TaskCommentDeleteManyArgs} args - Arguments to filter TaskComments to delete.
     * @example
     * // Delete a few TaskComments
     * const { count } = await prisma.taskComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskCommentDeleteManyArgs>(args?: SelectSubset<T, TaskCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskComments
     * const taskComment = await prisma.taskComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskCommentUpdateManyArgs>(args: SelectSubset<T, TaskCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskComment.
     * @param {TaskCommentUpsertArgs} args - Arguments to update or create a TaskComment.
     * @example
     * // Update or create a TaskComment
     * const taskComment = await prisma.taskComment.upsert({
     *   create: {
     *     // ... data to create a TaskComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskComment we want to update
     *   }
     * })
     */
    upsert<T extends TaskCommentUpsertArgs>(args: SelectSubset<T, TaskCommentUpsertArgs<ExtArgs>>): Prisma__TaskCommentClient<$Result.GetResult<Prisma.$TaskCommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCommentCountArgs} args - Arguments to filter TaskComments to count.
     * @example
     * // Count the number of TaskComments
     * const count = await prisma.taskComment.count({
     *   where: {
     *     // ... the filter for the TaskComments we want to count
     *   }
     * })
    **/
    count<T extends TaskCommentCountArgs>(
      args?: Subset<T, TaskCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskCommentAggregateArgs>(args: Subset<T, TaskCommentAggregateArgs>): Prisma.PrismaPromise<GetTaskCommentAggregateType<T>>

    /**
     * Group by TaskComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskCommentGroupByArgs['orderBy'] }
        : { orderBy?: TaskCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskComment model
   */
  readonly fields: TaskCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskComment model
   */
  interface TaskCommentFieldRefs {
    readonly id: FieldRef<"TaskComment", 'String'>
    readonly taskId: FieldRef<"TaskComment", 'String'>
    readonly userId: FieldRef<"TaskComment", 'String'>
    readonly content: FieldRef<"TaskComment", 'String'>
    readonly createdAt: FieldRef<"TaskComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskComment findUnique
   */
  export type TaskCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskComment
     */
    omit?: TaskCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentInclude<ExtArgs> | null
    /**
     * Filter, which TaskComment to fetch.
     */
    where: TaskCommentWhereUniqueInput
  }

  /**
   * TaskComment findUniqueOrThrow
   */
  export type TaskCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskComment
     */
    omit?: TaskCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentInclude<ExtArgs> | null
    /**
     * Filter, which TaskComment to fetch.
     */
    where: TaskCommentWhereUniqueInput
  }

  /**
   * TaskComment findFirst
   */
  export type TaskCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskComment
     */
    omit?: TaskCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentInclude<ExtArgs> | null
    /**
     * Filter, which TaskComment to fetch.
     */
    where?: TaskCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskComments to fetch.
     */
    orderBy?: TaskCommentOrderByWithRelationInput | TaskCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskComments.
     */
    cursor?: TaskCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskComments.
     */
    distinct?: TaskCommentScalarFieldEnum | TaskCommentScalarFieldEnum[]
  }

  /**
   * TaskComment findFirstOrThrow
   */
  export type TaskCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskComment
     */
    omit?: TaskCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentInclude<ExtArgs> | null
    /**
     * Filter, which TaskComment to fetch.
     */
    where?: TaskCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskComments to fetch.
     */
    orderBy?: TaskCommentOrderByWithRelationInput | TaskCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskComments.
     */
    cursor?: TaskCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskComments.
     */
    distinct?: TaskCommentScalarFieldEnum | TaskCommentScalarFieldEnum[]
  }

  /**
   * TaskComment findMany
   */
  export type TaskCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskComment
     */
    omit?: TaskCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentInclude<ExtArgs> | null
    /**
     * Filter, which TaskComments to fetch.
     */
    where?: TaskCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskComments to fetch.
     */
    orderBy?: TaskCommentOrderByWithRelationInput | TaskCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskComments.
     */
    cursor?: TaskCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskComments.
     */
    skip?: number
    distinct?: TaskCommentScalarFieldEnum | TaskCommentScalarFieldEnum[]
  }

  /**
   * TaskComment create
   */
  export type TaskCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskComment
     */
    omit?: TaskCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskComment.
     */
    data: XOR<TaskCommentCreateInput, TaskCommentUncheckedCreateInput>
  }

  /**
   * TaskComment createMany
   */
  export type TaskCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskComments.
     */
    data: TaskCommentCreateManyInput | TaskCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskComment update
   */
  export type TaskCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskComment
     */
    omit?: TaskCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskComment.
     */
    data: XOR<TaskCommentUpdateInput, TaskCommentUncheckedUpdateInput>
    /**
     * Choose, which TaskComment to update.
     */
    where: TaskCommentWhereUniqueInput
  }

  /**
   * TaskComment updateMany
   */
  export type TaskCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskComments.
     */
    data: XOR<TaskCommentUpdateManyMutationInput, TaskCommentUncheckedUpdateManyInput>
    /**
     * Filter which TaskComments to update
     */
    where?: TaskCommentWhereInput
    /**
     * Limit how many TaskComments to update.
     */
    limit?: number
  }

  /**
   * TaskComment upsert
   */
  export type TaskCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskComment
     */
    omit?: TaskCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskComment to update in case it exists.
     */
    where: TaskCommentWhereUniqueInput
    /**
     * In case the TaskComment found by the `where` argument doesn't exist, create a new TaskComment with this data.
     */
    create: XOR<TaskCommentCreateInput, TaskCommentUncheckedCreateInput>
    /**
     * In case the TaskComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskCommentUpdateInput, TaskCommentUncheckedUpdateInput>
  }

  /**
   * TaskComment delete
   */
  export type TaskCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskComment
     */
    omit?: TaskCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentInclude<ExtArgs> | null
    /**
     * Filter which TaskComment to delete.
     */
    where: TaskCommentWhereUniqueInput
  }

  /**
   * TaskComment deleteMany
   */
  export type TaskCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskComments to delete
     */
    where?: TaskCommentWhereInput
    /**
     * Limit how many TaskComments to delete.
     */
    limit?: number
  }

  /**
   * TaskComment without action
   */
  export type TaskCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskComment
     */
    omit?: TaskCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentInclude<ExtArgs> | null
  }


  /**
   * Model TaskTimeLog
   */

  export type AggregateTaskTimeLog = {
    _count: TaskTimeLogCountAggregateOutputType | null
    _avg: TaskTimeLogAvgAggregateOutputType | null
    _sum: TaskTimeLogSumAggregateOutputType | null
    _min: TaskTimeLogMinAggregateOutputType | null
    _max: TaskTimeLogMaxAggregateOutputType | null
  }

  export type TaskTimeLogAvgAggregateOutputType = {
    durationSeconds: number | null
  }

  export type TaskTimeLogSumAggregateOutputType = {
    durationSeconds: number | null
  }

  export type TaskTimeLogMinAggregateOutputType = {
    id: string | null
    taskId: string | null
    userId: string | null
    startedAt: Date | null
    endedAt: Date | null
    durationSeconds: number | null
  }

  export type TaskTimeLogMaxAggregateOutputType = {
    id: string | null
    taskId: string | null
    userId: string | null
    startedAt: Date | null
    endedAt: Date | null
    durationSeconds: number | null
  }

  export type TaskTimeLogCountAggregateOutputType = {
    id: number
    taskId: number
    userId: number
    startedAt: number
    endedAt: number
    durationSeconds: number
    _all: number
  }


  export type TaskTimeLogAvgAggregateInputType = {
    durationSeconds?: true
  }

  export type TaskTimeLogSumAggregateInputType = {
    durationSeconds?: true
  }

  export type TaskTimeLogMinAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    startedAt?: true
    endedAt?: true
    durationSeconds?: true
  }

  export type TaskTimeLogMaxAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    startedAt?: true
    endedAt?: true
    durationSeconds?: true
  }

  export type TaskTimeLogCountAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    startedAt?: true
    endedAt?: true
    durationSeconds?: true
    _all?: true
  }

  export type TaskTimeLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskTimeLog to aggregate.
     */
    where?: TaskTimeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskTimeLogs to fetch.
     */
    orderBy?: TaskTimeLogOrderByWithRelationInput | TaskTimeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskTimeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskTimeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskTimeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskTimeLogs
    **/
    _count?: true | TaskTimeLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskTimeLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskTimeLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskTimeLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskTimeLogMaxAggregateInputType
  }

  export type GetTaskTimeLogAggregateType<T extends TaskTimeLogAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskTimeLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskTimeLog[P]>
      : GetScalarType<T[P], AggregateTaskTimeLog[P]>
  }




  export type TaskTimeLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskTimeLogWhereInput
    orderBy?: TaskTimeLogOrderByWithAggregationInput | TaskTimeLogOrderByWithAggregationInput[]
    by: TaskTimeLogScalarFieldEnum[] | TaskTimeLogScalarFieldEnum
    having?: TaskTimeLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskTimeLogCountAggregateInputType | true
    _avg?: TaskTimeLogAvgAggregateInputType
    _sum?: TaskTimeLogSumAggregateInputType
    _min?: TaskTimeLogMinAggregateInputType
    _max?: TaskTimeLogMaxAggregateInputType
  }

  export type TaskTimeLogGroupByOutputType = {
    id: string
    taskId: string
    userId: string
    startedAt: Date
    endedAt: Date | null
    durationSeconds: number | null
    _count: TaskTimeLogCountAggregateOutputType | null
    _avg: TaskTimeLogAvgAggregateOutputType | null
    _sum: TaskTimeLogSumAggregateOutputType | null
    _min: TaskTimeLogMinAggregateOutputType | null
    _max: TaskTimeLogMaxAggregateOutputType | null
  }

  type GetTaskTimeLogGroupByPayload<T extends TaskTimeLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskTimeLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskTimeLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskTimeLogGroupByOutputType[P]>
            : GetScalarType<T[P], TaskTimeLogGroupByOutputType[P]>
        }
      >
    >


  export type TaskTimeLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    userId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    durationSeconds?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskTimeLog"]>



  export type TaskTimeLogSelectScalar = {
    id?: boolean
    taskId?: boolean
    userId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    durationSeconds?: boolean
  }

  export type TaskTimeLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskId" | "userId" | "startedAt" | "endedAt" | "durationSeconds", ExtArgs["result"]["taskTimeLog"]>
  export type TaskTimeLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TaskTimeLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskTimeLog"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskId: string
      userId: string
      startedAt: Date
      endedAt: Date | null
      durationSeconds: number | null
    }, ExtArgs["result"]["taskTimeLog"]>
    composites: {}
  }

  type TaskTimeLogGetPayload<S extends boolean | null | undefined | TaskTimeLogDefaultArgs> = $Result.GetResult<Prisma.$TaskTimeLogPayload, S>

  type TaskTimeLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskTimeLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskTimeLogCountAggregateInputType | true
    }

  export interface TaskTimeLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskTimeLog'], meta: { name: 'TaskTimeLog' } }
    /**
     * Find zero or one TaskTimeLog that matches the filter.
     * @param {TaskTimeLogFindUniqueArgs} args - Arguments to find a TaskTimeLog
     * @example
     * // Get one TaskTimeLog
     * const taskTimeLog = await prisma.taskTimeLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskTimeLogFindUniqueArgs>(args: SelectSubset<T, TaskTimeLogFindUniqueArgs<ExtArgs>>): Prisma__TaskTimeLogClient<$Result.GetResult<Prisma.$TaskTimeLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskTimeLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskTimeLogFindUniqueOrThrowArgs} args - Arguments to find a TaskTimeLog
     * @example
     * // Get one TaskTimeLog
     * const taskTimeLog = await prisma.taskTimeLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskTimeLogFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskTimeLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskTimeLogClient<$Result.GetResult<Prisma.$TaskTimeLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskTimeLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTimeLogFindFirstArgs} args - Arguments to find a TaskTimeLog
     * @example
     * // Get one TaskTimeLog
     * const taskTimeLog = await prisma.taskTimeLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskTimeLogFindFirstArgs>(args?: SelectSubset<T, TaskTimeLogFindFirstArgs<ExtArgs>>): Prisma__TaskTimeLogClient<$Result.GetResult<Prisma.$TaskTimeLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskTimeLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTimeLogFindFirstOrThrowArgs} args - Arguments to find a TaskTimeLog
     * @example
     * // Get one TaskTimeLog
     * const taskTimeLog = await prisma.taskTimeLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskTimeLogFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskTimeLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskTimeLogClient<$Result.GetResult<Prisma.$TaskTimeLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskTimeLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTimeLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskTimeLogs
     * const taskTimeLogs = await prisma.taskTimeLog.findMany()
     * 
     * // Get first 10 TaskTimeLogs
     * const taskTimeLogs = await prisma.taskTimeLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskTimeLogWithIdOnly = await prisma.taskTimeLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskTimeLogFindManyArgs>(args?: SelectSubset<T, TaskTimeLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTimeLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskTimeLog.
     * @param {TaskTimeLogCreateArgs} args - Arguments to create a TaskTimeLog.
     * @example
     * // Create one TaskTimeLog
     * const TaskTimeLog = await prisma.taskTimeLog.create({
     *   data: {
     *     // ... data to create a TaskTimeLog
     *   }
     * })
     * 
     */
    create<T extends TaskTimeLogCreateArgs>(args: SelectSubset<T, TaskTimeLogCreateArgs<ExtArgs>>): Prisma__TaskTimeLogClient<$Result.GetResult<Prisma.$TaskTimeLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskTimeLogs.
     * @param {TaskTimeLogCreateManyArgs} args - Arguments to create many TaskTimeLogs.
     * @example
     * // Create many TaskTimeLogs
     * const taskTimeLog = await prisma.taskTimeLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskTimeLogCreateManyArgs>(args?: SelectSubset<T, TaskTimeLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TaskTimeLog.
     * @param {TaskTimeLogDeleteArgs} args - Arguments to delete one TaskTimeLog.
     * @example
     * // Delete one TaskTimeLog
     * const TaskTimeLog = await prisma.taskTimeLog.delete({
     *   where: {
     *     // ... filter to delete one TaskTimeLog
     *   }
     * })
     * 
     */
    delete<T extends TaskTimeLogDeleteArgs>(args: SelectSubset<T, TaskTimeLogDeleteArgs<ExtArgs>>): Prisma__TaskTimeLogClient<$Result.GetResult<Prisma.$TaskTimeLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskTimeLog.
     * @param {TaskTimeLogUpdateArgs} args - Arguments to update one TaskTimeLog.
     * @example
     * // Update one TaskTimeLog
     * const taskTimeLog = await prisma.taskTimeLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskTimeLogUpdateArgs>(args: SelectSubset<T, TaskTimeLogUpdateArgs<ExtArgs>>): Prisma__TaskTimeLogClient<$Result.GetResult<Prisma.$TaskTimeLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskTimeLogs.
     * @param {TaskTimeLogDeleteManyArgs} args - Arguments to filter TaskTimeLogs to delete.
     * @example
     * // Delete a few TaskTimeLogs
     * const { count } = await prisma.taskTimeLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskTimeLogDeleteManyArgs>(args?: SelectSubset<T, TaskTimeLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskTimeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTimeLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskTimeLogs
     * const taskTimeLog = await prisma.taskTimeLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskTimeLogUpdateManyArgs>(args: SelectSubset<T, TaskTimeLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskTimeLog.
     * @param {TaskTimeLogUpsertArgs} args - Arguments to update or create a TaskTimeLog.
     * @example
     * // Update or create a TaskTimeLog
     * const taskTimeLog = await prisma.taskTimeLog.upsert({
     *   create: {
     *     // ... data to create a TaskTimeLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskTimeLog we want to update
     *   }
     * })
     */
    upsert<T extends TaskTimeLogUpsertArgs>(args: SelectSubset<T, TaskTimeLogUpsertArgs<ExtArgs>>): Prisma__TaskTimeLogClient<$Result.GetResult<Prisma.$TaskTimeLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskTimeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTimeLogCountArgs} args - Arguments to filter TaskTimeLogs to count.
     * @example
     * // Count the number of TaskTimeLogs
     * const count = await prisma.taskTimeLog.count({
     *   where: {
     *     // ... the filter for the TaskTimeLogs we want to count
     *   }
     * })
    **/
    count<T extends TaskTimeLogCountArgs>(
      args?: Subset<T, TaskTimeLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskTimeLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskTimeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTimeLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskTimeLogAggregateArgs>(args: Subset<T, TaskTimeLogAggregateArgs>): Prisma.PrismaPromise<GetTaskTimeLogAggregateType<T>>

    /**
     * Group by TaskTimeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTimeLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskTimeLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskTimeLogGroupByArgs['orderBy'] }
        : { orderBy?: TaskTimeLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskTimeLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskTimeLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskTimeLog model
   */
  readonly fields: TaskTimeLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskTimeLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskTimeLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskTimeLog model
   */
  interface TaskTimeLogFieldRefs {
    readonly id: FieldRef<"TaskTimeLog", 'String'>
    readonly taskId: FieldRef<"TaskTimeLog", 'String'>
    readonly userId: FieldRef<"TaskTimeLog", 'String'>
    readonly startedAt: FieldRef<"TaskTimeLog", 'DateTime'>
    readonly endedAt: FieldRef<"TaskTimeLog", 'DateTime'>
    readonly durationSeconds: FieldRef<"TaskTimeLog", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TaskTimeLog findUnique
   */
  export type TaskTimeLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTimeLog
     */
    select?: TaskTimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTimeLog
     */
    omit?: TaskTimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTimeLogInclude<ExtArgs> | null
    /**
     * Filter, which TaskTimeLog to fetch.
     */
    where: TaskTimeLogWhereUniqueInput
  }

  /**
   * TaskTimeLog findUniqueOrThrow
   */
  export type TaskTimeLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTimeLog
     */
    select?: TaskTimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTimeLog
     */
    omit?: TaskTimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTimeLogInclude<ExtArgs> | null
    /**
     * Filter, which TaskTimeLog to fetch.
     */
    where: TaskTimeLogWhereUniqueInput
  }

  /**
   * TaskTimeLog findFirst
   */
  export type TaskTimeLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTimeLog
     */
    select?: TaskTimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTimeLog
     */
    omit?: TaskTimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTimeLogInclude<ExtArgs> | null
    /**
     * Filter, which TaskTimeLog to fetch.
     */
    where?: TaskTimeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskTimeLogs to fetch.
     */
    orderBy?: TaskTimeLogOrderByWithRelationInput | TaskTimeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskTimeLogs.
     */
    cursor?: TaskTimeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskTimeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskTimeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskTimeLogs.
     */
    distinct?: TaskTimeLogScalarFieldEnum | TaskTimeLogScalarFieldEnum[]
  }

  /**
   * TaskTimeLog findFirstOrThrow
   */
  export type TaskTimeLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTimeLog
     */
    select?: TaskTimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTimeLog
     */
    omit?: TaskTimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTimeLogInclude<ExtArgs> | null
    /**
     * Filter, which TaskTimeLog to fetch.
     */
    where?: TaskTimeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskTimeLogs to fetch.
     */
    orderBy?: TaskTimeLogOrderByWithRelationInput | TaskTimeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskTimeLogs.
     */
    cursor?: TaskTimeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskTimeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskTimeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskTimeLogs.
     */
    distinct?: TaskTimeLogScalarFieldEnum | TaskTimeLogScalarFieldEnum[]
  }

  /**
   * TaskTimeLog findMany
   */
  export type TaskTimeLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTimeLog
     */
    select?: TaskTimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTimeLog
     */
    omit?: TaskTimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTimeLogInclude<ExtArgs> | null
    /**
     * Filter, which TaskTimeLogs to fetch.
     */
    where?: TaskTimeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskTimeLogs to fetch.
     */
    orderBy?: TaskTimeLogOrderByWithRelationInput | TaskTimeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskTimeLogs.
     */
    cursor?: TaskTimeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskTimeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskTimeLogs.
     */
    skip?: number
    distinct?: TaskTimeLogScalarFieldEnum | TaskTimeLogScalarFieldEnum[]
  }

  /**
   * TaskTimeLog create
   */
  export type TaskTimeLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTimeLog
     */
    select?: TaskTimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTimeLog
     */
    omit?: TaskTimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTimeLogInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskTimeLog.
     */
    data: XOR<TaskTimeLogCreateInput, TaskTimeLogUncheckedCreateInput>
  }

  /**
   * TaskTimeLog createMany
   */
  export type TaskTimeLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskTimeLogs.
     */
    data: TaskTimeLogCreateManyInput | TaskTimeLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskTimeLog update
   */
  export type TaskTimeLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTimeLog
     */
    select?: TaskTimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTimeLog
     */
    omit?: TaskTimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTimeLogInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskTimeLog.
     */
    data: XOR<TaskTimeLogUpdateInput, TaskTimeLogUncheckedUpdateInput>
    /**
     * Choose, which TaskTimeLog to update.
     */
    where: TaskTimeLogWhereUniqueInput
  }

  /**
   * TaskTimeLog updateMany
   */
  export type TaskTimeLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskTimeLogs.
     */
    data: XOR<TaskTimeLogUpdateManyMutationInput, TaskTimeLogUncheckedUpdateManyInput>
    /**
     * Filter which TaskTimeLogs to update
     */
    where?: TaskTimeLogWhereInput
    /**
     * Limit how many TaskTimeLogs to update.
     */
    limit?: number
  }

  /**
   * TaskTimeLog upsert
   */
  export type TaskTimeLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTimeLog
     */
    select?: TaskTimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTimeLog
     */
    omit?: TaskTimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTimeLogInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskTimeLog to update in case it exists.
     */
    where: TaskTimeLogWhereUniqueInput
    /**
     * In case the TaskTimeLog found by the `where` argument doesn't exist, create a new TaskTimeLog with this data.
     */
    create: XOR<TaskTimeLogCreateInput, TaskTimeLogUncheckedCreateInput>
    /**
     * In case the TaskTimeLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskTimeLogUpdateInput, TaskTimeLogUncheckedUpdateInput>
  }

  /**
   * TaskTimeLog delete
   */
  export type TaskTimeLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTimeLog
     */
    select?: TaskTimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTimeLog
     */
    omit?: TaskTimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTimeLogInclude<ExtArgs> | null
    /**
     * Filter which TaskTimeLog to delete.
     */
    where: TaskTimeLogWhereUniqueInput
  }

  /**
   * TaskTimeLog deleteMany
   */
  export type TaskTimeLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskTimeLogs to delete
     */
    where?: TaskTimeLogWhereInput
    /**
     * Limit how many TaskTimeLogs to delete.
     */
    limit?: number
  }

  /**
   * TaskTimeLog without action
   */
  export type TaskTimeLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTimeLog
     */
    select?: TaskTimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTimeLog
     */
    omit?: TaskTimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTimeLogInclude<ExtArgs> | null
  }


  /**
   * Model AttendanceRecord
   */

  export type AggregateAttendanceRecord = {
    _count: AttendanceRecordCountAggregateOutputType | null
    _min: AttendanceRecordMinAggregateOutputType | null
    _max: AttendanceRecordMaxAggregateOutputType | null
  }

  export type AttendanceRecordMinAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    clockIn: Date | null
    clockOut: Date | null
    status: $Enums.AttendanceStatus | null
    ipAddress: string | null
    location: string | null
  }

  export type AttendanceRecordMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    clockIn: Date | null
    clockOut: Date | null
    status: $Enums.AttendanceStatus | null
    ipAddress: string | null
    location: string | null
  }

  export type AttendanceRecordCountAggregateOutputType = {
    id: number
    userId: number
    date: number
    clockIn: number
    clockOut: number
    status: number
    ipAddress: number
    location: number
    _all: number
  }


  export type AttendanceRecordMinAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    clockIn?: true
    clockOut?: true
    status?: true
    ipAddress?: true
    location?: true
  }

  export type AttendanceRecordMaxAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    clockIn?: true
    clockOut?: true
    status?: true
    ipAddress?: true
    location?: true
  }

  export type AttendanceRecordCountAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    clockIn?: true
    clockOut?: true
    status?: true
    ipAddress?: true
    location?: true
    _all?: true
  }

  export type AttendanceRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceRecord to aggregate.
     */
    where?: AttendanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceRecords to fetch.
     */
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttendanceRecords
    **/
    _count?: true | AttendanceRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceRecordMaxAggregateInputType
  }

  export type GetAttendanceRecordAggregateType<T extends AttendanceRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendanceRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendanceRecord[P]>
      : GetScalarType<T[P], AggregateAttendanceRecord[P]>
  }




  export type AttendanceRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceRecordWhereInput
    orderBy?: AttendanceRecordOrderByWithAggregationInput | AttendanceRecordOrderByWithAggregationInput[]
    by: AttendanceRecordScalarFieldEnum[] | AttendanceRecordScalarFieldEnum
    having?: AttendanceRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceRecordCountAggregateInputType | true
    _min?: AttendanceRecordMinAggregateInputType
    _max?: AttendanceRecordMaxAggregateInputType
  }

  export type AttendanceRecordGroupByOutputType = {
    id: string
    userId: string
    date: Date
    clockIn: Date | null
    clockOut: Date | null
    status: $Enums.AttendanceStatus
    ipAddress: string | null
    location: string | null
    _count: AttendanceRecordCountAggregateOutputType | null
    _min: AttendanceRecordMinAggregateOutputType | null
    _max: AttendanceRecordMaxAggregateOutputType | null
  }

  type GetAttendanceRecordGroupByPayload<T extends AttendanceRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceRecordGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceRecordGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    clockIn?: boolean
    clockOut?: boolean
    status?: boolean
    ipAddress?: boolean
    location?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceRecord"]>



  export type AttendanceRecordSelectScalar = {
    id?: boolean
    userId?: boolean
    date?: boolean
    clockIn?: boolean
    clockOut?: boolean
    status?: boolean
    ipAddress?: boolean
    location?: boolean
  }

  export type AttendanceRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "date" | "clockIn" | "clockOut" | "status" | "ipAddress" | "location", ExtArgs["result"]["attendanceRecord"]>
  export type AttendanceRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AttendanceRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttendanceRecord"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      date: Date
      clockIn: Date | null
      clockOut: Date | null
      status: $Enums.AttendanceStatus
      ipAddress: string | null
      location: string | null
    }, ExtArgs["result"]["attendanceRecord"]>
    composites: {}
  }

  type AttendanceRecordGetPayload<S extends boolean | null | undefined | AttendanceRecordDefaultArgs> = $Result.GetResult<Prisma.$AttendanceRecordPayload, S>

  type AttendanceRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceRecordCountAggregateInputType | true
    }

  export interface AttendanceRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttendanceRecord'], meta: { name: 'AttendanceRecord' } }
    /**
     * Find zero or one AttendanceRecord that matches the filter.
     * @param {AttendanceRecordFindUniqueArgs} args - Arguments to find a AttendanceRecord
     * @example
     * // Get one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceRecordFindUniqueArgs>(args: SelectSubset<T, AttendanceRecordFindUniqueArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AttendanceRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceRecordFindUniqueOrThrowArgs} args - Arguments to find a AttendanceRecord
     * @example
     * // Get one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordFindFirstArgs} args - Arguments to find a AttendanceRecord
     * @example
     * // Get one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceRecordFindFirstArgs>(args?: SelectSubset<T, AttendanceRecordFindFirstArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordFindFirstOrThrowArgs} args - Arguments to find a AttendanceRecord
     * @example
     * // Get one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AttendanceRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttendanceRecords
     * const attendanceRecords = await prisma.attendanceRecord.findMany()
     * 
     * // Get first 10 AttendanceRecords
     * const attendanceRecords = await prisma.attendanceRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceRecordWithIdOnly = await prisma.attendanceRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceRecordFindManyArgs>(args?: SelectSubset<T, AttendanceRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AttendanceRecord.
     * @param {AttendanceRecordCreateArgs} args - Arguments to create a AttendanceRecord.
     * @example
     * // Create one AttendanceRecord
     * const AttendanceRecord = await prisma.attendanceRecord.create({
     *   data: {
     *     // ... data to create a AttendanceRecord
     *   }
     * })
     * 
     */
    create<T extends AttendanceRecordCreateArgs>(args: SelectSubset<T, AttendanceRecordCreateArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AttendanceRecords.
     * @param {AttendanceRecordCreateManyArgs} args - Arguments to create many AttendanceRecords.
     * @example
     * // Create many AttendanceRecords
     * const attendanceRecord = await prisma.attendanceRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceRecordCreateManyArgs>(args?: SelectSubset<T, AttendanceRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AttendanceRecord.
     * @param {AttendanceRecordDeleteArgs} args - Arguments to delete one AttendanceRecord.
     * @example
     * // Delete one AttendanceRecord
     * const AttendanceRecord = await prisma.attendanceRecord.delete({
     *   where: {
     *     // ... filter to delete one AttendanceRecord
     *   }
     * })
     * 
     */
    delete<T extends AttendanceRecordDeleteArgs>(args: SelectSubset<T, AttendanceRecordDeleteArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AttendanceRecord.
     * @param {AttendanceRecordUpdateArgs} args - Arguments to update one AttendanceRecord.
     * @example
     * // Update one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceRecordUpdateArgs>(args: SelectSubset<T, AttendanceRecordUpdateArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AttendanceRecords.
     * @param {AttendanceRecordDeleteManyArgs} args - Arguments to filter AttendanceRecords to delete.
     * @example
     * // Delete a few AttendanceRecords
     * const { count } = await prisma.attendanceRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceRecordDeleteManyArgs>(args?: SelectSubset<T, AttendanceRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttendanceRecords
     * const attendanceRecord = await prisma.attendanceRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceRecordUpdateManyArgs>(args: SelectSubset<T, AttendanceRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AttendanceRecord.
     * @param {AttendanceRecordUpsertArgs} args - Arguments to update or create a AttendanceRecord.
     * @example
     * // Update or create a AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.upsert({
     *   create: {
     *     // ... data to create a AttendanceRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttendanceRecord we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceRecordUpsertArgs>(args: SelectSubset<T, AttendanceRecordUpsertArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AttendanceRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordCountArgs} args - Arguments to filter AttendanceRecords to count.
     * @example
     * // Count the number of AttendanceRecords
     * const count = await prisma.attendanceRecord.count({
     *   where: {
     *     // ... the filter for the AttendanceRecords we want to count
     *   }
     * })
    **/
    count<T extends AttendanceRecordCountArgs>(
      args?: Subset<T, AttendanceRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttendanceRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceRecordAggregateArgs>(args: Subset<T, AttendanceRecordAggregateArgs>): Prisma.PrismaPromise<GetAttendanceRecordAggregateType<T>>

    /**
     * Group by AttendanceRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceRecordGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttendanceRecord model
   */
  readonly fields: AttendanceRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttendanceRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttendanceRecord model
   */
  interface AttendanceRecordFieldRefs {
    readonly id: FieldRef<"AttendanceRecord", 'String'>
    readonly userId: FieldRef<"AttendanceRecord", 'String'>
    readonly date: FieldRef<"AttendanceRecord", 'DateTime'>
    readonly clockIn: FieldRef<"AttendanceRecord", 'DateTime'>
    readonly clockOut: FieldRef<"AttendanceRecord", 'DateTime'>
    readonly status: FieldRef<"AttendanceRecord", 'AttendanceStatus'>
    readonly ipAddress: FieldRef<"AttendanceRecord", 'String'>
    readonly location: FieldRef<"AttendanceRecord", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AttendanceRecord findUnique
   */
  export type AttendanceRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecord to fetch.
     */
    where: AttendanceRecordWhereUniqueInput
  }

  /**
   * AttendanceRecord findUniqueOrThrow
   */
  export type AttendanceRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecord to fetch.
     */
    where: AttendanceRecordWhereUniqueInput
  }

  /**
   * AttendanceRecord findFirst
   */
  export type AttendanceRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecord to fetch.
     */
    where?: AttendanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceRecords to fetch.
     */
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceRecords.
     */
    cursor?: AttendanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceRecords.
     */
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * AttendanceRecord findFirstOrThrow
   */
  export type AttendanceRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecord to fetch.
     */
    where?: AttendanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceRecords to fetch.
     */
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceRecords.
     */
    cursor?: AttendanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceRecords.
     */
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * AttendanceRecord findMany
   */
  export type AttendanceRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecords to fetch.
     */
    where?: AttendanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceRecords to fetch.
     */
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttendanceRecords.
     */
    cursor?: AttendanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceRecords.
     */
    skip?: number
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * AttendanceRecord create
   */
  export type AttendanceRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a AttendanceRecord.
     */
    data: XOR<AttendanceRecordCreateInput, AttendanceRecordUncheckedCreateInput>
  }

  /**
   * AttendanceRecord createMany
   */
  export type AttendanceRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttendanceRecords.
     */
    data: AttendanceRecordCreateManyInput | AttendanceRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AttendanceRecord update
   */
  export type AttendanceRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a AttendanceRecord.
     */
    data: XOR<AttendanceRecordUpdateInput, AttendanceRecordUncheckedUpdateInput>
    /**
     * Choose, which AttendanceRecord to update.
     */
    where: AttendanceRecordWhereUniqueInput
  }

  /**
   * AttendanceRecord updateMany
   */
  export type AttendanceRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttendanceRecords.
     */
    data: XOR<AttendanceRecordUpdateManyMutationInput, AttendanceRecordUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceRecords to update
     */
    where?: AttendanceRecordWhereInput
    /**
     * Limit how many AttendanceRecords to update.
     */
    limit?: number
  }

  /**
   * AttendanceRecord upsert
   */
  export type AttendanceRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the AttendanceRecord to update in case it exists.
     */
    where: AttendanceRecordWhereUniqueInput
    /**
     * In case the AttendanceRecord found by the `where` argument doesn't exist, create a new AttendanceRecord with this data.
     */
    create: XOR<AttendanceRecordCreateInput, AttendanceRecordUncheckedCreateInput>
    /**
     * In case the AttendanceRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceRecordUpdateInput, AttendanceRecordUncheckedUpdateInput>
  }

  /**
   * AttendanceRecord delete
   */
  export type AttendanceRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter which AttendanceRecord to delete.
     */
    where: AttendanceRecordWhereUniqueInput
  }

  /**
   * AttendanceRecord deleteMany
   */
  export type AttendanceRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceRecords to delete
     */
    where?: AttendanceRecordWhereInput
    /**
     * Limit how many AttendanceRecords to delete.
     */
    limit?: number
  }

  /**
   * AttendanceRecord without action
   */
  export type AttendanceRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
  }


  /**
   * Model Leave
   */

  export type AggregateLeave = {
    _count: LeaveCountAggregateOutputType | null
    _min: LeaveMinAggregateOutputType | null
    _max: LeaveMaxAggregateOutputType | null
  }

  export type LeaveMinAggregateOutputType = {
    id: string | null
    userId: string | null
    startDate: Date | null
    endDate: Date | null
    reason: string | null
    status: $Enums.LeaveStatus | null
    approverId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    startDate: Date | null
    endDate: Date | null
    reason: string | null
    status: $Enums.LeaveStatus | null
    approverId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveCountAggregateOutputType = {
    id: number
    userId: number
    startDate: number
    endDate: number
    reason: number
    status: number
    approverId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeaveMinAggregateInputType = {
    id?: true
    userId?: true
    startDate?: true
    endDate?: true
    reason?: true
    status?: true
    approverId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveMaxAggregateInputType = {
    id?: true
    userId?: true
    startDate?: true
    endDate?: true
    reason?: true
    status?: true
    approverId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveCountAggregateInputType = {
    id?: true
    userId?: true
    startDate?: true
    endDate?: true
    reason?: true
    status?: true
    approverId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeaveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leave to aggregate.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leaves
    **/
    _count?: true | LeaveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaveMaxAggregateInputType
  }

  export type GetLeaveAggregateType<T extends LeaveAggregateArgs> = {
        [P in keyof T & keyof AggregateLeave]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeave[P]>
      : GetScalarType<T[P], AggregateLeave[P]>
  }




  export type LeaveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveWhereInput
    orderBy?: LeaveOrderByWithAggregationInput | LeaveOrderByWithAggregationInput[]
    by: LeaveScalarFieldEnum[] | LeaveScalarFieldEnum
    having?: LeaveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaveCountAggregateInputType | true
    _min?: LeaveMinAggregateInputType
    _max?: LeaveMaxAggregateInputType
  }

  export type LeaveGroupByOutputType = {
    id: string
    userId: string
    startDate: Date
    endDate: Date
    reason: string | null
    status: $Enums.LeaveStatus
    approverId: string | null
    createdAt: Date
    updatedAt: Date
    _count: LeaveCountAggregateOutputType | null
    _min: LeaveMinAggregateOutputType | null
    _max: LeaveMaxAggregateOutputType | null
  }

  type GetLeaveGroupByPayload<T extends LeaveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaveGroupByOutputType[P]>
            : GetScalarType<T[P], LeaveGroupByOutputType[P]>
        }
      >
    >


  export type LeaveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    startDate?: boolean
    endDate?: boolean
    reason?: boolean
    status?: boolean
    approverId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | Leave$approverArgs<ExtArgs>
  }, ExtArgs["result"]["leave"]>



  export type LeaveSelectScalar = {
    id?: boolean
    userId?: boolean
    startDate?: boolean
    endDate?: boolean
    reason?: boolean
    status?: boolean
    approverId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeaveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "startDate" | "endDate" | "reason" | "status" | "approverId" | "createdAt" | "updatedAt", ExtArgs["result"]["leave"]>
  export type LeaveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | Leave$approverArgs<ExtArgs>
  }

  export type $LeavePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Leave"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      approver: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      startDate: Date
      endDate: Date
      reason: string | null
      status: $Enums.LeaveStatus
      approverId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["leave"]>
    composites: {}
  }

  type LeaveGetPayload<S extends boolean | null | undefined | LeaveDefaultArgs> = $Result.GetResult<Prisma.$LeavePayload, S>

  type LeaveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeaveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeaveCountAggregateInputType | true
    }

  export interface LeaveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Leave'], meta: { name: 'Leave' } }
    /**
     * Find zero or one Leave that matches the filter.
     * @param {LeaveFindUniqueArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaveFindUniqueArgs>(args: SelectSubset<T, LeaveFindUniqueArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Leave that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeaveFindUniqueOrThrowArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaveFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Leave that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveFindFirstArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaveFindFirstArgs>(args?: SelectSubset<T, LeaveFindFirstArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Leave that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveFindFirstOrThrowArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaveFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaveFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leaves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leaves
     * const leaves = await prisma.leave.findMany()
     * 
     * // Get first 10 Leaves
     * const leaves = await prisma.leave.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaveWithIdOnly = await prisma.leave.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaveFindManyArgs>(args?: SelectSubset<T, LeaveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Leave.
     * @param {LeaveCreateArgs} args - Arguments to create a Leave.
     * @example
     * // Create one Leave
     * const Leave = await prisma.leave.create({
     *   data: {
     *     // ... data to create a Leave
     *   }
     * })
     * 
     */
    create<T extends LeaveCreateArgs>(args: SelectSubset<T, LeaveCreateArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Leaves.
     * @param {LeaveCreateManyArgs} args - Arguments to create many Leaves.
     * @example
     * // Create many Leaves
     * const leave = await prisma.leave.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaveCreateManyArgs>(args?: SelectSubset<T, LeaveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Leave.
     * @param {LeaveDeleteArgs} args - Arguments to delete one Leave.
     * @example
     * // Delete one Leave
     * const Leave = await prisma.leave.delete({
     *   where: {
     *     // ... filter to delete one Leave
     *   }
     * })
     * 
     */
    delete<T extends LeaveDeleteArgs>(args: SelectSubset<T, LeaveDeleteArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Leave.
     * @param {LeaveUpdateArgs} args - Arguments to update one Leave.
     * @example
     * // Update one Leave
     * const leave = await prisma.leave.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaveUpdateArgs>(args: SelectSubset<T, LeaveUpdateArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Leaves.
     * @param {LeaveDeleteManyArgs} args - Arguments to filter Leaves to delete.
     * @example
     * // Delete a few Leaves
     * const { count } = await prisma.leave.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaveDeleteManyArgs>(args?: SelectSubset<T, LeaveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leaves
     * const leave = await prisma.leave.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaveUpdateManyArgs>(args: SelectSubset<T, LeaveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Leave.
     * @param {LeaveUpsertArgs} args - Arguments to update or create a Leave.
     * @example
     * // Update or create a Leave
     * const leave = await prisma.leave.upsert({
     *   create: {
     *     // ... data to create a Leave
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Leave we want to update
     *   }
     * })
     */
    upsert<T extends LeaveUpsertArgs>(args: SelectSubset<T, LeaveUpsertArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Leaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveCountArgs} args - Arguments to filter Leaves to count.
     * @example
     * // Count the number of Leaves
     * const count = await prisma.leave.count({
     *   where: {
     *     // ... the filter for the Leaves we want to count
     *   }
     * })
    **/
    count<T extends LeaveCountArgs>(
      args?: Subset<T, LeaveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Leave.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaveAggregateArgs>(args: Subset<T, LeaveAggregateArgs>): Prisma.PrismaPromise<GetLeaveAggregateType<T>>

    /**
     * Group by Leave.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaveGroupByArgs['orderBy'] }
        : { orderBy?: LeaveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Leave model
   */
  readonly fields: LeaveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Leave.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    approver<T extends Leave$approverArgs<ExtArgs> = {}>(args?: Subset<T, Leave$approverArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Leave model
   */
  interface LeaveFieldRefs {
    readonly id: FieldRef<"Leave", 'String'>
    readonly userId: FieldRef<"Leave", 'String'>
    readonly startDate: FieldRef<"Leave", 'DateTime'>
    readonly endDate: FieldRef<"Leave", 'DateTime'>
    readonly reason: FieldRef<"Leave", 'String'>
    readonly status: FieldRef<"Leave", 'LeaveStatus'>
    readonly approverId: FieldRef<"Leave", 'String'>
    readonly createdAt: FieldRef<"Leave", 'DateTime'>
    readonly updatedAt: FieldRef<"Leave", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Leave findUnique
   */
  export type LeaveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where: LeaveWhereUniqueInput
  }

  /**
   * Leave findUniqueOrThrow
   */
  export type LeaveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where: LeaveWhereUniqueInput
  }

  /**
   * Leave findFirst
   */
  export type LeaveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leaves.
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leaves.
     */
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * Leave findFirstOrThrow
   */
  export type LeaveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leaves.
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leaves.
     */
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * Leave findMany
   */
  export type LeaveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leaves to fetch.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leaves.
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * Leave create
   */
  export type LeaveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * The data needed to create a Leave.
     */
    data: XOR<LeaveCreateInput, LeaveUncheckedCreateInput>
  }

  /**
   * Leave createMany
   */
  export type LeaveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leaves.
     */
    data: LeaveCreateManyInput | LeaveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Leave update
   */
  export type LeaveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * The data needed to update a Leave.
     */
    data: XOR<LeaveUpdateInput, LeaveUncheckedUpdateInput>
    /**
     * Choose, which Leave to update.
     */
    where: LeaveWhereUniqueInput
  }

  /**
   * Leave updateMany
   */
  export type LeaveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leaves.
     */
    data: XOR<LeaveUpdateManyMutationInput, LeaveUncheckedUpdateManyInput>
    /**
     * Filter which Leaves to update
     */
    where?: LeaveWhereInput
    /**
     * Limit how many Leaves to update.
     */
    limit?: number
  }

  /**
   * Leave upsert
   */
  export type LeaveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * The filter to search for the Leave to update in case it exists.
     */
    where: LeaveWhereUniqueInput
    /**
     * In case the Leave found by the `where` argument doesn't exist, create a new Leave with this data.
     */
    create: XOR<LeaveCreateInput, LeaveUncheckedCreateInput>
    /**
     * In case the Leave was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaveUpdateInput, LeaveUncheckedUpdateInput>
  }

  /**
   * Leave delete
   */
  export type LeaveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter which Leave to delete.
     */
    where: LeaveWhereUniqueInput
  }

  /**
   * Leave deleteMany
   */
  export type LeaveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leaves to delete
     */
    where?: LeaveWhereInput
    /**
     * Limit how many Leaves to delete.
     */
    limit?: number
  }

  /**
   * Leave.approver
   */
  export type Leave$approverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Leave without action
   */
  export type LeaveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
  }


  /**
   * Model ChatMessage
   */

  export type AggregateChatMessage = {
    _count: ChatMessageCountAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  export type ChatMessageMinAggregateOutputType = {
    id: string | null
    senderId: string | null
    receiverId: string | null
    groupId: string | null
    content: string | null
    timestamp: Date | null
  }

  export type ChatMessageMaxAggregateOutputType = {
    id: string | null
    senderId: string | null
    receiverId: string | null
    groupId: string | null
    content: string | null
    timestamp: Date | null
  }

  export type ChatMessageCountAggregateOutputType = {
    id: number
    senderId: number
    receiverId: number
    groupId: number
    content: number
    timestamp: number
    _all: number
  }


  export type ChatMessageMinAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    groupId?: true
    content?: true
    timestamp?: true
  }

  export type ChatMessageMaxAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    groupId?: true
    content?: true
    timestamp?: true
  }

  export type ChatMessageCountAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    groupId?: true
    content?: true
    timestamp?: true
    _all?: true
  }

  export type ChatMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessage to aggregate.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatMessages
    **/
    _count?: true | ChatMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMessageMaxAggregateInputType
  }

  export type GetChatMessageAggregateType<T extends ChatMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateChatMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatMessage[P]>
      : GetScalarType<T[P], AggregateChatMessage[P]>
  }




  export type ChatMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithAggregationInput | ChatMessageOrderByWithAggregationInput[]
    by: ChatMessageScalarFieldEnum[] | ChatMessageScalarFieldEnum
    having?: ChatMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatMessageCountAggregateInputType | true
    _min?: ChatMessageMinAggregateInputType
    _max?: ChatMessageMaxAggregateInputType
  }

  export type ChatMessageGroupByOutputType = {
    id: string
    senderId: string
    receiverId: string | null
    groupId: string | null
    content: string
    timestamp: Date
    _count: ChatMessageCountAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  type GetChatMessageGroupByPayload<T extends ChatMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
        }
      >
    >


  export type ChatMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    groupId?: boolean
    content?: boolean
    timestamp?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | ChatMessage$receiverArgs<ExtArgs>
    group?: boolean | ChatMessage$groupArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>



  export type ChatMessageSelectScalar = {
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    groupId?: boolean
    content?: boolean
    timestamp?: boolean
  }

  export type ChatMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "senderId" | "receiverId" | "groupId" | "content" | "timestamp", ExtArgs["result"]["chatMessage"]>
  export type ChatMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | ChatMessage$receiverArgs<ExtArgs>
    group?: boolean | ChatMessage$groupArgs<ExtArgs>
  }

  export type $ChatMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatMessage"
    objects: {
      sender: Prisma.$UserPayload<ExtArgs>
      receiver: Prisma.$UserPayload<ExtArgs> | null
      group: Prisma.$ChatGroupPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      senderId: string
      receiverId: string | null
      groupId: string | null
      content: string
      timestamp: Date
    }, ExtArgs["result"]["chatMessage"]>
    composites: {}
  }

  type ChatMessageGetPayload<S extends boolean | null | undefined | ChatMessageDefaultArgs> = $Result.GetResult<Prisma.$ChatMessagePayload, S>

  type ChatMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatMessageCountAggregateInputType | true
    }

  export interface ChatMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatMessage'], meta: { name: 'ChatMessage' } }
    /**
     * Find zero or one ChatMessage that matches the filter.
     * @param {ChatMessageFindUniqueArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatMessageFindUniqueArgs>(args: SelectSubset<T, ChatMessageFindUniqueArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatMessageFindUniqueOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatMessageFindFirstArgs>(args?: SelectSubset<T, ChatMessageFindFirstArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany()
     * 
     * // Get first 10 ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatMessageFindManyArgs>(args?: SelectSubset<T, ChatMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatMessage.
     * @param {ChatMessageCreateArgs} args - Arguments to create a ChatMessage.
     * @example
     * // Create one ChatMessage
     * const ChatMessage = await prisma.chatMessage.create({
     *   data: {
     *     // ... data to create a ChatMessage
     *   }
     * })
     * 
     */
    create<T extends ChatMessageCreateArgs>(args: SelectSubset<T, ChatMessageCreateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatMessages.
     * @param {ChatMessageCreateManyArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatMessageCreateManyArgs>(args?: SelectSubset<T, ChatMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChatMessage.
     * @param {ChatMessageDeleteArgs} args - Arguments to delete one ChatMessage.
     * @example
     * // Delete one ChatMessage
     * const ChatMessage = await prisma.chatMessage.delete({
     *   where: {
     *     // ... filter to delete one ChatMessage
     *   }
     * })
     * 
     */
    delete<T extends ChatMessageDeleteArgs>(args: SelectSubset<T, ChatMessageDeleteArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatMessage.
     * @param {ChatMessageUpdateArgs} args - Arguments to update one ChatMessage.
     * @example
     * // Update one ChatMessage
     * const chatMessage = await prisma.chatMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatMessageUpdateArgs>(args: SelectSubset<T, ChatMessageUpdateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatMessages.
     * @param {ChatMessageDeleteManyArgs} args - Arguments to filter ChatMessages to delete.
     * @example
     * // Delete a few ChatMessages
     * const { count } = await prisma.chatMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatMessageDeleteManyArgs>(args?: SelectSubset<T, ChatMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatMessageUpdateManyArgs>(args: SelectSubset<T, ChatMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChatMessage.
     * @param {ChatMessageUpsertArgs} args - Arguments to update or create a ChatMessage.
     * @example
     * // Update or create a ChatMessage
     * const chatMessage = await prisma.chatMessage.upsert({
     *   create: {
     *     // ... data to create a ChatMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatMessage we want to update
     *   }
     * })
     */
    upsert<T extends ChatMessageUpsertArgs>(args: SelectSubset<T, ChatMessageUpsertArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageCountArgs} args - Arguments to filter ChatMessages to count.
     * @example
     * // Count the number of ChatMessages
     * const count = await prisma.chatMessage.count({
     *   where: {
     *     // ... the filter for the ChatMessages we want to count
     *   }
     * })
    **/
    count<T extends ChatMessageCountArgs>(
      args?: Subset<T, ChatMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatMessageAggregateArgs>(args: Subset<T, ChatMessageAggregateArgs>): Prisma.PrismaPromise<GetChatMessageAggregateType<T>>

    /**
     * Group by ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatMessageGroupByArgs['orderBy'] }
        : { orderBy?: ChatMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatMessage model
   */
  readonly fields: ChatMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    receiver<T extends ChatMessage$receiverArgs<ExtArgs> = {}>(args?: Subset<T, ChatMessage$receiverArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    group<T extends ChatMessage$groupArgs<ExtArgs> = {}>(args?: Subset<T, ChatMessage$groupArgs<ExtArgs>>): Prisma__ChatGroupClient<$Result.GetResult<Prisma.$ChatGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatMessage model
   */
  interface ChatMessageFieldRefs {
    readonly id: FieldRef<"ChatMessage", 'String'>
    readonly senderId: FieldRef<"ChatMessage", 'String'>
    readonly receiverId: FieldRef<"ChatMessage", 'String'>
    readonly groupId: FieldRef<"ChatMessage", 'String'>
    readonly content: FieldRef<"ChatMessage", 'String'>
    readonly timestamp: FieldRef<"ChatMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatMessage findUnique
   */
  export type ChatMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findUniqueOrThrow
   */
  export type ChatMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findFirst
   */
  export type ChatMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findFirstOrThrow
   */
  export type ChatMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findMany
   */
  export type ChatMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessages to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage create
   */
  export type ChatMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatMessage.
     */
    data: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
  }

  /**
   * ChatMessage createMany
   */
  export type ChatMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatMessage update
   */
  export type ChatMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatMessage.
     */
    data: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
    /**
     * Choose, which ChatMessage to update.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage updateMany
   */
  export type ChatMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to update.
     */
    limit?: number
  }

  /**
   * ChatMessage upsert
   */
  export type ChatMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatMessage to update in case it exists.
     */
    where: ChatMessageWhereUniqueInput
    /**
     * In case the ChatMessage found by the `where` argument doesn't exist, create a new ChatMessage with this data.
     */
    create: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
    /**
     * In case the ChatMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
  }

  /**
   * ChatMessage delete
   */
  export type ChatMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter which ChatMessage to delete.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage deleteMany
   */
  export type ChatMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessages to delete
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to delete.
     */
    limit?: number
  }

  /**
   * ChatMessage.receiver
   */
  export type ChatMessage$receiverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ChatMessage.group
   */
  export type ChatMessage$groupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroup
     */
    select?: ChatGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroup
     */
    omit?: ChatGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupInclude<ExtArgs> | null
    where?: ChatGroupWhereInput
  }

  /**
   * ChatMessage without action
   */
  export type ChatMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
  }


  /**
   * Model ChatGroup
   */

  export type AggregateChatGroup = {
    _count: ChatGroupCountAggregateOutputType | null
    _min: ChatGroupMinAggregateOutputType | null
    _max: ChatGroupMaxAggregateOutputType | null
  }

  export type ChatGroupMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
  }

  export type ChatGroupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
  }

  export type ChatGroupCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    _all: number
  }


  export type ChatGroupMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
  }

  export type ChatGroupMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
  }

  export type ChatGroupCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    _all?: true
  }

  export type ChatGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatGroup to aggregate.
     */
    where?: ChatGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatGroups to fetch.
     */
    orderBy?: ChatGroupOrderByWithRelationInput | ChatGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatGroups
    **/
    _count?: true | ChatGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatGroupMaxAggregateInputType
  }

  export type GetChatGroupAggregateType<T extends ChatGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateChatGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatGroup[P]>
      : GetScalarType<T[P], AggregateChatGroup[P]>
  }




  export type ChatGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatGroupWhereInput
    orderBy?: ChatGroupOrderByWithAggregationInput | ChatGroupOrderByWithAggregationInput[]
    by: ChatGroupScalarFieldEnum[] | ChatGroupScalarFieldEnum
    having?: ChatGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatGroupCountAggregateInputType | true
    _min?: ChatGroupMinAggregateInputType
    _max?: ChatGroupMaxAggregateInputType
  }

  export type ChatGroupGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    _count: ChatGroupCountAggregateOutputType | null
    _min: ChatGroupMinAggregateOutputType | null
    _max: ChatGroupMaxAggregateOutputType | null
  }

  type GetChatGroupGroupByPayload<T extends ChatGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatGroupGroupByOutputType[P]>
            : GetScalarType<T[P], ChatGroupGroupByOutputType[P]>
        }
      >
    >


  export type ChatGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    messages?: boolean | ChatGroup$messagesArgs<ExtArgs>
    members?: boolean | ChatGroup$membersArgs<ExtArgs>
    _count?: boolean | ChatGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatGroup"]>



  export type ChatGroupSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }

  export type ChatGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt", ExtArgs["result"]["chatGroup"]>
  export type ChatGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ChatGroup$messagesArgs<ExtArgs>
    members?: boolean | ChatGroup$membersArgs<ExtArgs>
    _count?: boolean | ChatGroupCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ChatGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatGroup"
    objects: {
      messages: Prisma.$ChatMessagePayload<ExtArgs>[]
      members: Prisma.$ChatGroupMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
    }, ExtArgs["result"]["chatGroup"]>
    composites: {}
  }

  type ChatGroupGetPayload<S extends boolean | null | undefined | ChatGroupDefaultArgs> = $Result.GetResult<Prisma.$ChatGroupPayload, S>

  type ChatGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatGroupCountAggregateInputType | true
    }

  export interface ChatGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatGroup'], meta: { name: 'ChatGroup' } }
    /**
     * Find zero or one ChatGroup that matches the filter.
     * @param {ChatGroupFindUniqueArgs} args - Arguments to find a ChatGroup
     * @example
     * // Get one ChatGroup
     * const chatGroup = await prisma.chatGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatGroupFindUniqueArgs>(args: SelectSubset<T, ChatGroupFindUniqueArgs<ExtArgs>>): Prisma__ChatGroupClient<$Result.GetResult<Prisma.$ChatGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatGroupFindUniqueOrThrowArgs} args - Arguments to find a ChatGroup
     * @example
     * // Get one ChatGroup
     * const chatGroup = await prisma.chatGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatGroupClient<$Result.GetResult<Prisma.$ChatGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupFindFirstArgs} args - Arguments to find a ChatGroup
     * @example
     * // Get one ChatGroup
     * const chatGroup = await prisma.chatGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatGroupFindFirstArgs>(args?: SelectSubset<T, ChatGroupFindFirstArgs<ExtArgs>>): Prisma__ChatGroupClient<$Result.GetResult<Prisma.$ChatGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupFindFirstOrThrowArgs} args - Arguments to find a ChatGroup
     * @example
     * // Get one ChatGroup
     * const chatGroup = await prisma.chatGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatGroupClient<$Result.GetResult<Prisma.$ChatGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatGroups
     * const chatGroups = await prisma.chatGroup.findMany()
     * 
     * // Get first 10 ChatGroups
     * const chatGroups = await prisma.chatGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatGroupWithIdOnly = await prisma.chatGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatGroupFindManyArgs>(args?: SelectSubset<T, ChatGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatGroup.
     * @param {ChatGroupCreateArgs} args - Arguments to create a ChatGroup.
     * @example
     * // Create one ChatGroup
     * const ChatGroup = await prisma.chatGroup.create({
     *   data: {
     *     // ... data to create a ChatGroup
     *   }
     * })
     * 
     */
    create<T extends ChatGroupCreateArgs>(args: SelectSubset<T, ChatGroupCreateArgs<ExtArgs>>): Prisma__ChatGroupClient<$Result.GetResult<Prisma.$ChatGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatGroups.
     * @param {ChatGroupCreateManyArgs} args - Arguments to create many ChatGroups.
     * @example
     * // Create many ChatGroups
     * const chatGroup = await prisma.chatGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatGroupCreateManyArgs>(args?: SelectSubset<T, ChatGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChatGroup.
     * @param {ChatGroupDeleteArgs} args - Arguments to delete one ChatGroup.
     * @example
     * // Delete one ChatGroup
     * const ChatGroup = await prisma.chatGroup.delete({
     *   where: {
     *     // ... filter to delete one ChatGroup
     *   }
     * })
     * 
     */
    delete<T extends ChatGroupDeleteArgs>(args: SelectSubset<T, ChatGroupDeleteArgs<ExtArgs>>): Prisma__ChatGroupClient<$Result.GetResult<Prisma.$ChatGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatGroup.
     * @param {ChatGroupUpdateArgs} args - Arguments to update one ChatGroup.
     * @example
     * // Update one ChatGroup
     * const chatGroup = await prisma.chatGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatGroupUpdateArgs>(args: SelectSubset<T, ChatGroupUpdateArgs<ExtArgs>>): Prisma__ChatGroupClient<$Result.GetResult<Prisma.$ChatGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatGroups.
     * @param {ChatGroupDeleteManyArgs} args - Arguments to filter ChatGroups to delete.
     * @example
     * // Delete a few ChatGroups
     * const { count } = await prisma.chatGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatGroupDeleteManyArgs>(args?: SelectSubset<T, ChatGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatGroups
     * const chatGroup = await prisma.chatGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatGroupUpdateManyArgs>(args: SelectSubset<T, ChatGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChatGroup.
     * @param {ChatGroupUpsertArgs} args - Arguments to update or create a ChatGroup.
     * @example
     * // Update or create a ChatGroup
     * const chatGroup = await prisma.chatGroup.upsert({
     *   create: {
     *     // ... data to create a ChatGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatGroup we want to update
     *   }
     * })
     */
    upsert<T extends ChatGroupUpsertArgs>(args: SelectSubset<T, ChatGroupUpsertArgs<ExtArgs>>): Prisma__ChatGroupClient<$Result.GetResult<Prisma.$ChatGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupCountArgs} args - Arguments to filter ChatGroups to count.
     * @example
     * // Count the number of ChatGroups
     * const count = await prisma.chatGroup.count({
     *   where: {
     *     // ... the filter for the ChatGroups we want to count
     *   }
     * })
    **/
    count<T extends ChatGroupCountArgs>(
      args?: Subset<T, ChatGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatGroupAggregateArgs>(args: Subset<T, ChatGroupAggregateArgs>): Prisma.PrismaPromise<GetChatGroupAggregateType<T>>

    /**
     * Group by ChatGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatGroupGroupByArgs['orderBy'] }
        : { orderBy?: ChatGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatGroup model
   */
  readonly fields: ChatGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    messages<T extends ChatGroup$messagesArgs<ExtArgs> = {}>(args?: Subset<T, ChatGroup$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    members<T extends ChatGroup$membersArgs<ExtArgs> = {}>(args?: Subset<T, ChatGroup$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatGroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatGroup model
   */
  interface ChatGroupFieldRefs {
    readonly id: FieldRef<"ChatGroup", 'String'>
    readonly name: FieldRef<"ChatGroup", 'String'>
    readonly createdAt: FieldRef<"ChatGroup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatGroup findUnique
   */
  export type ChatGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroup
     */
    select?: ChatGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroup
     */
    omit?: ChatGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupInclude<ExtArgs> | null
    /**
     * Filter, which ChatGroup to fetch.
     */
    where: ChatGroupWhereUniqueInput
  }

  /**
   * ChatGroup findUniqueOrThrow
   */
  export type ChatGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroup
     */
    select?: ChatGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroup
     */
    omit?: ChatGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupInclude<ExtArgs> | null
    /**
     * Filter, which ChatGroup to fetch.
     */
    where: ChatGroupWhereUniqueInput
  }

  /**
   * ChatGroup findFirst
   */
  export type ChatGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroup
     */
    select?: ChatGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroup
     */
    omit?: ChatGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupInclude<ExtArgs> | null
    /**
     * Filter, which ChatGroup to fetch.
     */
    where?: ChatGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatGroups to fetch.
     */
    orderBy?: ChatGroupOrderByWithRelationInput | ChatGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatGroups.
     */
    cursor?: ChatGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatGroups.
     */
    distinct?: ChatGroupScalarFieldEnum | ChatGroupScalarFieldEnum[]
  }

  /**
   * ChatGroup findFirstOrThrow
   */
  export type ChatGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroup
     */
    select?: ChatGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroup
     */
    omit?: ChatGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupInclude<ExtArgs> | null
    /**
     * Filter, which ChatGroup to fetch.
     */
    where?: ChatGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatGroups to fetch.
     */
    orderBy?: ChatGroupOrderByWithRelationInput | ChatGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatGroups.
     */
    cursor?: ChatGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatGroups.
     */
    distinct?: ChatGroupScalarFieldEnum | ChatGroupScalarFieldEnum[]
  }

  /**
   * ChatGroup findMany
   */
  export type ChatGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroup
     */
    select?: ChatGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroup
     */
    omit?: ChatGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupInclude<ExtArgs> | null
    /**
     * Filter, which ChatGroups to fetch.
     */
    where?: ChatGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatGroups to fetch.
     */
    orderBy?: ChatGroupOrderByWithRelationInput | ChatGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatGroups.
     */
    cursor?: ChatGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatGroups.
     */
    skip?: number
    distinct?: ChatGroupScalarFieldEnum | ChatGroupScalarFieldEnum[]
  }

  /**
   * ChatGroup create
   */
  export type ChatGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroup
     */
    select?: ChatGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroup
     */
    omit?: ChatGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatGroup.
     */
    data: XOR<ChatGroupCreateInput, ChatGroupUncheckedCreateInput>
  }

  /**
   * ChatGroup createMany
   */
  export type ChatGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatGroups.
     */
    data: ChatGroupCreateManyInput | ChatGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatGroup update
   */
  export type ChatGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroup
     */
    select?: ChatGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroup
     */
    omit?: ChatGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatGroup.
     */
    data: XOR<ChatGroupUpdateInput, ChatGroupUncheckedUpdateInput>
    /**
     * Choose, which ChatGroup to update.
     */
    where: ChatGroupWhereUniqueInput
  }

  /**
   * ChatGroup updateMany
   */
  export type ChatGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatGroups.
     */
    data: XOR<ChatGroupUpdateManyMutationInput, ChatGroupUncheckedUpdateManyInput>
    /**
     * Filter which ChatGroups to update
     */
    where?: ChatGroupWhereInput
    /**
     * Limit how many ChatGroups to update.
     */
    limit?: number
  }

  /**
   * ChatGroup upsert
   */
  export type ChatGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroup
     */
    select?: ChatGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroup
     */
    omit?: ChatGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatGroup to update in case it exists.
     */
    where: ChatGroupWhereUniqueInput
    /**
     * In case the ChatGroup found by the `where` argument doesn't exist, create a new ChatGroup with this data.
     */
    create: XOR<ChatGroupCreateInput, ChatGroupUncheckedCreateInput>
    /**
     * In case the ChatGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatGroupUpdateInput, ChatGroupUncheckedUpdateInput>
  }

  /**
   * ChatGroup delete
   */
  export type ChatGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroup
     */
    select?: ChatGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroup
     */
    omit?: ChatGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupInclude<ExtArgs> | null
    /**
     * Filter which ChatGroup to delete.
     */
    where: ChatGroupWhereUniqueInput
  }

  /**
   * ChatGroup deleteMany
   */
  export type ChatGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatGroups to delete
     */
    where?: ChatGroupWhereInput
    /**
     * Limit how many ChatGroups to delete.
     */
    limit?: number
  }

  /**
   * ChatGroup.messages
   */
  export type ChatGroup$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatGroup.members
   */
  export type ChatGroup$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroupMember
     */
    select?: ChatGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroupMember
     */
    omit?: ChatGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupMemberInclude<ExtArgs> | null
    where?: ChatGroupMemberWhereInput
    orderBy?: ChatGroupMemberOrderByWithRelationInput | ChatGroupMemberOrderByWithRelationInput[]
    cursor?: ChatGroupMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatGroupMemberScalarFieldEnum | ChatGroupMemberScalarFieldEnum[]
  }

  /**
   * ChatGroup without action
   */
  export type ChatGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroup
     */
    select?: ChatGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroup
     */
    omit?: ChatGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupInclude<ExtArgs> | null
  }


  /**
   * Model ChatGroupMember
   */

  export type AggregateChatGroupMember = {
    _count: ChatGroupMemberCountAggregateOutputType | null
    _min: ChatGroupMemberMinAggregateOutputType | null
    _max: ChatGroupMemberMaxAggregateOutputType | null
  }

  export type ChatGroupMemberMinAggregateOutputType = {
    id: string | null
    groupId: string | null
    userId: string | null
    joinedAt: Date | null
  }

  export type ChatGroupMemberMaxAggregateOutputType = {
    id: string | null
    groupId: string | null
    userId: string | null
    joinedAt: Date | null
  }

  export type ChatGroupMemberCountAggregateOutputType = {
    id: number
    groupId: number
    userId: number
    joinedAt: number
    _all: number
  }


  export type ChatGroupMemberMinAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    joinedAt?: true
  }

  export type ChatGroupMemberMaxAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    joinedAt?: true
  }

  export type ChatGroupMemberCountAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    joinedAt?: true
    _all?: true
  }

  export type ChatGroupMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatGroupMember to aggregate.
     */
    where?: ChatGroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatGroupMembers to fetch.
     */
    orderBy?: ChatGroupMemberOrderByWithRelationInput | ChatGroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatGroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatGroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatGroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatGroupMembers
    **/
    _count?: true | ChatGroupMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatGroupMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatGroupMemberMaxAggregateInputType
  }

  export type GetChatGroupMemberAggregateType<T extends ChatGroupMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateChatGroupMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatGroupMember[P]>
      : GetScalarType<T[P], AggregateChatGroupMember[P]>
  }




  export type ChatGroupMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatGroupMemberWhereInput
    orderBy?: ChatGroupMemberOrderByWithAggregationInput | ChatGroupMemberOrderByWithAggregationInput[]
    by: ChatGroupMemberScalarFieldEnum[] | ChatGroupMemberScalarFieldEnum
    having?: ChatGroupMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatGroupMemberCountAggregateInputType | true
    _min?: ChatGroupMemberMinAggregateInputType
    _max?: ChatGroupMemberMaxAggregateInputType
  }

  export type ChatGroupMemberGroupByOutputType = {
    id: string
    groupId: string
    userId: string
    joinedAt: Date
    _count: ChatGroupMemberCountAggregateOutputType | null
    _min: ChatGroupMemberMinAggregateOutputType | null
    _max: ChatGroupMemberMaxAggregateOutputType | null
  }

  type GetChatGroupMemberGroupByPayload<T extends ChatGroupMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatGroupMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatGroupMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatGroupMemberGroupByOutputType[P]>
            : GetScalarType<T[P], ChatGroupMemberGroupByOutputType[P]>
        }
      >
    >


  export type ChatGroupMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    userId?: boolean
    joinedAt?: boolean
    group?: boolean | ChatGroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatGroupMember"]>



  export type ChatGroupMemberSelectScalar = {
    id?: boolean
    groupId?: boolean
    userId?: boolean
    joinedAt?: boolean
  }

  export type ChatGroupMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "groupId" | "userId" | "joinedAt", ExtArgs["result"]["chatGroupMember"]>
  export type ChatGroupMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | ChatGroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChatGroupMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatGroupMember"
    objects: {
      group: Prisma.$ChatGroupPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      groupId: string
      userId: string
      joinedAt: Date
    }, ExtArgs["result"]["chatGroupMember"]>
    composites: {}
  }

  type ChatGroupMemberGetPayload<S extends boolean | null | undefined | ChatGroupMemberDefaultArgs> = $Result.GetResult<Prisma.$ChatGroupMemberPayload, S>

  type ChatGroupMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatGroupMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatGroupMemberCountAggregateInputType | true
    }

  export interface ChatGroupMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatGroupMember'], meta: { name: 'ChatGroupMember' } }
    /**
     * Find zero or one ChatGroupMember that matches the filter.
     * @param {ChatGroupMemberFindUniqueArgs} args - Arguments to find a ChatGroupMember
     * @example
     * // Get one ChatGroupMember
     * const chatGroupMember = await prisma.chatGroupMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatGroupMemberFindUniqueArgs>(args: SelectSubset<T, ChatGroupMemberFindUniqueArgs<ExtArgs>>): Prisma__ChatGroupMemberClient<$Result.GetResult<Prisma.$ChatGroupMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatGroupMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatGroupMemberFindUniqueOrThrowArgs} args - Arguments to find a ChatGroupMember
     * @example
     * // Get one ChatGroupMember
     * const chatGroupMember = await prisma.chatGroupMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatGroupMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatGroupMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatGroupMemberClient<$Result.GetResult<Prisma.$ChatGroupMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatGroupMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupMemberFindFirstArgs} args - Arguments to find a ChatGroupMember
     * @example
     * // Get one ChatGroupMember
     * const chatGroupMember = await prisma.chatGroupMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatGroupMemberFindFirstArgs>(args?: SelectSubset<T, ChatGroupMemberFindFirstArgs<ExtArgs>>): Prisma__ChatGroupMemberClient<$Result.GetResult<Prisma.$ChatGroupMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatGroupMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupMemberFindFirstOrThrowArgs} args - Arguments to find a ChatGroupMember
     * @example
     * // Get one ChatGroupMember
     * const chatGroupMember = await prisma.chatGroupMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatGroupMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatGroupMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatGroupMemberClient<$Result.GetResult<Prisma.$ChatGroupMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatGroupMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatGroupMembers
     * const chatGroupMembers = await prisma.chatGroupMember.findMany()
     * 
     * // Get first 10 ChatGroupMembers
     * const chatGroupMembers = await prisma.chatGroupMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatGroupMemberWithIdOnly = await prisma.chatGroupMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatGroupMemberFindManyArgs>(args?: SelectSubset<T, ChatGroupMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatGroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatGroupMember.
     * @param {ChatGroupMemberCreateArgs} args - Arguments to create a ChatGroupMember.
     * @example
     * // Create one ChatGroupMember
     * const ChatGroupMember = await prisma.chatGroupMember.create({
     *   data: {
     *     // ... data to create a ChatGroupMember
     *   }
     * })
     * 
     */
    create<T extends ChatGroupMemberCreateArgs>(args: SelectSubset<T, ChatGroupMemberCreateArgs<ExtArgs>>): Prisma__ChatGroupMemberClient<$Result.GetResult<Prisma.$ChatGroupMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatGroupMembers.
     * @param {ChatGroupMemberCreateManyArgs} args - Arguments to create many ChatGroupMembers.
     * @example
     * // Create many ChatGroupMembers
     * const chatGroupMember = await prisma.chatGroupMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatGroupMemberCreateManyArgs>(args?: SelectSubset<T, ChatGroupMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChatGroupMember.
     * @param {ChatGroupMemberDeleteArgs} args - Arguments to delete one ChatGroupMember.
     * @example
     * // Delete one ChatGroupMember
     * const ChatGroupMember = await prisma.chatGroupMember.delete({
     *   where: {
     *     // ... filter to delete one ChatGroupMember
     *   }
     * })
     * 
     */
    delete<T extends ChatGroupMemberDeleteArgs>(args: SelectSubset<T, ChatGroupMemberDeleteArgs<ExtArgs>>): Prisma__ChatGroupMemberClient<$Result.GetResult<Prisma.$ChatGroupMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatGroupMember.
     * @param {ChatGroupMemberUpdateArgs} args - Arguments to update one ChatGroupMember.
     * @example
     * // Update one ChatGroupMember
     * const chatGroupMember = await prisma.chatGroupMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatGroupMemberUpdateArgs>(args: SelectSubset<T, ChatGroupMemberUpdateArgs<ExtArgs>>): Prisma__ChatGroupMemberClient<$Result.GetResult<Prisma.$ChatGroupMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatGroupMembers.
     * @param {ChatGroupMemberDeleteManyArgs} args - Arguments to filter ChatGroupMembers to delete.
     * @example
     * // Delete a few ChatGroupMembers
     * const { count } = await prisma.chatGroupMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatGroupMemberDeleteManyArgs>(args?: SelectSubset<T, ChatGroupMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatGroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatGroupMembers
     * const chatGroupMember = await prisma.chatGroupMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatGroupMemberUpdateManyArgs>(args: SelectSubset<T, ChatGroupMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChatGroupMember.
     * @param {ChatGroupMemberUpsertArgs} args - Arguments to update or create a ChatGroupMember.
     * @example
     * // Update or create a ChatGroupMember
     * const chatGroupMember = await prisma.chatGroupMember.upsert({
     *   create: {
     *     // ... data to create a ChatGroupMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatGroupMember we want to update
     *   }
     * })
     */
    upsert<T extends ChatGroupMemberUpsertArgs>(args: SelectSubset<T, ChatGroupMemberUpsertArgs<ExtArgs>>): Prisma__ChatGroupMemberClient<$Result.GetResult<Prisma.$ChatGroupMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatGroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupMemberCountArgs} args - Arguments to filter ChatGroupMembers to count.
     * @example
     * // Count the number of ChatGroupMembers
     * const count = await prisma.chatGroupMember.count({
     *   where: {
     *     // ... the filter for the ChatGroupMembers we want to count
     *   }
     * })
    **/
    count<T extends ChatGroupMemberCountArgs>(
      args?: Subset<T, ChatGroupMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatGroupMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatGroupMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatGroupMemberAggregateArgs>(args: Subset<T, ChatGroupMemberAggregateArgs>): Prisma.PrismaPromise<GetChatGroupMemberAggregateType<T>>

    /**
     * Group by ChatGroupMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatGroupMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatGroupMemberGroupByArgs['orderBy'] }
        : { orderBy?: ChatGroupMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatGroupMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatGroupMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatGroupMember model
   */
  readonly fields: ChatGroupMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatGroupMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatGroupMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends ChatGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatGroupDefaultArgs<ExtArgs>>): Prisma__ChatGroupClient<$Result.GetResult<Prisma.$ChatGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatGroupMember model
   */
  interface ChatGroupMemberFieldRefs {
    readonly id: FieldRef<"ChatGroupMember", 'String'>
    readonly groupId: FieldRef<"ChatGroupMember", 'String'>
    readonly userId: FieldRef<"ChatGroupMember", 'String'>
    readonly joinedAt: FieldRef<"ChatGroupMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatGroupMember findUnique
   */
  export type ChatGroupMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroupMember
     */
    select?: ChatGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroupMember
     */
    omit?: ChatGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which ChatGroupMember to fetch.
     */
    where: ChatGroupMemberWhereUniqueInput
  }

  /**
   * ChatGroupMember findUniqueOrThrow
   */
  export type ChatGroupMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroupMember
     */
    select?: ChatGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroupMember
     */
    omit?: ChatGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which ChatGroupMember to fetch.
     */
    where: ChatGroupMemberWhereUniqueInput
  }

  /**
   * ChatGroupMember findFirst
   */
  export type ChatGroupMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroupMember
     */
    select?: ChatGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroupMember
     */
    omit?: ChatGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which ChatGroupMember to fetch.
     */
    where?: ChatGroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatGroupMembers to fetch.
     */
    orderBy?: ChatGroupMemberOrderByWithRelationInput | ChatGroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatGroupMembers.
     */
    cursor?: ChatGroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatGroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatGroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatGroupMembers.
     */
    distinct?: ChatGroupMemberScalarFieldEnum | ChatGroupMemberScalarFieldEnum[]
  }

  /**
   * ChatGroupMember findFirstOrThrow
   */
  export type ChatGroupMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroupMember
     */
    select?: ChatGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroupMember
     */
    omit?: ChatGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which ChatGroupMember to fetch.
     */
    where?: ChatGroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatGroupMembers to fetch.
     */
    orderBy?: ChatGroupMemberOrderByWithRelationInput | ChatGroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatGroupMembers.
     */
    cursor?: ChatGroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatGroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatGroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatGroupMembers.
     */
    distinct?: ChatGroupMemberScalarFieldEnum | ChatGroupMemberScalarFieldEnum[]
  }

  /**
   * ChatGroupMember findMany
   */
  export type ChatGroupMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroupMember
     */
    select?: ChatGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroupMember
     */
    omit?: ChatGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which ChatGroupMembers to fetch.
     */
    where?: ChatGroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatGroupMembers to fetch.
     */
    orderBy?: ChatGroupMemberOrderByWithRelationInput | ChatGroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatGroupMembers.
     */
    cursor?: ChatGroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatGroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatGroupMembers.
     */
    skip?: number
    distinct?: ChatGroupMemberScalarFieldEnum | ChatGroupMemberScalarFieldEnum[]
  }

  /**
   * ChatGroupMember create
   */
  export type ChatGroupMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroupMember
     */
    select?: ChatGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroupMember
     */
    omit?: ChatGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatGroupMember.
     */
    data: XOR<ChatGroupMemberCreateInput, ChatGroupMemberUncheckedCreateInput>
  }

  /**
   * ChatGroupMember createMany
   */
  export type ChatGroupMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatGroupMembers.
     */
    data: ChatGroupMemberCreateManyInput | ChatGroupMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatGroupMember update
   */
  export type ChatGroupMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroupMember
     */
    select?: ChatGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroupMember
     */
    omit?: ChatGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatGroupMember.
     */
    data: XOR<ChatGroupMemberUpdateInput, ChatGroupMemberUncheckedUpdateInput>
    /**
     * Choose, which ChatGroupMember to update.
     */
    where: ChatGroupMemberWhereUniqueInput
  }

  /**
   * ChatGroupMember updateMany
   */
  export type ChatGroupMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatGroupMembers.
     */
    data: XOR<ChatGroupMemberUpdateManyMutationInput, ChatGroupMemberUncheckedUpdateManyInput>
    /**
     * Filter which ChatGroupMembers to update
     */
    where?: ChatGroupMemberWhereInput
    /**
     * Limit how many ChatGroupMembers to update.
     */
    limit?: number
  }

  /**
   * ChatGroupMember upsert
   */
  export type ChatGroupMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroupMember
     */
    select?: ChatGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroupMember
     */
    omit?: ChatGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatGroupMember to update in case it exists.
     */
    where: ChatGroupMemberWhereUniqueInput
    /**
     * In case the ChatGroupMember found by the `where` argument doesn't exist, create a new ChatGroupMember with this data.
     */
    create: XOR<ChatGroupMemberCreateInput, ChatGroupMemberUncheckedCreateInput>
    /**
     * In case the ChatGroupMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatGroupMemberUpdateInput, ChatGroupMemberUncheckedUpdateInput>
  }

  /**
   * ChatGroupMember delete
   */
  export type ChatGroupMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroupMember
     */
    select?: ChatGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroupMember
     */
    omit?: ChatGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupMemberInclude<ExtArgs> | null
    /**
     * Filter which ChatGroupMember to delete.
     */
    where: ChatGroupMemberWhereUniqueInput
  }

  /**
   * ChatGroupMember deleteMany
   */
  export type ChatGroupMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatGroupMembers to delete
     */
    where?: ChatGroupMemberWhereInput
    /**
     * Limit how many ChatGroupMembers to delete.
     */
    limit?: number
  }

  /**
   * ChatGroupMember without action
   */
  export type ChatGroupMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroupMember
     */
    select?: ChatGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroupMember
     */
    omit?: ChatGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupMemberInclude<ExtArgs> | null
  }


  /**
   * Model Announcement
   */

  export type AggregateAnnouncement = {
    _count: AnnouncementCountAggregateOutputType | null
    _min: AnnouncementMinAggregateOutputType | null
    _max: AnnouncementMaxAggregateOutputType | null
  }

  export type AnnouncementMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    authorId: string | null
    departmentId: string | null
    createdAt: Date | null
  }

  export type AnnouncementMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    authorId: string | null
    departmentId: string | null
    createdAt: Date | null
  }

  export type AnnouncementCountAggregateOutputType = {
    id: number
    title: number
    content: number
    authorId: number
    departmentId: number
    createdAt: number
    _all: number
  }


  export type AnnouncementMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    authorId?: true
    departmentId?: true
    createdAt?: true
  }

  export type AnnouncementMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    authorId?: true
    departmentId?: true
    createdAt?: true
  }

  export type AnnouncementCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    authorId?: true
    departmentId?: true
    createdAt?: true
    _all?: true
  }

  export type AnnouncementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Announcement to aggregate.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Announcements
    **/
    _count?: true | AnnouncementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnnouncementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnnouncementMaxAggregateInputType
  }

  export type GetAnnouncementAggregateType<T extends AnnouncementAggregateArgs> = {
        [P in keyof T & keyof AggregateAnnouncement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnouncement[P]>
      : GetScalarType<T[P], AggregateAnnouncement[P]>
  }




  export type AnnouncementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementWhereInput
    orderBy?: AnnouncementOrderByWithAggregationInput | AnnouncementOrderByWithAggregationInput[]
    by: AnnouncementScalarFieldEnum[] | AnnouncementScalarFieldEnum
    having?: AnnouncementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnnouncementCountAggregateInputType | true
    _min?: AnnouncementMinAggregateInputType
    _max?: AnnouncementMaxAggregateInputType
  }

  export type AnnouncementGroupByOutputType = {
    id: string
    title: string
    content: string
    authorId: string
    departmentId: string | null
    createdAt: Date
    _count: AnnouncementCountAggregateOutputType | null
    _min: AnnouncementMinAggregateOutputType | null
    _max: AnnouncementMaxAggregateOutputType | null
  }

  type GetAnnouncementGroupByPayload<T extends AnnouncementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnnouncementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnnouncementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>
            : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>
        }
      >
    >


  export type AnnouncementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    authorId?: boolean
    departmentId?: boolean
    createdAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    department?: boolean | Announcement$departmentArgs<ExtArgs>
  }, ExtArgs["result"]["announcement"]>



  export type AnnouncementSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    authorId?: boolean
    departmentId?: boolean
    createdAt?: boolean
  }

  export type AnnouncementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "authorId" | "departmentId" | "createdAt", ExtArgs["result"]["announcement"]>
  export type AnnouncementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    department?: boolean | Announcement$departmentArgs<ExtArgs>
  }

  export type $AnnouncementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Announcement"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
      department: Prisma.$DepartmentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string
      authorId: string
      departmentId: string | null
      createdAt: Date
    }, ExtArgs["result"]["announcement"]>
    composites: {}
  }

  type AnnouncementGetPayload<S extends boolean | null | undefined | AnnouncementDefaultArgs> = $Result.GetResult<Prisma.$AnnouncementPayload, S>

  type AnnouncementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnnouncementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnnouncementCountAggregateInputType | true
    }

  export interface AnnouncementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Announcement'], meta: { name: 'Announcement' } }
    /**
     * Find zero or one Announcement that matches the filter.
     * @param {AnnouncementFindUniqueArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnnouncementFindUniqueArgs>(args: SelectSubset<T, AnnouncementFindUniqueArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Announcement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnnouncementFindUniqueOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnnouncementFindUniqueOrThrowArgs>(args: SelectSubset<T, AnnouncementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindFirstArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnnouncementFindFirstArgs>(args?: SelectSubset<T, AnnouncementFindFirstArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindFirstOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnnouncementFindFirstOrThrowArgs>(args?: SelectSubset<T, AnnouncementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Announcements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Announcements
     * const announcements = await prisma.announcement.findMany()
     * 
     * // Get first 10 Announcements
     * const announcements = await prisma.announcement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const announcementWithIdOnly = await prisma.announcement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnnouncementFindManyArgs>(args?: SelectSubset<T, AnnouncementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Announcement.
     * @param {AnnouncementCreateArgs} args - Arguments to create a Announcement.
     * @example
     * // Create one Announcement
     * const Announcement = await prisma.announcement.create({
     *   data: {
     *     // ... data to create a Announcement
     *   }
     * })
     * 
     */
    create<T extends AnnouncementCreateArgs>(args: SelectSubset<T, AnnouncementCreateArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Announcements.
     * @param {AnnouncementCreateManyArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcement = await prisma.announcement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnnouncementCreateManyArgs>(args?: SelectSubset<T, AnnouncementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Announcement.
     * @param {AnnouncementDeleteArgs} args - Arguments to delete one Announcement.
     * @example
     * // Delete one Announcement
     * const Announcement = await prisma.announcement.delete({
     *   where: {
     *     // ... filter to delete one Announcement
     *   }
     * })
     * 
     */
    delete<T extends AnnouncementDeleteArgs>(args: SelectSubset<T, AnnouncementDeleteArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Announcement.
     * @param {AnnouncementUpdateArgs} args - Arguments to update one Announcement.
     * @example
     * // Update one Announcement
     * const announcement = await prisma.announcement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnnouncementUpdateArgs>(args: SelectSubset<T, AnnouncementUpdateArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Announcements.
     * @param {AnnouncementDeleteManyArgs} args - Arguments to filter Announcements to delete.
     * @example
     * // Delete a few Announcements
     * const { count } = await prisma.announcement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnnouncementDeleteManyArgs>(args?: SelectSubset<T, AnnouncementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Announcements
     * const announcement = await prisma.announcement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnnouncementUpdateManyArgs>(args: SelectSubset<T, AnnouncementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Announcement.
     * @param {AnnouncementUpsertArgs} args - Arguments to update or create a Announcement.
     * @example
     * // Update or create a Announcement
     * const announcement = await prisma.announcement.upsert({
     *   create: {
     *     // ... data to create a Announcement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Announcement we want to update
     *   }
     * })
     */
    upsert<T extends AnnouncementUpsertArgs>(args: SelectSubset<T, AnnouncementUpsertArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementCountArgs} args - Arguments to filter Announcements to count.
     * @example
     * // Count the number of Announcements
     * const count = await prisma.announcement.count({
     *   where: {
     *     // ... the filter for the Announcements we want to count
     *   }
     * })
    **/
    count<T extends AnnouncementCountArgs>(
      args?: Subset<T, AnnouncementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnouncementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnnouncementAggregateArgs>(args: Subset<T, AnnouncementAggregateArgs>): Prisma.PrismaPromise<GetAnnouncementAggregateType<T>>

    /**
     * Group by Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnnouncementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnnouncementGroupByArgs['orderBy'] }
        : { orderBy?: AnnouncementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnnouncementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnnouncementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Announcement model
   */
  readonly fields: AnnouncementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Announcement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnnouncementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    department<T extends Announcement$departmentArgs<ExtArgs> = {}>(args?: Subset<T, Announcement$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Announcement model
   */
  interface AnnouncementFieldRefs {
    readonly id: FieldRef<"Announcement", 'String'>
    readonly title: FieldRef<"Announcement", 'String'>
    readonly content: FieldRef<"Announcement", 'String'>
    readonly authorId: FieldRef<"Announcement", 'String'>
    readonly departmentId: FieldRef<"Announcement", 'String'>
    readonly createdAt: FieldRef<"Announcement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Announcement findUnique
   */
  export type AnnouncementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement findUniqueOrThrow
   */
  export type AnnouncementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement findFirst
   */
  export type AnnouncementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement findFirstOrThrow
   */
  export type AnnouncementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement findMany
   */
  export type AnnouncementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcements to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement create
   */
  export type AnnouncementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The data needed to create a Announcement.
     */
    data: XOR<AnnouncementCreateInput, AnnouncementUncheckedCreateInput>
  }

  /**
   * Announcement createMany
   */
  export type AnnouncementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Announcements.
     */
    data: AnnouncementCreateManyInput | AnnouncementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Announcement update
   */
  export type AnnouncementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The data needed to update a Announcement.
     */
    data: XOR<AnnouncementUpdateInput, AnnouncementUncheckedUpdateInput>
    /**
     * Choose, which Announcement to update.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement updateMany
   */
  export type AnnouncementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Announcements.
     */
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyInput>
    /**
     * Filter which Announcements to update
     */
    where?: AnnouncementWhereInput
    /**
     * Limit how many Announcements to update.
     */
    limit?: number
  }

  /**
   * Announcement upsert
   */
  export type AnnouncementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The filter to search for the Announcement to update in case it exists.
     */
    where: AnnouncementWhereUniqueInput
    /**
     * In case the Announcement found by the `where` argument doesn't exist, create a new Announcement with this data.
     */
    create: XOR<AnnouncementCreateInput, AnnouncementUncheckedCreateInput>
    /**
     * In case the Announcement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnnouncementUpdateInput, AnnouncementUncheckedUpdateInput>
  }

  /**
   * Announcement delete
   */
  export type AnnouncementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter which Announcement to delete.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement deleteMany
   */
  export type AnnouncementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Announcements to delete
     */
    where?: AnnouncementWhereInput
    /**
     * Limit how many Announcements to delete.
     */
    limit?: number
  }

  /**
   * Announcement.department
   */
  export type Announcement$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Announcement without action
   */
  export type AnnouncementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    type: $Enums.NotificationType | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    type: $Enums.NotificationType | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    message: number
    type: number
    data: number
    read: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    read?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    read?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    data?: true
    read?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    title: string
    message: string
    type: $Enums.NotificationType
    data: JsonValue | null
    read: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    data?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>



  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    data?: boolean
    read?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "message" | "type" | "data" | "read" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      message: string
      type: $Enums.NotificationType
      data: Prisma.JsonValue | null
      read: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly data: FieldRef<"Notification", 'Json'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    fileUrl: string | null
    createdAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    fileUrl: string | null
    createdAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    fileUrl: number
    createdAt: number
    _all: number
  }


  export type DocumentMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    fileUrl?: true
    createdAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    fileUrl?: true
    createdAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    fileUrl?: true
    createdAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    userId: string
    title: string
    fileUrl: string
    createdAt: Date
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    fileUrl?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>



  export type DocumentSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    fileUrl?: boolean
    createdAt?: boolean
  }

  export type DocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "fileUrl" | "createdAt", ExtArgs["result"]["document"]>
  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      fileUrl: string
      createdAt: Date
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly userId: FieldRef<"Document", 'String'>
    readonly title: FieldRef<"Document", 'String'>
    readonly fileUrl: FieldRef<"Document", 'String'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to delete.
     */
    limit?: number
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model CompanyDocument
   */

  export type AggregateCompanyDocument = {
    _count: CompanyDocumentCountAggregateOutputType | null
    _min: CompanyDocumentMinAggregateOutputType | null
    _max: CompanyDocumentMaxAggregateOutputType | null
  }

  export type CompanyDocumentMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    fileUrl: string | null
    uploadedBy: string | null
    createdAt: Date | null
  }

  export type CompanyDocumentMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    fileUrl: string | null
    uploadedBy: string | null
    createdAt: Date | null
  }

  export type CompanyDocumentCountAggregateOutputType = {
    id: number
    title: number
    description: number
    fileUrl: number
    uploadedBy: number
    createdAt: number
    _all: number
  }


  export type CompanyDocumentMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    fileUrl?: true
    uploadedBy?: true
    createdAt?: true
  }

  export type CompanyDocumentMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    fileUrl?: true
    uploadedBy?: true
    createdAt?: true
  }

  export type CompanyDocumentCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    fileUrl?: true
    uploadedBy?: true
    createdAt?: true
    _all?: true
  }

  export type CompanyDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyDocument to aggregate.
     */
    where?: CompanyDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyDocuments to fetch.
     */
    orderBy?: CompanyDocumentOrderByWithRelationInput | CompanyDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyDocuments
    **/
    _count?: true | CompanyDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyDocumentMaxAggregateInputType
  }

  export type GetCompanyDocumentAggregateType<T extends CompanyDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyDocument[P]>
      : GetScalarType<T[P], AggregateCompanyDocument[P]>
  }




  export type CompanyDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyDocumentWhereInput
    orderBy?: CompanyDocumentOrderByWithAggregationInput | CompanyDocumentOrderByWithAggregationInput[]
    by: CompanyDocumentScalarFieldEnum[] | CompanyDocumentScalarFieldEnum
    having?: CompanyDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyDocumentCountAggregateInputType | true
    _min?: CompanyDocumentMinAggregateInputType
    _max?: CompanyDocumentMaxAggregateInputType
  }

  export type CompanyDocumentGroupByOutputType = {
    id: string
    title: string
    description: string | null
    fileUrl: string
    uploadedBy: string
    createdAt: Date
    _count: CompanyDocumentCountAggregateOutputType | null
    _min: CompanyDocumentMinAggregateOutputType | null
    _max: CompanyDocumentMaxAggregateOutputType | null
  }

  type GetCompanyDocumentGroupByPayload<T extends CompanyDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyDocumentGroupByOutputType[P]>
        }
      >
    >


  export type CompanyDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    fileUrl?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyDocument"]>



  export type CompanyDocumentSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    fileUrl?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
  }

  export type CompanyDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "fileUrl" | "uploadedBy" | "createdAt", ExtArgs["result"]["companyDocument"]>
  export type CompanyDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CompanyDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyDocument"
    objects: {
      uploader: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      fileUrl: string
      uploadedBy: string
      createdAt: Date
    }, ExtArgs["result"]["companyDocument"]>
    composites: {}
  }

  type CompanyDocumentGetPayload<S extends boolean | null | undefined | CompanyDocumentDefaultArgs> = $Result.GetResult<Prisma.$CompanyDocumentPayload, S>

  type CompanyDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyDocumentCountAggregateInputType | true
    }

  export interface CompanyDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyDocument'], meta: { name: 'CompanyDocument' } }
    /**
     * Find zero or one CompanyDocument that matches the filter.
     * @param {CompanyDocumentFindUniqueArgs} args - Arguments to find a CompanyDocument
     * @example
     * // Get one CompanyDocument
     * const companyDocument = await prisma.companyDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyDocumentFindUniqueArgs>(args: SelectSubset<T, CompanyDocumentFindUniqueArgs<ExtArgs>>): Prisma__CompanyDocumentClient<$Result.GetResult<Prisma.$CompanyDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanyDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyDocumentFindUniqueOrThrowArgs} args - Arguments to find a CompanyDocument
     * @example
     * // Get one CompanyDocument
     * const companyDocument = await prisma.companyDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyDocumentClient<$Result.GetResult<Prisma.$CompanyDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyDocumentFindFirstArgs} args - Arguments to find a CompanyDocument
     * @example
     * // Get one CompanyDocument
     * const companyDocument = await prisma.companyDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyDocumentFindFirstArgs>(args?: SelectSubset<T, CompanyDocumentFindFirstArgs<ExtArgs>>): Prisma__CompanyDocumentClient<$Result.GetResult<Prisma.$CompanyDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyDocumentFindFirstOrThrowArgs} args - Arguments to find a CompanyDocument
     * @example
     * // Get one CompanyDocument
     * const companyDocument = await prisma.companyDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyDocumentClient<$Result.GetResult<Prisma.$CompanyDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanyDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyDocuments
     * const companyDocuments = await prisma.companyDocument.findMany()
     * 
     * // Get first 10 CompanyDocuments
     * const companyDocuments = await prisma.companyDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyDocumentWithIdOnly = await prisma.companyDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyDocumentFindManyArgs>(args?: SelectSubset<T, CompanyDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanyDocument.
     * @param {CompanyDocumentCreateArgs} args - Arguments to create a CompanyDocument.
     * @example
     * // Create one CompanyDocument
     * const CompanyDocument = await prisma.companyDocument.create({
     *   data: {
     *     // ... data to create a CompanyDocument
     *   }
     * })
     * 
     */
    create<T extends CompanyDocumentCreateArgs>(args: SelectSubset<T, CompanyDocumentCreateArgs<ExtArgs>>): Prisma__CompanyDocumentClient<$Result.GetResult<Prisma.$CompanyDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanyDocuments.
     * @param {CompanyDocumentCreateManyArgs} args - Arguments to create many CompanyDocuments.
     * @example
     * // Create many CompanyDocuments
     * const companyDocument = await prisma.companyDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyDocumentCreateManyArgs>(args?: SelectSubset<T, CompanyDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CompanyDocument.
     * @param {CompanyDocumentDeleteArgs} args - Arguments to delete one CompanyDocument.
     * @example
     * // Delete one CompanyDocument
     * const CompanyDocument = await prisma.companyDocument.delete({
     *   where: {
     *     // ... filter to delete one CompanyDocument
     *   }
     * })
     * 
     */
    delete<T extends CompanyDocumentDeleteArgs>(args: SelectSubset<T, CompanyDocumentDeleteArgs<ExtArgs>>): Prisma__CompanyDocumentClient<$Result.GetResult<Prisma.$CompanyDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanyDocument.
     * @param {CompanyDocumentUpdateArgs} args - Arguments to update one CompanyDocument.
     * @example
     * // Update one CompanyDocument
     * const companyDocument = await prisma.companyDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyDocumentUpdateArgs>(args: SelectSubset<T, CompanyDocumentUpdateArgs<ExtArgs>>): Prisma__CompanyDocumentClient<$Result.GetResult<Prisma.$CompanyDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanyDocuments.
     * @param {CompanyDocumentDeleteManyArgs} args - Arguments to filter CompanyDocuments to delete.
     * @example
     * // Delete a few CompanyDocuments
     * const { count } = await prisma.companyDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDocumentDeleteManyArgs>(args?: SelectSubset<T, CompanyDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyDocuments
     * const companyDocument = await prisma.companyDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyDocumentUpdateManyArgs>(args: SelectSubset<T, CompanyDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanyDocument.
     * @param {CompanyDocumentUpsertArgs} args - Arguments to update or create a CompanyDocument.
     * @example
     * // Update or create a CompanyDocument
     * const companyDocument = await prisma.companyDocument.upsert({
     *   create: {
     *     // ... data to create a CompanyDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyDocument we want to update
     *   }
     * })
     */
    upsert<T extends CompanyDocumentUpsertArgs>(args: SelectSubset<T, CompanyDocumentUpsertArgs<ExtArgs>>): Prisma__CompanyDocumentClient<$Result.GetResult<Prisma.$CompanyDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanyDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyDocumentCountArgs} args - Arguments to filter CompanyDocuments to count.
     * @example
     * // Count the number of CompanyDocuments
     * const count = await prisma.companyDocument.count({
     *   where: {
     *     // ... the filter for the CompanyDocuments we want to count
     *   }
     * })
    **/
    count<T extends CompanyDocumentCountArgs>(
      args?: Subset<T, CompanyDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyDocumentAggregateArgs>(args: Subset<T, CompanyDocumentAggregateArgs>): Prisma.PrismaPromise<GetCompanyDocumentAggregateType<T>>

    /**
     * Group by CompanyDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyDocumentGroupByArgs['orderBy'] }
        : { orderBy?: CompanyDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyDocument model
   */
  readonly fields: CompanyDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    uploader<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyDocument model
   */
  interface CompanyDocumentFieldRefs {
    readonly id: FieldRef<"CompanyDocument", 'String'>
    readonly title: FieldRef<"CompanyDocument", 'String'>
    readonly description: FieldRef<"CompanyDocument", 'String'>
    readonly fileUrl: FieldRef<"CompanyDocument", 'String'>
    readonly uploadedBy: FieldRef<"CompanyDocument", 'String'>
    readonly createdAt: FieldRef<"CompanyDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyDocument findUnique
   */
  export type CompanyDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentInclude<ExtArgs> | null
    /**
     * Filter, which CompanyDocument to fetch.
     */
    where: CompanyDocumentWhereUniqueInput
  }

  /**
   * CompanyDocument findUniqueOrThrow
   */
  export type CompanyDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentInclude<ExtArgs> | null
    /**
     * Filter, which CompanyDocument to fetch.
     */
    where: CompanyDocumentWhereUniqueInput
  }

  /**
   * CompanyDocument findFirst
   */
  export type CompanyDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentInclude<ExtArgs> | null
    /**
     * Filter, which CompanyDocument to fetch.
     */
    where?: CompanyDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyDocuments to fetch.
     */
    orderBy?: CompanyDocumentOrderByWithRelationInput | CompanyDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyDocuments.
     */
    cursor?: CompanyDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyDocuments.
     */
    distinct?: CompanyDocumentScalarFieldEnum | CompanyDocumentScalarFieldEnum[]
  }

  /**
   * CompanyDocument findFirstOrThrow
   */
  export type CompanyDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentInclude<ExtArgs> | null
    /**
     * Filter, which CompanyDocument to fetch.
     */
    where?: CompanyDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyDocuments to fetch.
     */
    orderBy?: CompanyDocumentOrderByWithRelationInput | CompanyDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyDocuments.
     */
    cursor?: CompanyDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyDocuments.
     */
    distinct?: CompanyDocumentScalarFieldEnum | CompanyDocumentScalarFieldEnum[]
  }

  /**
   * CompanyDocument findMany
   */
  export type CompanyDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentInclude<ExtArgs> | null
    /**
     * Filter, which CompanyDocuments to fetch.
     */
    where?: CompanyDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyDocuments to fetch.
     */
    orderBy?: CompanyDocumentOrderByWithRelationInput | CompanyDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyDocuments.
     */
    cursor?: CompanyDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyDocuments.
     */
    skip?: number
    distinct?: CompanyDocumentScalarFieldEnum | CompanyDocumentScalarFieldEnum[]
  }

  /**
   * CompanyDocument create
   */
  export type CompanyDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyDocument.
     */
    data: XOR<CompanyDocumentCreateInput, CompanyDocumentUncheckedCreateInput>
  }

  /**
   * CompanyDocument createMany
   */
  export type CompanyDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyDocuments.
     */
    data: CompanyDocumentCreateManyInput | CompanyDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyDocument update
   */
  export type CompanyDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyDocument.
     */
    data: XOR<CompanyDocumentUpdateInput, CompanyDocumentUncheckedUpdateInput>
    /**
     * Choose, which CompanyDocument to update.
     */
    where: CompanyDocumentWhereUniqueInput
  }

  /**
   * CompanyDocument updateMany
   */
  export type CompanyDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyDocuments.
     */
    data: XOR<CompanyDocumentUpdateManyMutationInput, CompanyDocumentUncheckedUpdateManyInput>
    /**
     * Filter which CompanyDocuments to update
     */
    where?: CompanyDocumentWhereInput
    /**
     * Limit how many CompanyDocuments to update.
     */
    limit?: number
  }

  /**
   * CompanyDocument upsert
   */
  export type CompanyDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyDocument to update in case it exists.
     */
    where: CompanyDocumentWhereUniqueInput
    /**
     * In case the CompanyDocument found by the `where` argument doesn't exist, create a new CompanyDocument with this data.
     */
    create: XOR<CompanyDocumentCreateInput, CompanyDocumentUncheckedCreateInput>
    /**
     * In case the CompanyDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyDocumentUpdateInput, CompanyDocumentUncheckedUpdateInput>
  }

  /**
   * CompanyDocument delete
   */
  export type CompanyDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentInclude<ExtArgs> | null
    /**
     * Filter which CompanyDocument to delete.
     */
    where: CompanyDocumentWhereUniqueInput
  }

  /**
   * CompanyDocument deleteMany
   */
  export type CompanyDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyDocuments to delete
     */
    where?: CompanyDocumentWhereInput
    /**
     * Limit how many CompanyDocuments to delete.
     */
    limit?: number
  }

  /**
   * CompanyDocument without action
   */
  export type CompanyDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentInclude<ExtArgs> | null
  }


  /**
   * Model Expense
   */

  export type AggregateExpense = {
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  export type ExpenseAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type ExpenseSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type ExpenseMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    category: string | null
    amount: Decimal | null
    currency: string | null
    date: Date | null
    status: $Enums.ExpenseStatus | null
    receiptUrl: string | null
    submittedAt: Date | null
    approvedAt: Date | null
    approvedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenseMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    category: string | null
    amount: Decimal | null
    currency: string | null
    date: Date | null
    status: $Enums.ExpenseStatus | null
    receiptUrl: string | null
    submittedAt: Date | null
    approvedAt: Date | null
    approvedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenseCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    description: number
    category: number
    amount: number
    currency: number
    date: number
    status: number
    receiptUrl: number
    submittedAt: number
    approvedAt: number
    approvedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExpenseAvgAggregateInputType = {
    amount?: true
  }

  export type ExpenseSumAggregateInputType = {
    amount?: true
  }

  export type ExpenseMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    category?: true
    amount?: true
    currency?: true
    date?: true
    status?: true
    receiptUrl?: true
    submittedAt?: true
    approvedAt?: true
    approvedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenseMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    category?: true
    amount?: true
    currency?: true
    date?: true
    status?: true
    receiptUrl?: true
    submittedAt?: true
    approvedAt?: true
    approvedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenseCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    category?: true
    amount?: true
    currency?: true
    date?: true
    status?: true
    receiptUrl?: true
    submittedAt?: true
    approvedAt?: true
    approvedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExpenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expense to aggregate.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Expenses
    **/
    _count?: true | ExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseMaxAggregateInputType
  }

  export type GetExpenseAggregateType<T extends ExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpense[P]>
      : GetScalarType<T[P], AggregateExpense[P]>
  }




  export type ExpenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithAggregationInput | ExpenseOrderByWithAggregationInput[]
    by: ExpenseScalarFieldEnum[] | ExpenseScalarFieldEnum
    having?: ExpenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseCountAggregateInputType | true
    _avg?: ExpenseAvgAggregateInputType
    _sum?: ExpenseSumAggregateInputType
    _min?: ExpenseMinAggregateInputType
    _max?: ExpenseMaxAggregateInputType
  }

  export type ExpenseGroupByOutputType = {
    id: string
    userId: string
    title: string
    description: string | null
    category: string | null
    amount: Decimal
    currency: string
    date: Date
    status: $Enums.ExpenseStatus
    receiptUrl: string | null
    submittedAt: Date
    approvedAt: Date | null
    approvedById: string | null
    createdAt: Date
    updatedAt: Date
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  type GetExpenseGroupByPayload<T extends ExpenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    amount?: boolean
    currency?: boolean
    date?: boolean
    status?: boolean
    receiptUrl?: boolean
    submittedAt?: boolean
    approvedAt?: boolean
    approvedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | Expense$approverArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>



  export type ExpenseSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    amount?: boolean
    currency?: boolean
    date?: boolean
    status?: boolean
    receiptUrl?: boolean
    submittedAt?: boolean
    approvedAt?: boolean
    approvedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExpenseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "description" | "category" | "amount" | "currency" | "date" | "status" | "receiptUrl" | "submittedAt" | "approvedAt" | "approvedById" | "createdAt" | "updatedAt", ExtArgs["result"]["expense"]>
  export type ExpenseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | Expense$approverArgs<ExtArgs>
  }

  export type $ExpensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Expense"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      approver: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      description: string | null
      category: string | null
      amount: Prisma.Decimal
      currency: string
      date: Date
      status: $Enums.ExpenseStatus
      receiptUrl: string | null
      submittedAt: Date
      approvedAt: Date | null
      approvedById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["expense"]>
    composites: {}
  }

  type ExpenseGetPayload<S extends boolean | null | undefined | ExpenseDefaultArgs> = $Result.GetResult<Prisma.$ExpensePayload, S>

  type ExpenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExpenseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExpenseCountAggregateInputType | true
    }

  export interface ExpenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Expense'], meta: { name: 'Expense' } }
    /**
     * Find zero or one Expense that matches the filter.
     * @param {ExpenseFindUniqueArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseFindUniqueArgs>(args: SelectSubset<T, ExpenseFindUniqueArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Expense that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExpenseFindUniqueOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseFindFirstArgs>(args?: SelectSubset<T, ExpenseFindFirstArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Expenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Expenses
     * const expenses = await prisma.expense.findMany()
     * 
     * // Get first 10 Expenses
     * const expenses = await prisma.expense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseWithIdOnly = await prisma.expense.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseFindManyArgs>(args?: SelectSubset<T, ExpenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Expense.
     * @param {ExpenseCreateArgs} args - Arguments to create a Expense.
     * @example
     * // Create one Expense
     * const Expense = await prisma.expense.create({
     *   data: {
     *     // ... data to create a Expense
     *   }
     * })
     * 
     */
    create<T extends ExpenseCreateArgs>(args: SelectSubset<T, ExpenseCreateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Expenses.
     * @param {ExpenseCreateManyArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseCreateManyArgs>(args?: SelectSubset<T, ExpenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Expense.
     * @param {ExpenseDeleteArgs} args - Arguments to delete one Expense.
     * @example
     * // Delete one Expense
     * const Expense = await prisma.expense.delete({
     *   where: {
     *     // ... filter to delete one Expense
     *   }
     * })
     * 
     */
    delete<T extends ExpenseDeleteArgs>(args: SelectSubset<T, ExpenseDeleteArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Expense.
     * @param {ExpenseUpdateArgs} args - Arguments to update one Expense.
     * @example
     * // Update one Expense
     * const expense = await prisma.expense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseUpdateArgs>(args: SelectSubset<T, ExpenseUpdateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Expenses.
     * @param {ExpenseDeleteManyArgs} args - Arguments to filter Expenses to delete.
     * @example
     * // Delete a few Expenses
     * const { count } = await prisma.expense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseDeleteManyArgs>(args?: SelectSubset<T, ExpenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseUpdateManyArgs>(args: SelectSubset<T, ExpenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Expense.
     * @param {ExpenseUpsertArgs} args - Arguments to update or create a Expense.
     * @example
     * // Update or create a Expense
     * const expense = await prisma.expense.upsert({
     *   create: {
     *     // ... data to create a Expense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Expense we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseUpsertArgs>(args: SelectSubset<T, ExpenseUpsertArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCountArgs} args - Arguments to filter Expenses to count.
     * @example
     * // Count the number of Expenses
     * const count = await prisma.expense.count({
     *   where: {
     *     // ... the filter for the Expenses we want to count
     *   }
     * })
    **/
    count<T extends ExpenseCountArgs>(
      args?: Subset<T, ExpenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseAggregateArgs>(args: Subset<T, ExpenseAggregateArgs>): Prisma.PrismaPromise<GetExpenseAggregateType<T>>

    /**
     * Group by Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Expense model
   */
  readonly fields: ExpenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Expense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    approver<T extends Expense$approverArgs<ExtArgs> = {}>(args?: Subset<T, Expense$approverArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Expense model
   */
  interface ExpenseFieldRefs {
    readonly id: FieldRef<"Expense", 'String'>
    readonly userId: FieldRef<"Expense", 'String'>
    readonly title: FieldRef<"Expense", 'String'>
    readonly description: FieldRef<"Expense", 'String'>
    readonly category: FieldRef<"Expense", 'String'>
    readonly amount: FieldRef<"Expense", 'Decimal'>
    readonly currency: FieldRef<"Expense", 'String'>
    readonly date: FieldRef<"Expense", 'DateTime'>
    readonly status: FieldRef<"Expense", 'ExpenseStatus'>
    readonly receiptUrl: FieldRef<"Expense", 'String'>
    readonly submittedAt: FieldRef<"Expense", 'DateTime'>
    readonly approvedAt: FieldRef<"Expense", 'DateTime'>
    readonly approvedById: FieldRef<"Expense", 'String'>
    readonly createdAt: FieldRef<"Expense", 'DateTime'>
    readonly updatedAt: FieldRef<"Expense", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Expense findUnique
   */
  export type ExpenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findUniqueOrThrow
   */
  export type ExpenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findFirst
   */
  export type ExpenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findFirstOrThrow
   */
  export type ExpenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findMany
   */
  export type ExpenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expenses to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense create
   */
  export type ExpenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to create a Expense.
     */
    data: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
  }

  /**
   * Expense createMany
   */
  export type ExpenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Expense update
   */
  export type ExpenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to update a Expense.
     */
    data: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
    /**
     * Choose, which Expense to update.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense updateMany
   */
  export type ExpenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to update.
     */
    limit?: number
  }

  /**
   * Expense upsert
   */
  export type ExpenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The filter to search for the Expense to update in case it exists.
     */
    where: ExpenseWhereUniqueInput
    /**
     * In case the Expense found by the `where` argument doesn't exist, create a new Expense with this data.
     */
    create: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
    /**
     * In case the Expense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
  }

  /**
   * Expense delete
   */
  export type ExpenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter which Expense to delete.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense deleteMany
   */
  export type ExpenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expenses to delete
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to delete.
     */
    limit?: number
  }

  /**
   * Expense.approver
   */
  export type Expense$approverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Expense without action
   */
  export type ExpenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
  }


  /**
   * Model Asset
   */

  export type AggregateAsset = {
    _count: AssetCountAggregateOutputType | null
    _min: AssetMinAggregateOutputType | null
    _max: AssetMaxAggregateOutputType | null
  }

  export type AssetMinAggregateOutputType = {
    id: string | null
    tag: string | null
    name: string | null
    type: string | null
    serialNumber: string | null
    purchaseDate: Date | null
    status: $Enums.AssetStatus | null
    assignedToId: string | null
    assignedAt: Date | null
    location: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssetMaxAggregateOutputType = {
    id: string | null
    tag: string | null
    name: string | null
    type: string | null
    serialNumber: string | null
    purchaseDate: Date | null
    status: $Enums.AssetStatus | null
    assignedToId: string | null
    assignedAt: Date | null
    location: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssetCountAggregateOutputType = {
    id: number
    tag: number
    name: number
    type: number
    serialNumber: number
    purchaseDate: number
    status: number
    assignedToId: number
    assignedAt: number
    location: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AssetMinAggregateInputType = {
    id?: true
    tag?: true
    name?: true
    type?: true
    serialNumber?: true
    purchaseDate?: true
    status?: true
    assignedToId?: true
    assignedAt?: true
    location?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssetMaxAggregateInputType = {
    id?: true
    tag?: true
    name?: true
    type?: true
    serialNumber?: true
    purchaseDate?: true
    status?: true
    assignedToId?: true
    assignedAt?: true
    location?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssetCountAggregateInputType = {
    id?: true
    tag?: true
    name?: true
    type?: true
    serialNumber?: true
    purchaseDate?: true
    status?: true
    assignedToId?: true
    assignedAt?: true
    location?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AssetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Asset to aggregate.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assets
    **/
    _count?: true | AssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetMaxAggregateInputType
  }

  export type GetAssetAggregateType<T extends AssetAggregateArgs> = {
        [P in keyof T & keyof AggregateAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAsset[P]>
      : GetScalarType<T[P], AggregateAsset[P]>
  }




  export type AssetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithAggregationInput | AssetOrderByWithAggregationInput[]
    by: AssetScalarFieldEnum[] | AssetScalarFieldEnum
    having?: AssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetCountAggregateInputType | true
    _min?: AssetMinAggregateInputType
    _max?: AssetMaxAggregateInputType
  }

  export type AssetGroupByOutputType = {
    id: string
    tag: string
    name: string
    type: string | null
    serialNumber: string | null
    purchaseDate: Date | null
    status: $Enums.AssetStatus
    assignedToId: string | null
    assignedAt: Date | null
    location: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: AssetCountAggregateOutputType | null
    _min: AssetMinAggregateOutputType | null
    _max: AssetMaxAggregateOutputType | null
  }

  type GetAssetGroupByPayload<T extends AssetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetGroupByOutputType[P]>
            : GetScalarType<T[P], AssetGroupByOutputType[P]>
        }
      >
    >


  export type AssetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tag?: boolean
    name?: boolean
    type?: boolean
    serialNumber?: boolean
    purchaseDate?: boolean
    status?: boolean
    assignedToId?: boolean
    assignedAt?: boolean
    location?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedTo?: boolean | Asset$assignedToArgs<ExtArgs>
  }, ExtArgs["result"]["asset"]>



  export type AssetSelectScalar = {
    id?: boolean
    tag?: boolean
    name?: boolean
    type?: boolean
    serialNumber?: boolean
    purchaseDate?: boolean
    status?: boolean
    assignedToId?: boolean
    assignedAt?: boolean
    location?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AssetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tag" | "name" | "type" | "serialNumber" | "purchaseDate" | "status" | "assignedToId" | "assignedAt" | "location" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["asset"]>
  export type AssetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | Asset$assignedToArgs<ExtArgs>
  }

  export type $AssetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Asset"
    objects: {
      assignedTo: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tag: string
      name: string
      type: string | null
      serialNumber: string | null
      purchaseDate: Date | null
      status: $Enums.AssetStatus
      assignedToId: string | null
      assignedAt: Date | null
      location: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["asset"]>
    composites: {}
  }

  type AssetGetPayload<S extends boolean | null | undefined | AssetDefaultArgs> = $Result.GetResult<Prisma.$AssetPayload, S>

  type AssetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssetCountAggregateInputType | true
    }

  export interface AssetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Asset'], meta: { name: 'Asset' } }
    /**
     * Find zero or one Asset that matches the filter.
     * @param {AssetFindUniqueArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssetFindUniqueArgs>(args: SelectSubset<T, AssetFindUniqueArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Asset that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssetFindUniqueOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssetFindUniqueOrThrowArgs>(args: SelectSubset<T, AssetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Asset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssetFindFirstArgs>(args?: SelectSubset<T, AssetFindFirstArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Asset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssetFindFirstOrThrowArgs>(args?: SelectSubset<T, AssetFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Assets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assets
     * const assets = await prisma.asset.findMany()
     * 
     * // Get first 10 Assets
     * const assets = await prisma.asset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assetWithIdOnly = await prisma.asset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssetFindManyArgs>(args?: SelectSubset<T, AssetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Asset.
     * @param {AssetCreateArgs} args - Arguments to create a Asset.
     * @example
     * // Create one Asset
     * const Asset = await prisma.asset.create({
     *   data: {
     *     // ... data to create a Asset
     *   }
     * })
     * 
     */
    create<T extends AssetCreateArgs>(args: SelectSubset<T, AssetCreateArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Assets.
     * @param {AssetCreateManyArgs} args - Arguments to create many Assets.
     * @example
     * // Create many Assets
     * const asset = await prisma.asset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssetCreateManyArgs>(args?: SelectSubset<T, AssetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Asset.
     * @param {AssetDeleteArgs} args - Arguments to delete one Asset.
     * @example
     * // Delete one Asset
     * const Asset = await prisma.asset.delete({
     *   where: {
     *     // ... filter to delete one Asset
     *   }
     * })
     * 
     */
    delete<T extends AssetDeleteArgs>(args: SelectSubset<T, AssetDeleteArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Asset.
     * @param {AssetUpdateArgs} args - Arguments to update one Asset.
     * @example
     * // Update one Asset
     * const asset = await prisma.asset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssetUpdateArgs>(args: SelectSubset<T, AssetUpdateArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Assets.
     * @param {AssetDeleteManyArgs} args - Arguments to filter Assets to delete.
     * @example
     * // Delete a few Assets
     * const { count } = await prisma.asset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssetDeleteManyArgs>(args?: SelectSubset<T, AssetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assets
     * const asset = await prisma.asset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssetUpdateManyArgs>(args: SelectSubset<T, AssetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Asset.
     * @param {AssetUpsertArgs} args - Arguments to update or create a Asset.
     * @example
     * // Update or create a Asset
     * const asset = await prisma.asset.upsert({
     *   create: {
     *     // ... data to create a Asset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Asset we want to update
     *   }
     * })
     */
    upsert<T extends AssetUpsertArgs>(args: SelectSubset<T, AssetUpsertArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetCountArgs} args - Arguments to filter Assets to count.
     * @example
     * // Count the number of Assets
     * const count = await prisma.asset.count({
     *   where: {
     *     // ... the filter for the Assets we want to count
     *   }
     * })
    **/
    count<T extends AssetCountArgs>(
      args?: Subset<T, AssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetAggregateArgs>(args: Subset<T, AssetAggregateArgs>): Prisma.PrismaPromise<GetAssetAggregateType<T>>

    /**
     * Group by Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetGroupByArgs['orderBy'] }
        : { orderBy?: AssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Asset model
   */
  readonly fields: AssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Asset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignedTo<T extends Asset$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, Asset$assignedToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Asset model
   */
  interface AssetFieldRefs {
    readonly id: FieldRef<"Asset", 'String'>
    readonly tag: FieldRef<"Asset", 'String'>
    readonly name: FieldRef<"Asset", 'String'>
    readonly type: FieldRef<"Asset", 'String'>
    readonly serialNumber: FieldRef<"Asset", 'String'>
    readonly purchaseDate: FieldRef<"Asset", 'DateTime'>
    readonly status: FieldRef<"Asset", 'AssetStatus'>
    readonly assignedToId: FieldRef<"Asset", 'String'>
    readonly assignedAt: FieldRef<"Asset", 'DateTime'>
    readonly location: FieldRef<"Asset", 'String'>
    readonly notes: FieldRef<"Asset", 'String'>
    readonly createdAt: FieldRef<"Asset", 'DateTime'>
    readonly updatedAt: FieldRef<"Asset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Asset findUnique
   */
  export type AssetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset findUniqueOrThrow
   */
  export type AssetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset findFirst
   */
  export type AssetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset findFirstOrThrow
   */
  export type AssetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset findMany
   */
  export type AssetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Assets to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset create
   */
  export type AssetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The data needed to create a Asset.
     */
    data: XOR<AssetCreateInput, AssetUncheckedCreateInput>
  }

  /**
   * Asset createMany
   */
  export type AssetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assets.
     */
    data: AssetCreateManyInput | AssetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Asset update
   */
  export type AssetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The data needed to update a Asset.
     */
    data: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>
    /**
     * Choose, which Asset to update.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset updateMany
   */
  export type AssetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assets.
     */
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyInput>
    /**
     * Filter which Assets to update
     */
    where?: AssetWhereInput
    /**
     * Limit how many Assets to update.
     */
    limit?: number
  }

  /**
   * Asset upsert
   */
  export type AssetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The filter to search for the Asset to update in case it exists.
     */
    where: AssetWhereUniqueInput
    /**
     * In case the Asset found by the `where` argument doesn't exist, create a new Asset with this data.
     */
    create: XOR<AssetCreateInput, AssetUncheckedCreateInput>
    /**
     * In case the Asset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>
  }

  /**
   * Asset delete
   */
  export type AssetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter which Asset to delete.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset deleteMany
   */
  export type AssetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assets to delete
     */
    where?: AssetWhereInput
    /**
     * Limit how many Assets to delete.
     */
    limit?: number
  }

  /**
   * Asset.assignedTo
   */
  export type Asset$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Asset without action
   */
  export type AssetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
  }


  /**
   * Model Payroll
   */

  export type AggregatePayroll = {
    _count: PayrollCountAggregateOutputType | null
    _avg: PayrollAvgAggregateOutputType | null
    _sum: PayrollSumAggregateOutputType | null
    _min: PayrollMinAggregateOutputType | null
    _max: PayrollMaxAggregateOutputType | null
  }

  export type PayrollAvgAggregateOutputType = {
    month: number | null
    year: number | null
    baseSalary: Decimal | null
    allowances: Decimal | null
    deductions: Decimal | null
    netPay: Decimal | null
  }

  export type PayrollSumAggregateOutputType = {
    month: number | null
    year: number | null
    baseSalary: Decimal | null
    allowances: Decimal | null
    deductions: Decimal | null
    netPay: Decimal | null
  }

  export type PayrollMinAggregateOutputType = {
    id: string | null
    userId: string | null
    month: number | null
    year: number | null
    baseSalary: Decimal | null
    allowances: Decimal | null
    deductions: Decimal | null
    netPay: Decimal | null
    currency: string | null
    status: $Enums.PayrollStatus | null
    generatedById: string | null
    generatedAt: Date | null
    paidAt: Date | null
    slipUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayrollMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    month: number | null
    year: number | null
    baseSalary: Decimal | null
    allowances: Decimal | null
    deductions: Decimal | null
    netPay: Decimal | null
    currency: string | null
    status: $Enums.PayrollStatus | null
    generatedById: string | null
    generatedAt: Date | null
    paidAt: Date | null
    slipUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayrollCountAggregateOutputType = {
    id: number
    userId: number
    month: number
    year: number
    baseSalary: number
    allowances: number
    deductions: number
    netPay: number
    currency: number
    status: number
    generatedById: number
    generatedAt: number
    paidAt: number
    slipUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PayrollAvgAggregateInputType = {
    month?: true
    year?: true
    baseSalary?: true
    allowances?: true
    deductions?: true
    netPay?: true
  }

  export type PayrollSumAggregateInputType = {
    month?: true
    year?: true
    baseSalary?: true
    allowances?: true
    deductions?: true
    netPay?: true
  }

  export type PayrollMinAggregateInputType = {
    id?: true
    userId?: true
    month?: true
    year?: true
    baseSalary?: true
    allowances?: true
    deductions?: true
    netPay?: true
    currency?: true
    status?: true
    generatedById?: true
    generatedAt?: true
    paidAt?: true
    slipUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayrollMaxAggregateInputType = {
    id?: true
    userId?: true
    month?: true
    year?: true
    baseSalary?: true
    allowances?: true
    deductions?: true
    netPay?: true
    currency?: true
    status?: true
    generatedById?: true
    generatedAt?: true
    paidAt?: true
    slipUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayrollCountAggregateInputType = {
    id?: true
    userId?: true
    month?: true
    year?: true
    baseSalary?: true
    allowances?: true
    deductions?: true
    netPay?: true
    currency?: true
    status?: true
    generatedById?: true
    generatedAt?: true
    paidAt?: true
    slipUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PayrollAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payroll to aggregate.
     */
    where?: PayrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payrolls to fetch.
     */
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PayrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payrolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payrolls
    **/
    _count?: true | PayrollCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PayrollAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PayrollSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayrollMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayrollMaxAggregateInputType
  }

  export type GetPayrollAggregateType<T extends PayrollAggregateArgs> = {
        [P in keyof T & keyof AggregatePayroll]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayroll[P]>
      : GetScalarType<T[P], AggregatePayroll[P]>
  }




  export type PayrollGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollWhereInput
    orderBy?: PayrollOrderByWithAggregationInput | PayrollOrderByWithAggregationInput[]
    by: PayrollScalarFieldEnum[] | PayrollScalarFieldEnum
    having?: PayrollScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayrollCountAggregateInputType | true
    _avg?: PayrollAvgAggregateInputType
    _sum?: PayrollSumAggregateInputType
    _min?: PayrollMinAggregateInputType
    _max?: PayrollMaxAggregateInputType
  }

  export type PayrollGroupByOutputType = {
    id: string
    userId: string
    month: number
    year: number
    baseSalary: Decimal
    allowances: Decimal
    deductions: Decimal
    netPay: Decimal
    currency: string
    status: $Enums.PayrollStatus
    generatedById: string | null
    generatedAt: Date | null
    paidAt: Date | null
    slipUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: PayrollCountAggregateOutputType | null
    _avg: PayrollAvgAggregateOutputType | null
    _sum: PayrollSumAggregateOutputType | null
    _min: PayrollMinAggregateOutputType | null
    _max: PayrollMaxAggregateOutputType | null
  }

  type GetPayrollGroupByPayload<T extends PayrollGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PayrollGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayrollGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayrollGroupByOutputType[P]>
            : GetScalarType<T[P], PayrollGroupByOutputType[P]>
        }
      >
    >


  export type PayrollSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    month?: boolean
    year?: boolean
    baseSalary?: boolean
    allowances?: boolean
    deductions?: boolean
    netPay?: boolean
    currency?: boolean
    status?: boolean
    generatedById?: boolean
    generatedAt?: boolean
    paidAt?: boolean
    slipUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    generatedBy?: boolean | Payroll$generatedByArgs<ExtArgs>
  }, ExtArgs["result"]["payroll"]>



  export type PayrollSelectScalar = {
    id?: boolean
    userId?: boolean
    month?: boolean
    year?: boolean
    baseSalary?: boolean
    allowances?: boolean
    deductions?: boolean
    netPay?: boolean
    currency?: boolean
    status?: boolean
    generatedById?: boolean
    generatedAt?: boolean
    paidAt?: boolean
    slipUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PayrollOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "month" | "year" | "baseSalary" | "allowances" | "deductions" | "netPay" | "currency" | "status" | "generatedById" | "generatedAt" | "paidAt" | "slipUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["payroll"]>
  export type PayrollInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    generatedBy?: boolean | Payroll$generatedByArgs<ExtArgs>
  }

  export type $PayrollPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payroll"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      generatedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      month: number
      year: number
      baseSalary: Prisma.Decimal
      allowances: Prisma.Decimal
      deductions: Prisma.Decimal
      netPay: Prisma.Decimal
      currency: string
      status: $Enums.PayrollStatus
      generatedById: string | null
      generatedAt: Date | null
      paidAt: Date | null
      slipUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payroll"]>
    composites: {}
  }

  type PayrollGetPayload<S extends boolean | null | undefined | PayrollDefaultArgs> = $Result.GetResult<Prisma.$PayrollPayload, S>

  type PayrollCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PayrollFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PayrollCountAggregateInputType | true
    }

  export interface PayrollDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payroll'], meta: { name: 'Payroll' } }
    /**
     * Find zero or one Payroll that matches the filter.
     * @param {PayrollFindUniqueArgs} args - Arguments to find a Payroll
     * @example
     * // Get one Payroll
     * const payroll = await prisma.payroll.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PayrollFindUniqueArgs>(args: SelectSubset<T, PayrollFindUniqueArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payroll that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PayrollFindUniqueOrThrowArgs} args - Arguments to find a Payroll
     * @example
     * // Get one Payroll
     * const payroll = await prisma.payroll.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PayrollFindUniqueOrThrowArgs>(args: SelectSubset<T, PayrollFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payroll that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollFindFirstArgs} args - Arguments to find a Payroll
     * @example
     * // Get one Payroll
     * const payroll = await prisma.payroll.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PayrollFindFirstArgs>(args?: SelectSubset<T, PayrollFindFirstArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payroll that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollFindFirstOrThrowArgs} args - Arguments to find a Payroll
     * @example
     * // Get one Payroll
     * const payroll = await prisma.payroll.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PayrollFindFirstOrThrowArgs>(args?: SelectSubset<T, PayrollFindFirstOrThrowArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payrolls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payrolls
     * const payrolls = await prisma.payroll.findMany()
     * 
     * // Get first 10 Payrolls
     * const payrolls = await prisma.payroll.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payrollWithIdOnly = await prisma.payroll.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PayrollFindManyArgs>(args?: SelectSubset<T, PayrollFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payroll.
     * @param {PayrollCreateArgs} args - Arguments to create a Payroll.
     * @example
     * // Create one Payroll
     * const Payroll = await prisma.payroll.create({
     *   data: {
     *     // ... data to create a Payroll
     *   }
     * })
     * 
     */
    create<T extends PayrollCreateArgs>(args: SelectSubset<T, PayrollCreateArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payrolls.
     * @param {PayrollCreateManyArgs} args - Arguments to create many Payrolls.
     * @example
     * // Create many Payrolls
     * const payroll = await prisma.payroll.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PayrollCreateManyArgs>(args?: SelectSubset<T, PayrollCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payroll.
     * @param {PayrollDeleteArgs} args - Arguments to delete one Payroll.
     * @example
     * // Delete one Payroll
     * const Payroll = await prisma.payroll.delete({
     *   where: {
     *     // ... filter to delete one Payroll
     *   }
     * })
     * 
     */
    delete<T extends PayrollDeleteArgs>(args: SelectSubset<T, PayrollDeleteArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payroll.
     * @param {PayrollUpdateArgs} args - Arguments to update one Payroll.
     * @example
     * // Update one Payroll
     * const payroll = await prisma.payroll.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PayrollUpdateArgs>(args: SelectSubset<T, PayrollUpdateArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payrolls.
     * @param {PayrollDeleteManyArgs} args - Arguments to filter Payrolls to delete.
     * @example
     * // Delete a few Payrolls
     * const { count } = await prisma.payroll.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PayrollDeleteManyArgs>(args?: SelectSubset<T, PayrollDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payrolls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payrolls
     * const payroll = await prisma.payroll.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PayrollUpdateManyArgs>(args: SelectSubset<T, PayrollUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payroll.
     * @param {PayrollUpsertArgs} args - Arguments to update or create a Payroll.
     * @example
     * // Update or create a Payroll
     * const payroll = await prisma.payroll.upsert({
     *   create: {
     *     // ... data to create a Payroll
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payroll we want to update
     *   }
     * })
     */
    upsert<T extends PayrollUpsertArgs>(args: SelectSubset<T, PayrollUpsertArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payrolls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollCountArgs} args - Arguments to filter Payrolls to count.
     * @example
     * // Count the number of Payrolls
     * const count = await prisma.payroll.count({
     *   where: {
     *     // ... the filter for the Payrolls we want to count
     *   }
     * })
    **/
    count<T extends PayrollCountArgs>(
      args?: Subset<T, PayrollCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayrollCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payroll.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayrollAggregateArgs>(args: Subset<T, PayrollAggregateArgs>): Prisma.PrismaPromise<GetPayrollAggregateType<T>>

    /**
     * Group by Payroll.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayrollGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayrollGroupByArgs['orderBy'] }
        : { orderBy?: PayrollGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayrollGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayrollGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payroll model
   */
  readonly fields: PayrollFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payroll.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PayrollClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    generatedBy<T extends Payroll$generatedByArgs<ExtArgs> = {}>(args?: Subset<T, Payroll$generatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payroll model
   */
  interface PayrollFieldRefs {
    readonly id: FieldRef<"Payroll", 'String'>
    readonly userId: FieldRef<"Payroll", 'String'>
    readonly month: FieldRef<"Payroll", 'Int'>
    readonly year: FieldRef<"Payroll", 'Int'>
    readonly baseSalary: FieldRef<"Payroll", 'Decimal'>
    readonly allowances: FieldRef<"Payroll", 'Decimal'>
    readonly deductions: FieldRef<"Payroll", 'Decimal'>
    readonly netPay: FieldRef<"Payroll", 'Decimal'>
    readonly currency: FieldRef<"Payroll", 'String'>
    readonly status: FieldRef<"Payroll", 'PayrollStatus'>
    readonly generatedById: FieldRef<"Payroll", 'String'>
    readonly generatedAt: FieldRef<"Payroll", 'DateTime'>
    readonly paidAt: FieldRef<"Payroll", 'DateTime'>
    readonly slipUrl: FieldRef<"Payroll", 'String'>
    readonly createdAt: FieldRef<"Payroll", 'DateTime'>
    readonly updatedAt: FieldRef<"Payroll", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payroll findUnique
   */
  export type PayrollFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payroll to fetch.
     */
    where: PayrollWhereUniqueInput
  }

  /**
   * Payroll findUniqueOrThrow
   */
  export type PayrollFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payroll to fetch.
     */
    where: PayrollWhereUniqueInput
  }

  /**
   * Payroll findFirst
   */
  export type PayrollFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payroll to fetch.
     */
    where?: PayrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payrolls to fetch.
     */
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payrolls.
     */
    cursor?: PayrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payrolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payrolls.
     */
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * Payroll findFirstOrThrow
   */
  export type PayrollFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payroll to fetch.
     */
    where?: PayrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payrolls to fetch.
     */
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payrolls.
     */
    cursor?: PayrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payrolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payrolls.
     */
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * Payroll findMany
   */
  export type PayrollFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payrolls to fetch.
     */
    where?: PayrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payrolls to fetch.
     */
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payrolls.
     */
    cursor?: PayrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payrolls.
     */
    skip?: number
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * Payroll create
   */
  export type PayrollCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * The data needed to create a Payroll.
     */
    data: XOR<PayrollCreateInput, PayrollUncheckedCreateInput>
  }

  /**
   * Payroll createMany
   */
  export type PayrollCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payrolls.
     */
    data: PayrollCreateManyInput | PayrollCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payroll update
   */
  export type PayrollUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * The data needed to update a Payroll.
     */
    data: XOR<PayrollUpdateInput, PayrollUncheckedUpdateInput>
    /**
     * Choose, which Payroll to update.
     */
    where: PayrollWhereUniqueInput
  }

  /**
   * Payroll updateMany
   */
  export type PayrollUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payrolls.
     */
    data: XOR<PayrollUpdateManyMutationInput, PayrollUncheckedUpdateManyInput>
    /**
     * Filter which Payrolls to update
     */
    where?: PayrollWhereInput
    /**
     * Limit how many Payrolls to update.
     */
    limit?: number
  }

  /**
   * Payroll upsert
   */
  export type PayrollUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * The filter to search for the Payroll to update in case it exists.
     */
    where: PayrollWhereUniqueInput
    /**
     * In case the Payroll found by the `where` argument doesn't exist, create a new Payroll with this data.
     */
    create: XOR<PayrollCreateInput, PayrollUncheckedCreateInput>
    /**
     * In case the Payroll was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PayrollUpdateInput, PayrollUncheckedUpdateInput>
  }

  /**
   * Payroll delete
   */
  export type PayrollDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter which Payroll to delete.
     */
    where: PayrollWhereUniqueInput
  }

  /**
   * Payroll deleteMany
   */
  export type PayrollDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payrolls to delete
     */
    where?: PayrollWhereInput
    /**
     * Limit how many Payrolls to delete.
     */
    limit?: number
  }

  /**
   * Payroll.generatedBy
   */
  export type Payroll$generatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Payroll without action
   */
  export type PayrollDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
  }


  /**
   * Model PerformanceReview
   */

  export type AggregatePerformanceReview = {
    _count: PerformanceReviewCountAggregateOutputType | null
    _avg: PerformanceReviewAvgAggregateOutputType | null
    _sum: PerformanceReviewSumAggregateOutputType | null
    _min: PerformanceReviewMinAggregateOutputType | null
    _max: PerformanceReviewMaxAggregateOutputType | null
  }

  export type PerformanceReviewAvgAggregateOutputType = {
    overallScore: number | null
  }

  export type PerformanceReviewSumAggregateOutputType = {
    overallScore: number | null
  }

  export type PerformanceReviewMinAggregateOutputType = {
    id: string | null
    revieweeId: string | null
    reviewerId: string | null
    periodStart: Date | null
    periodEnd: Date | null
    overallScore: number | null
    feedback: string | null
    createdAt: Date | null
  }

  export type PerformanceReviewMaxAggregateOutputType = {
    id: string | null
    revieweeId: string | null
    reviewerId: string | null
    periodStart: Date | null
    periodEnd: Date | null
    overallScore: number | null
    feedback: string | null
    createdAt: Date | null
  }

  export type PerformanceReviewCountAggregateOutputType = {
    id: number
    revieweeId: number
    reviewerId: number
    periodStart: number
    periodEnd: number
    overallScore: number
    kpiScores: number
    feedback: number
    createdAt: number
    _all: number
  }


  export type PerformanceReviewAvgAggregateInputType = {
    overallScore?: true
  }

  export type PerformanceReviewSumAggregateInputType = {
    overallScore?: true
  }

  export type PerformanceReviewMinAggregateInputType = {
    id?: true
    revieweeId?: true
    reviewerId?: true
    periodStart?: true
    periodEnd?: true
    overallScore?: true
    feedback?: true
    createdAt?: true
  }

  export type PerformanceReviewMaxAggregateInputType = {
    id?: true
    revieweeId?: true
    reviewerId?: true
    periodStart?: true
    periodEnd?: true
    overallScore?: true
    feedback?: true
    createdAt?: true
  }

  export type PerformanceReviewCountAggregateInputType = {
    id?: true
    revieweeId?: true
    reviewerId?: true
    periodStart?: true
    periodEnd?: true
    overallScore?: true
    kpiScores?: true
    feedback?: true
    createdAt?: true
    _all?: true
  }

  export type PerformanceReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceReview to aggregate.
     */
    where?: PerformanceReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceReviews to fetch.
     */
    orderBy?: PerformanceReviewOrderByWithRelationInput | PerformanceReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PerformanceReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PerformanceReviews
    **/
    _count?: true | PerformanceReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PerformanceReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PerformanceReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PerformanceReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PerformanceReviewMaxAggregateInputType
  }

  export type GetPerformanceReviewAggregateType<T extends PerformanceReviewAggregateArgs> = {
        [P in keyof T & keyof AggregatePerformanceReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerformanceReview[P]>
      : GetScalarType<T[P], AggregatePerformanceReview[P]>
  }




  export type PerformanceReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceReviewWhereInput
    orderBy?: PerformanceReviewOrderByWithAggregationInput | PerformanceReviewOrderByWithAggregationInput[]
    by: PerformanceReviewScalarFieldEnum[] | PerformanceReviewScalarFieldEnum
    having?: PerformanceReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PerformanceReviewCountAggregateInputType | true
    _avg?: PerformanceReviewAvgAggregateInputType
    _sum?: PerformanceReviewSumAggregateInputType
    _min?: PerformanceReviewMinAggregateInputType
    _max?: PerformanceReviewMaxAggregateInputType
  }

  export type PerformanceReviewGroupByOutputType = {
    id: string
    revieweeId: string
    reviewerId: string
    periodStart: Date
    periodEnd: Date
    overallScore: number
    kpiScores: JsonValue | null
    feedback: string | null
    createdAt: Date
    _count: PerformanceReviewCountAggregateOutputType | null
    _avg: PerformanceReviewAvgAggregateOutputType | null
    _sum: PerformanceReviewSumAggregateOutputType | null
    _min: PerformanceReviewMinAggregateOutputType | null
    _max: PerformanceReviewMaxAggregateOutputType | null
  }

  type GetPerformanceReviewGroupByPayload<T extends PerformanceReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PerformanceReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PerformanceReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PerformanceReviewGroupByOutputType[P]>
            : GetScalarType<T[P], PerformanceReviewGroupByOutputType[P]>
        }
      >
    >


  export type PerformanceReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    revieweeId?: boolean
    reviewerId?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    overallScore?: boolean
    kpiScores?: boolean
    feedback?: boolean
    createdAt?: boolean
    reviewee?: boolean | UserDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performanceReview"]>



  export type PerformanceReviewSelectScalar = {
    id?: boolean
    revieweeId?: boolean
    reviewerId?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    overallScore?: boolean
    kpiScores?: boolean
    feedback?: boolean
    createdAt?: boolean
  }

  export type PerformanceReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "revieweeId" | "reviewerId" | "periodStart" | "periodEnd" | "overallScore" | "kpiScores" | "feedback" | "createdAt", ExtArgs["result"]["performanceReview"]>
  export type PerformanceReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviewee?: boolean | UserDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PerformanceReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PerformanceReview"
    objects: {
      reviewee: Prisma.$UserPayload<ExtArgs>
      reviewer: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      revieweeId: string
      reviewerId: string
      periodStart: Date
      periodEnd: Date
      overallScore: number
      kpiScores: Prisma.JsonValue | null
      feedback: string | null
      createdAt: Date
    }, ExtArgs["result"]["performanceReview"]>
    composites: {}
  }

  type PerformanceReviewGetPayload<S extends boolean | null | undefined | PerformanceReviewDefaultArgs> = $Result.GetResult<Prisma.$PerformanceReviewPayload, S>

  type PerformanceReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PerformanceReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PerformanceReviewCountAggregateInputType | true
    }

  export interface PerformanceReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PerformanceReview'], meta: { name: 'PerformanceReview' } }
    /**
     * Find zero or one PerformanceReview that matches the filter.
     * @param {PerformanceReviewFindUniqueArgs} args - Arguments to find a PerformanceReview
     * @example
     * // Get one PerformanceReview
     * const performanceReview = await prisma.performanceReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PerformanceReviewFindUniqueArgs>(args: SelectSubset<T, PerformanceReviewFindUniqueArgs<ExtArgs>>): Prisma__PerformanceReviewClient<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PerformanceReview that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PerformanceReviewFindUniqueOrThrowArgs} args - Arguments to find a PerformanceReview
     * @example
     * // Get one PerformanceReview
     * const performanceReview = await prisma.performanceReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PerformanceReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, PerformanceReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PerformanceReviewClient<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PerformanceReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceReviewFindFirstArgs} args - Arguments to find a PerformanceReview
     * @example
     * // Get one PerformanceReview
     * const performanceReview = await prisma.performanceReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PerformanceReviewFindFirstArgs>(args?: SelectSubset<T, PerformanceReviewFindFirstArgs<ExtArgs>>): Prisma__PerformanceReviewClient<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PerformanceReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceReviewFindFirstOrThrowArgs} args - Arguments to find a PerformanceReview
     * @example
     * // Get one PerformanceReview
     * const performanceReview = await prisma.performanceReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PerformanceReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, PerformanceReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__PerformanceReviewClient<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PerformanceReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PerformanceReviews
     * const performanceReviews = await prisma.performanceReview.findMany()
     * 
     * // Get first 10 PerformanceReviews
     * const performanceReviews = await prisma.performanceReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const performanceReviewWithIdOnly = await prisma.performanceReview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PerformanceReviewFindManyArgs>(args?: SelectSubset<T, PerformanceReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PerformanceReview.
     * @param {PerformanceReviewCreateArgs} args - Arguments to create a PerformanceReview.
     * @example
     * // Create one PerformanceReview
     * const PerformanceReview = await prisma.performanceReview.create({
     *   data: {
     *     // ... data to create a PerformanceReview
     *   }
     * })
     * 
     */
    create<T extends PerformanceReviewCreateArgs>(args: SelectSubset<T, PerformanceReviewCreateArgs<ExtArgs>>): Prisma__PerformanceReviewClient<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PerformanceReviews.
     * @param {PerformanceReviewCreateManyArgs} args - Arguments to create many PerformanceReviews.
     * @example
     * // Create many PerformanceReviews
     * const performanceReview = await prisma.performanceReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PerformanceReviewCreateManyArgs>(args?: SelectSubset<T, PerformanceReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PerformanceReview.
     * @param {PerformanceReviewDeleteArgs} args - Arguments to delete one PerformanceReview.
     * @example
     * // Delete one PerformanceReview
     * const PerformanceReview = await prisma.performanceReview.delete({
     *   where: {
     *     // ... filter to delete one PerformanceReview
     *   }
     * })
     * 
     */
    delete<T extends PerformanceReviewDeleteArgs>(args: SelectSubset<T, PerformanceReviewDeleteArgs<ExtArgs>>): Prisma__PerformanceReviewClient<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PerformanceReview.
     * @param {PerformanceReviewUpdateArgs} args - Arguments to update one PerformanceReview.
     * @example
     * // Update one PerformanceReview
     * const performanceReview = await prisma.performanceReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PerformanceReviewUpdateArgs>(args: SelectSubset<T, PerformanceReviewUpdateArgs<ExtArgs>>): Prisma__PerformanceReviewClient<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PerformanceReviews.
     * @param {PerformanceReviewDeleteManyArgs} args - Arguments to filter PerformanceReviews to delete.
     * @example
     * // Delete a few PerformanceReviews
     * const { count } = await prisma.performanceReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PerformanceReviewDeleteManyArgs>(args?: SelectSubset<T, PerformanceReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerformanceReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PerformanceReviews
     * const performanceReview = await prisma.performanceReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PerformanceReviewUpdateManyArgs>(args: SelectSubset<T, PerformanceReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PerformanceReview.
     * @param {PerformanceReviewUpsertArgs} args - Arguments to update or create a PerformanceReview.
     * @example
     * // Update or create a PerformanceReview
     * const performanceReview = await prisma.performanceReview.upsert({
     *   create: {
     *     // ... data to create a PerformanceReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PerformanceReview we want to update
     *   }
     * })
     */
    upsert<T extends PerformanceReviewUpsertArgs>(args: SelectSubset<T, PerformanceReviewUpsertArgs<ExtArgs>>): Prisma__PerformanceReviewClient<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PerformanceReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceReviewCountArgs} args - Arguments to filter PerformanceReviews to count.
     * @example
     * // Count the number of PerformanceReviews
     * const count = await prisma.performanceReview.count({
     *   where: {
     *     // ... the filter for the PerformanceReviews we want to count
     *   }
     * })
    **/
    count<T extends PerformanceReviewCountArgs>(
      args?: Subset<T, PerformanceReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PerformanceReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PerformanceReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PerformanceReviewAggregateArgs>(args: Subset<T, PerformanceReviewAggregateArgs>): Prisma.PrismaPromise<GetPerformanceReviewAggregateType<T>>

    /**
     * Group by PerformanceReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PerformanceReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PerformanceReviewGroupByArgs['orderBy'] }
        : { orderBy?: PerformanceReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PerformanceReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerformanceReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PerformanceReview model
   */
  readonly fields: PerformanceReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PerformanceReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PerformanceReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reviewee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reviewer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PerformanceReview model
   */
  interface PerformanceReviewFieldRefs {
    readonly id: FieldRef<"PerformanceReview", 'String'>
    readonly revieweeId: FieldRef<"PerformanceReview", 'String'>
    readonly reviewerId: FieldRef<"PerformanceReview", 'String'>
    readonly periodStart: FieldRef<"PerformanceReview", 'DateTime'>
    readonly periodEnd: FieldRef<"PerformanceReview", 'DateTime'>
    readonly overallScore: FieldRef<"PerformanceReview", 'Int'>
    readonly kpiScores: FieldRef<"PerformanceReview", 'Json'>
    readonly feedback: FieldRef<"PerformanceReview", 'String'>
    readonly createdAt: FieldRef<"PerformanceReview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PerformanceReview findUnique
   */
  export type PerformanceReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceReview to fetch.
     */
    where: PerformanceReviewWhereUniqueInput
  }

  /**
   * PerformanceReview findUniqueOrThrow
   */
  export type PerformanceReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceReview to fetch.
     */
    where: PerformanceReviewWhereUniqueInput
  }

  /**
   * PerformanceReview findFirst
   */
  export type PerformanceReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceReview to fetch.
     */
    where?: PerformanceReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceReviews to fetch.
     */
    orderBy?: PerformanceReviewOrderByWithRelationInput | PerformanceReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceReviews.
     */
    cursor?: PerformanceReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceReviews.
     */
    distinct?: PerformanceReviewScalarFieldEnum | PerformanceReviewScalarFieldEnum[]
  }

  /**
   * PerformanceReview findFirstOrThrow
   */
  export type PerformanceReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceReview to fetch.
     */
    where?: PerformanceReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceReviews to fetch.
     */
    orderBy?: PerformanceReviewOrderByWithRelationInput | PerformanceReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceReviews.
     */
    cursor?: PerformanceReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceReviews.
     */
    distinct?: PerformanceReviewScalarFieldEnum | PerformanceReviewScalarFieldEnum[]
  }

  /**
   * PerformanceReview findMany
   */
  export type PerformanceReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceReviews to fetch.
     */
    where?: PerformanceReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceReviews to fetch.
     */
    orderBy?: PerformanceReviewOrderByWithRelationInput | PerformanceReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PerformanceReviews.
     */
    cursor?: PerformanceReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceReviews.
     */
    skip?: number
    distinct?: PerformanceReviewScalarFieldEnum | PerformanceReviewScalarFieldEnum[]
  }

  /**
   * PerformanceReview create
   */
  export type PerformanceReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a PerformanceReview.
     */
    data: XOR<PerformanceReviewCreateInput, PerformanceReviewUncheckedCreateInput>
  }

  /**
   * PerformanceReview createMany
   */
  export type PerformanceReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PerformanceReviews.
     */
    data: PerformanceReviewCreateManyInput | PerformanceReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PerformanceReview update
   */
  export type PerformanceReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a PerformanceReview.
     */
    data: XOR<PerformanceReviewUpdateInput, PerformanceReviewUncheckedUpdateInput>
    /**
     * Choose, which PerformanceReview to update.
     */
    where: PerformanceReviewWhereUniqueInput
  }

  /**
   * PerformanceReview updateMany
   */
  export type PerformanceReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PerformanceReviews.
     */
    data: XOR<PerformanceReviewUpdateManyMutationInput, PerformanceReviewUncheckedUpdateManyInput>
    /**
     * Filter which PerformanceReviews to update
     */
    where?: PerformanceReviewWhereInput
    /**
     * Limit how many PerformanceReviews to update.
     */
    limit?: number
  }

  /**
   * PerformanceReview upsert
   */
  export type PerformanceReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the PerformanceReview to update in case it exists.
     */
    where: PerformanceReviewWhereUniqueInput
    /**
     * In case the PerformanceReview found by the `where` argument doesn't exist, create a new PerformanceReview with this data.
     */
    create: XOR<PerformanceReviewCreateInput, PerformanceReviewUncheckedCreateInput>
    /**
     * In case the PerformanceReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PerformanceReviewUpdateInput, PerformanceReviewUncheckedUpdateInput>
  }

  /**
   * PerformanceReview delete
   */
  export type PerformanceReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    /**
     * Filter which PerformanceReview to delete.
     */
    where: PerformanceReviewWhereUniqueInput
  }

  /**
   * PerformanceReview deleteMany
   */
  export type PerformanceReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceReviews to delete
     */
    where?: PerformanceReviewWhereInput
    /**
     * Limit how many PerformanceReviews to delete.
     */
    limit?: number
  }

  /**
   * PerformanceReview without action
   */
  export type PerformanceReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
  }


  /**
   * Model JobPost
   */

  export type AggregateJobPost = {
    _count: JobPostCountAggregateOutputType | null
    _min: JobPostMinAggregateOutputType | null
    _max: JobPostMaxAggregateOutputType | null
  }

  export type JobPostMinAggregateOutputType = {
    id: string | null
    title: string | null
    departmentId: string | null
    type: $Enums.JobType | null
    location: string | null
    description: string | null
    postedById: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobPostMaxAggregateOutputType = {
    id: string | null
    title: string | null
    departmentId: string | null
    type: $Enums.JobType | null
    location: string | null
    description: string | null
    postedById: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobPostCountAggregateOutputType = {
    id: number
    title: number
    departmentId: number
    type: number
    location: number
    description: number
    postedById: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type JobPostMinAggregateInputType = {
    id?: true
    title?: true
    departmentId?: true
    type?: true
    location?: true
    description?: true
    postedById?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobPostMaxAggregateInputType = {
    id?: true
    title?: true
    departmentId?: true
    type?: true
    location?: true
    description?: true
    postedById?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobPostCountAggregateInputType = {
    id?: true
    title?: true
    departmentId?: true
    type?: true
    location?: true
    description?: true
    postedById?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type JobPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobPost to aggregate.
     */
    where?: JobPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPosts to fetch.
     */
    orderBy?: JobPostOrderByWithRelationInput | JobPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobPosts
    **/
    _count?: true | JobPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobPostMaxAggregateInputType
  }

  export type GetJobPostAggregateType<T extends JobPostAggregateArgs> = {
        [P in keyof T & keyof AggregateJobPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobPost[P]>
      : GetScalarType<T[P], AggregateJobPost[P]>
  }




  export type JobPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobPostWhereInput
    orderBy?: JobPostOrderByWithAggregationInput | JobPostOrderByWithAggregationInput[]
    by: JobPostScalarFieldEnum[] | JobPostScalarFieldEnum
    having?: JobPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobPostCountAggregateInputType | true
    _min?: JobPostMinAggregateInputType
    _max?: JobPostMaxAggregateInputType
  }

  export type JobPostGroupByOutputType = {
    id: string
    title: string
    departmentId: string | null
    type: $Enums.JobType
    location: string | null
    description: string | null
    postedById: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: JobPostCountAggregateOutputType | null
    _min: JobPostMinAggregateOutputType | null
    _max: JobPostMaxAggregateOutputType | null
  }

  type GetJobPostGroupByPayload<T extends JobPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobPostGroupByOutputType[P]>
            : GetScalarType<T[P], JobPostGroupByOutputType[P]>
        }
      >
    >


  export type JobPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    departmentId?: boolean
    type?: boolean
    location?: boolean
    description?: boolean
    postedById?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | JobPost$departmentArgs<ExtArgs>
    postedBy?: boolean | UserDefaultArgs<ExtArgs>
    applications?: boolean | JobPost$applicationsArgs<ExtArgs>
    _count?: boolean | JobPostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobPost"]>



  export type JobPostSelectScalar = {
    id?: boolean
    title?: boolean
    departmentId?: boolean
    type?: boolean
    location?: boolean
    description?: boolean
    postedById?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type JobPostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "departmentId" | "type" | "location" | "description" | "postedById" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["jobPost"]>
  export type JobPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | JobPost$departmentArgs<ExtArgs>
    postedBy?: boolean | UserDefaultArgs<ExtArgs>
    applications?: boolean | JobPost$applicationsArgs<ExtArgs>
    _count?: boolean | JobPostCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $JobPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobPost"
    objects: {
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      postedBy: Prisma.$UserPayload<ExtArgs>
      applications: Prisma.$ApplicationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      departmentId: string | null
      type: $Enums.JobType
      location: string | null
      description: string | null
      postedById: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["jobPost"]>
    composites: {}
  }

  type JobPostGetPayload<S extends boolean | null | undefined | JobPostDefaultArgs> = $Result.GetResult<Prisma.$JobPostPayload, S>

  type JobPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobPostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobPostCountAggregateInputType | true
    }

  export interface JobPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobPost'], meta: { name: 'JobPost' } }
    /**
     * Find zero or one JobPost that matches the filter.
     * @param {JobPostFindUniqueArgs} args - Arguments to find a JobPost
     * @example
     * // Get one JobPost
     * const jobPost = await prisma.jobPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobPostFindUniqueArgs>(args: SelectSubset<T, JobPostFindUniqueArgs<ExtArgs>>): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JobPost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobPostFindUniqueOrThrowArgs} args - Arguments to find a JobPost
     * @example
     * // Get one JobPost
     * const jobPost = await prisma.jobPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobPostFindUniqueOrThrowArgs>(args: SelectSubset<T, JobPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostFindFirstArgs} args - Arguments to find a JobPost
     * @example
     * // Get one JobPost
     * const jobPost = await prisma.jobPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobPostFindFirstArgs>(args?: SelectSubset<T, JobPostFindFirstArgs<ExtArgs>>): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostFindFirstOrThrowArgs} args - Arguments to find a JobPost
     * @example
     * // Get one JobPost
     * const jobPost = await prisma.jobPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobPostFindFirstOrThrowArgs>(args?: SelectSubset<T, JobPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JobPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobPosts
     * const jobPosts = await prisma.jobPost.findMany()
     * 
     * // Get first 10 JobPosts
     * const jobPosts = await prisma.jobPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobPostWithIdOnly = await prisma.jobPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobPostFindManyArgs>(args?: SelectSubset<T, JobPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JobPost.
     * @param {JobPostCreateArgs} args - Arguments to create a JobPost.
     * @example
     * // Create one JobPost
     * const JobPost = await prisma.jobPost.create({
     *   data: {
     *     // ... data to create a JobPost
     *   }
     * })
     * 
     */
    create<T extends JobPostCreateArgs>(args: SelectSubset<T, JobPostCreateArgs<ExtArgs>>): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JobPosts.
     * @param {JobPostCreateManyArgs} args - Arguments to create many JobPosts.
     * @example
     * // Create many JobPosts
     * const jobPost = await prisma.jobPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobPostCreateManyArgs>(args?: SelectSubset<T, JobPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a JobPost.
     * @param {JobPostDeleteArgs} args - Arguments to delete one JobPost.
     * @example
     * // Delete one JobPost
     * const JobPost = await prisma.jobPost.delete({
     *   where: {
     *     // ... filter to delete one JobPost
     *   }
     * })
     * 
     */
    delete<T extends JobPostDeleteArgs>(args: SelectSubset<T, JobPostDeleteArgs<ExtArgs>>): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JobPost.
     * @param {JobPostUpdateArgs} args - Arguments to update one JobPost.
     * @example
     * // Update one JobPost
     * const jobPost = await prisma.jobPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobPostUpdateArgs>(args: SelectSubset<T, JobPostUpdateArgs<ExtArgs>>): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JobPosts.
     * @param {JobPostDeleteManyArgs} args - Arguments to filter JobPosts to delete.
     * @example
     * // Delete a few JobPosts
     * const { count } = await prisma.jobPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobPostDeleteManyArgs>(args?: SelectSubset<T, JobPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobPosts
     * const jobPost = await prisma.jobPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobPostUpdateManyArgs>(args: SelectSubset<T, JobPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JobPost.
     * @param {JobPostUpsertArgs} args - Arguments to update or create a JobPost.
     * @example
     * // Update or create a JobPost
     * const jobPost = await prisma.jobPost.upsert({
     *   create: {
     *     // ... data to create a JobPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobPost we want to update
     *   }
     * })
     */
    upsert<T extends JobPostUpsertArgs>(args: SelectSubset<T, JobPostUpsertArgs<ExtArgs>>): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JobPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostCountArgs} args - Arguments to filter JobPosts to count.
     * @example
     * // Count the number of JobPosts
     * const count = await prisma.jobPost.count({
     *   where: {
     *     // ... the filter for the JobPosts we want to count
     *   }
     * })
    **/
    count<T extends JobPostCountArgs>(
      args?: Subset<T, JobPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobPostAggregateArgs>(args: Subset<T, JobPostAggregateArgs>): Prisma.PrismaPromise<GetJobPostAggregateType<T>>

    /**
     * Group by JobPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobPostGroupByArgs['orderBy'] }
        : { orderBy?: JobPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobPost model
   */
  readonly fields: JobPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends JobPost$departmentArgs<ExtArgs> = {}>(args?: Subset<T, JobPost$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    postedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    applications<T extends JobPost$applicationsArgs<ExtArgs> = {}>(args?: Subset<T, JobPost$applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobPost model
   */
  interface JobPostFieldRefs {
    readonly id: FieldRef<"JobPost", 'String'>
    readonly title: FieldRef<"JobPost", 'String'>
    readonly departmentId: FieldRef<"JobPost", 'String'>
    readonly type: FieldRef<"JobPost", 'JobType'>
    readonly location: FieldRef<"JobPost", 'String'>
    readonly description: FieldRef<"JobPost", 'String'>
    readonly postedById: FieldRef<"JobPost", 'String'>
    readonly isActive: FieldRef<"JobPost", 'Boolean'>
    readonly createdAt: FieldRef<"JobPost", 'DateTime'>
    readonly updatedAt: FieldRef<"JobPost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JobPost findUnique
   */
  export type JobPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPost
     */
    omit?: JobPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostInclude<ExtArgs> | null
    /**
     * Filter, which JobPost to fetch.
     */
    where: JobPostWhereUniqueInput
  }

  /**
   * JobPost findUniqueOrThrow
   */
  export type JobPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPost
     */
    omit?: JobPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostInclude<ExtArgs> | null
    /**
     * Filter, which JobPost to fetch.
     */
    where: JobPostWhereUniqueInput
  }

  /**
   * JobPost findFirst
   */
  export type JobPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPost
     */
    omit?: JobPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostInclude<ExtArgs> | null
    /**
     * Filter, which JobPost to fetch.
     */
    where?: JobPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPosts to fetch.
     */
    orderBy?: JobPostOrderByWithRelationInput | JobPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobPosts.
     */
    cursor?: JobPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobPosts.
     */
    distinct?: JobPostScalarFieldEnum | JobPostScalarFieldEnum[]
  }

  /**
   * JobPost findFirstOrThrow
   */
  export type JobPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPost
     */
    omit?: JobPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostInclude<ExtArgs> | null
    /**
     * Filter, which JobPost to fetch.
     */
    where?: JobPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPosts to fetch.
     */
    orderBy?: JobPostOrderByWithRelationInput | JobPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobPosts.
     */
    cursor?: JobPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobPosts.
     */
    distinct?: JobPostScalarFieldEnum | JobPostScalarFieldEnum[]
  }

  /**
   * JobPost findMany
   */
  export type JobPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPost
     */
    omit?: JobPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostInclude<ExtArgs> | null
    /**
     * Filter, which JobPosts to fetch.
     */
    where?: JobPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPosts to fetch.
     */
    orderBy?: JobPostOrderByWithRelationInput | JobPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobPosts.
     */
    cursor?: JobPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPosts.
     */
    skip?: number
    distinct?: JobPostScalarFieldEnum | JobPostScalarFieldEnum[]
  }

  /**
   * JobPost create
   */
  export type JobPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPost
     */
    omit?: JobPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostInclude<ExtArgs> | null
    /**
     * The data needed to create a JobPost.
     */
    data: XOR<JobPostCreateInput, JobPostUncheckedCreateInput>
  }

  /**
   * JobPost createMany
   */
  export type JobPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobPosts.
     */
    data: JobPostCreateManyInput | JobPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobPost update
   */
  export type JobPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPost
     */
    omit?: JobPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostInclude<ExtArgs> | null
    /**
     * The data needed to update a JobPost.
     */
    data: XOR<JobPostUpdateInput, JobPostUncheckedUpdateInput>
    /**
     * Choose, which JobPost to update.
     */
    where: JobPostWhereUniqueInput
  }

  /**
   * JobPost updateMany
   */
  export type JobPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobPosts.
     */
    data: XOR<JobPostUpdateManyMutationInput, JobPostUncheckedUpdateManyInput>
    /**
     * Filter which JobPosts to update
     */
    where?: JobPostWhereInput
    /**
     * Limit how many JobPosts to update.
     */
    limit?: number
  }

  /**
   * JobPost upsert
   */
  export type JobPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPost
     */
    omit?: JobPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostInclude<ExtArgs> | null
    /**
     * The filter to search for the JobPost to update in case it exists.
     */
    where: JobPostWhereUniqueInput
    /**
     * In case the JobPost found by the `where` argument doesn't exist, create a new JobPost with this data.
     */
    create: XOR<JobPostCreateInput, JobPostUncheckedCreateInput>
    /**
     * In case the JobPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobPostUpdateInput, JobPostUncheckedUpdateInput>
  }

  /**
   * JobPost delete
   */
  export type JobPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPost
     */
    omit?: JobPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostInclude<ExtArgs> | null
    /**
     * Filter which JobPost to delete.
     */
    where: JobPostWhereUniqueInput
  }

  /**
   * JobPost deleteMany
   */
  export type JobPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobPosts to delete
     */
    where?: JobPostWhereInput
    /**
     * Limit how many JobPosts to delete.
     */
    limit?: number
  }

  /**
   * JobPost.department
   */
  export type JobPost$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * JobPost.applications
   */
  export type JobPost$applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    where?: ApplicationWhereInput
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    cursor?: ApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * JobPost without action
   */
  export type JobPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPost
     */
    omit?: JobPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostInclude<ExtArgs> | null
  }


  /**
   * Model Application
   */

  export type AggregateApplication = {
    _count: ApplicationCountAggregateOutputType | null
    _min: ApplicationMinAggregateOutputType | null
    _max: ApplicationMaxAggregateOutputType | null
  }

  export type ApplicationMinAggregateOutputType = {
    id: string | null
    jobPostId: string | null
    applicantUserId: string | null
    applicantName: string | null
    applicantEmail: string | null
    resumeUrl: string | null
    coverLetter: string | null
    status: $Enums.ApplicationStatus | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApplicationMaxAggregateOutputType = {
    id: string | null
    jobPostId: string | null
    applicantUserId: string | null
    applicantName: string | null
    applicantEmail: string | null
    resumeUrl: string | null
    coverLetter: string | null
    status: $Enums.ApplicationStatus | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApplicationCountAggregateOutputType = {
    id: number
    jobPostId: number
    applicantUserId: number
    applicantName: number
    applicantEmail: number
    resumeUrl: number
    coverLetter: number
    status: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ApplicationMinAggregateInputType = {
    id?: true
    jobPostId?: true
    applicantUserId?: true
    applicantName?: true
    applicantEmail?: true
    resumeUrl?: true
    coverLetter?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApplicationMaxAggregateInputType = {
    id?: true
    jobPostId?: true
    applicantUserId?: true
    applicantName?: true
    applicantEmail?: true
    resumeUrl?: true
    coverLetter?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApplicationCountAggregateInputType = {
    id?: true
    jobPostId?: true
    applicantUserId?: true
    applicantName?: true
    applicantEmail?: true
    resumeUrl?: true
    coverLetter?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Application to aggregate.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Applications
    **/
    _count?: true | ApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApplicationMaxAggregateInputType
  }

  export type GetApplicationAggregateType<T extends ApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApplication[P]>
      : GetScalarType<T[P], AggregateApplication[P]>
  }




  export type ApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationWhereInput
    orderBy?: ApplicationOrderByWithAggregationInput | ApplicationOrderByWithAggregationInput[]
    by: ApplicationScalarFieldEnum[] | ApplicationScalarFieldEnum
    having?: ApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApplicationCountAggregateInputType | true
    _min?: ApplicationMinAggregateInputType
    _max?: ApplicationMaxAggregateInputType
  }

  export type ApplicationGroupByOutputType = {
    id: string
    jobPostId: string
    applicantUserId: string | null
    applicantName: string
    applicantEmail: string
    resumeUrl: string | null
    coverLetter: string | null
    status: $Enums.ApplicationStatus
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ApplicationCountAggregateOutputType | null
    _min: ApplicationMinAggregateOutputType | null
    _max: ApplicationMaxAggregateOutputType | null
  }

  type GetApplicationGroupByPayload<T extends ApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], ApplicationGroupByOutputType[P]>
        }
      >
    >


  export type ApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobPostId?: boolean
    applicantUserId?: boolean
    applicantName?: boolean
    applicantEmail?: boolean
    resumeUrl?: boolean
    coverLetter?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    jobPost?: boolean | JobPostDefaultArgs<ExtArgs>
    applicant?: boolean | Application$applicantArgs<ExtArgs>
  }, ExtArgs["result"]["application"]>



  export type ApplicationSelectScalar = {
    id?: boolean
    jobPostId?: boolean
    applicantUserId?: boolean
    applicantName?: boolean
    applicantEmail?: boolean
    resumeUrl?: boolean
    coverLetter?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ApplicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jobPostId" | "applicantUserId" | "applicantName" | "applicantEmail" | "resumeUrl" | "coverLetter" | "status" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["application"]>
  export type ApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobPost?: boolean | JobPostDefaultArgs<ExtArgs>
    applicant?: boolean | Application$applicantArgs<ExtArgs>
  }

  export type $ApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Application"
    objects: {
      jobPost: Prisma.$JobPostPayload<ExtArgs>
      applicant: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobPostId: string
      applicantUserId: string | null
      applicantName: string
      applicantEmail: string
      resumeUrl: string | null
      coverLetter: string | null
      status: $Enums.ApplicationStatus
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["application"]>
    composites: {}
  }

  type ApplicationGetPayload<S extends boolean | null | undefined | ApplicationDefaultArgs> = $Result.GetResult<Prisma.$ApplicationPayload, S>

  type ApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApplicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApplicationCountAggregateInputType | true
    }

  export interface ApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Application'], meta: { name: 'Application' } }
    /**
     * Find zero or one Application that matches the filter.
     * @param {ApplicationFindUniqueArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApplicationFindUniqueArgs>(args: SelectSubset<T, ApplicationFindUniqueArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Application that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApplicationFindUniqueOrThrowArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, ApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Application that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindFirstArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApplicationFindFirstArgs>(args?: SelectSubset<T, ApplicationFindFirstArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Application that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindFirstOrThrowArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, ApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Applications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Applications
     * const applications = await prisma.application.findMany()
     * 
     * // Get first 10 Applications
     * const applications = await prisma.application.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const applicationWithIdOnly = await prisma.application.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApplicationFindManyArgs>(args?: SelectSubset<T, ApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Application.
     * @param {ApplicationCreateArgs} args - Arguments to create a Application.
     * @example
     * // Create one Application
     * const Application = await prisma.application.create({
     *   data: {
     *     // ... data to create a Application
     *   }
     * })
     * 
     */
    create<T extends ApplicationCreateArgs>(args: SelectSubset<T, ApplicationCreateArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Applications.
     * @param {ApplicationCreateManyArgs} args - Arguments to create many Applications.
     * @example
     * // Create many Applications
     * const application = await prisma.application.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApplicationCreateManyArgs>(args?: SelectSubset<T, ApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Application.
     * @param {ApplicationDeleteArgs} args - Arguments to delete one Application.
     * @example
     * // Delete one Application
     * const Application = await prisma.application.delete({
     *   where: {
     *     // ... filter to delete one Application
     *   }
     * })
     * 
     */
    delete<T extends ApplicationDeleteArgs>(args: SelectSubset<T, ApplicationDeleteArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Application.
     * @param {ApplicationUpdateArgs} args - Arguments to update one Application.
     * @example
     * // Update one Application
     * const application = await prisma.application.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApplicationUpdateArgs>(args: SelectSubset<T, ApplicationUpdateArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Applications.
     * @param {ApplicationDeleteManyArgs} args - Arguments to filter Applications to delete.
     * @example
     * // Delete a few Applications
     * const { count } = await prisma.application.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApplicationDeleteManyArgs>(args?: SelectSubset<T, ApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Applications
     * const application = await prisma.application.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApplicationUpdateManyArgs>(args: SelectSubset<T, ApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Application.
     * @param {ApplicationUpsertArgs} args - Arguments to update or create a Application.
     * @example
     * // Update or create a Application
     * const application = await prisma.application.upsert({
     *   create: {
     *     // ... data to create a Application
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Application we want to update
     *   }
     * })
     */
    upsert<T extends ApplicationUpsertArgs>(args: SelectSubset<T, ApplicationUpsertArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationCountArgs} args - Arguments to filter Applications to count.
     * @example
     * // Count the number of Applications
     * const count = await prisma.application.count({
     *   where: {
     *     // ... the filter for the Applications we want to count
     *   }
     * })
    **/
    count<T extends ApplicationCountArgs>(
      args?: Subset<T, ApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Application.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApplicationAggregateArgs>(args: Subset<T, ApplicationAggregateArgs>): Prisma.PrismaPromise<GetApplicationAggregateType<T>>

    /**
     * Group by Application.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApplicationGroupByArgs['orderBy'] }
        : { orderBy?: ApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Application model
   */
  readonly fields: ApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Application.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    jobPost<T extends JobPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobPostDefaultArgs<ExtArgs>>): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    applicant<T extends Application$applicantArgs<ExtArgs> = {}>(args?: Subset<T, Application$applicantArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Application model
   */
  interface ApplicationFieldRefs {
    readonly id: FieldRef<"Application", 'String'>
    readonly jobPostId: FieldRef<"Application", 'String'>
    readonly applicantUserId: FieldRef<"Application", 'String'>
    readonly applicantName: FieldRef<"Application", 'String'>
    readonly applicantEmail: FieldRef<"Application", 'String'>
    readonly resumeUrl: FieldRef<"Application", 'String'>
    readonly coverLetter: FieldRef<"Application", 'String'>
    readonly status: FieldRef<"Application", 'ApplicationStatus'>
    readonly notes: FieldRef<"Application", 'String'>
    readonly createdAt: FieldRef<"Application", 'DateTime'>
    readonly updatedAt: FieldRef<"Application", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Application findUnique
   */
  export type ApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application findUniqueOrThrow
   */
  export type ApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application findFirst
   */
  export type ApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Applications.
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Applications.
     */
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Application findFirstOrThrow
   */
  export type ApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Applications.
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Applications.
     */
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Application findMany
   */
  export type ApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Applications to fetch.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Applications.
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Application create
   */
  export type ApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a Application.
     */
    data: XOR<ApplicationCreateInput, ApplicationUncheckedCreateInput>
  }

  /**
   * Application createMany
   */
  export type ApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Applications.
     */
    data: ApplicationCreateManyInput | ApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Application update
   */
  export type ApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a Application.
     */
    data: XOR<ApplicationUpdateInput, ApplicationUncheckedUpdateInput>
    /**
     * Choose, which Application to update.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application updateMany
   */
  export type ApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Applications.
     */
    data: XOR<ApplicationUpdateManyMutationInput, ApplicationUncheckedUpdateManyInput>
    /**
     * Filter which Applications to update
     */
    where?: ApplicationWhereInput
    /**
     * Limit how many Applications to update.
     */
    limit?: number
  }

  /**
   * Application upsert
   */
  export type ApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the Application to update in case it exists.
     */
    where: ApplicationWhereUniqueInput
    /**
     * In case the Application found by the `where` argument doesn't exist, create a new Application with this data.
     */
    create: XOR<ApplicationCreateInput, ApplicationUncheckedCreateInput>
    /**
     * In case the Application was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApplicationUpdateInput, ApplicationUncheckedUpdateInput>
  }

  /**
   * Application delete
   */
  export type ApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter which Application to delete.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application deleteMany
   */
  export type ApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Applications to delete
     */
    where?: ApplicationWhereInput
    /**
     * Limit how many Applications to delete.
     */
    limit?: number
  }

  /**
   * Application.applicant
   */
  export type Application$applicantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Application without action
   */
  export type ApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
  }


  /**
   * Model TrainingProgram
   */

  export type AggregateTrainingProgram = {
    _count: TrainingProgramCountAggregateOutputType | null
    _avg: TrainingProgramAvgAggregateOutputType | null
    _sum: TrainingProgramSumAggregateOutputType | null
    _min: TrainingProgramMinAggregateOutputType | null
    _max: TrainingProgramMaxAggregateOutputType | null
  }

  export type TrainingProgramAvgAggregateOutputType = {
    maxSeats: number | null
  }

  export type TrainingProgramSumAggregateOutputType = {
    maxSeats: number | null
  }

  export type TrainingProgramMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    trainer: string | null
    location: string | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.TrainingStatus | null
    mode: string | null
    maxSeats: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingProgramMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    trainer: string | null
    location: string | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.TrainingStatus | null
    mode: string | null
    maxSeats: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingProgramCountAggregateOutputType = {
    id: number
    title: number
    description: number
    trainer: number
    location: number
    startDate: number
    endDate: number
    status: number
    mode: number
    maxSeats: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrainingProgramAvgAggregateInputType = {
    maxSeats?: true
  }

  export type TrainingProgramSumAggregateInputType = {
    maxSeats?: true
  }

  export type TrainingProgramMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    trainer?: true
    location?: true
    startDate?: true
    endDate?: true
    status?: true
    mode?: true
    maxSeats?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingProgramMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    trainer?: true
    location?: true
    startDate?: true
    endDate?: true
    status?: true
    mode?: true
    maxSeats?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingProgramCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    trainer?: true
    location?: true
    startDate?: true
    endDate?: true
    status?: true
    mode?: true
    maxSeats?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrainingProgramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingProgram to aggregate.
     */
    where?: TrainingProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingPrograms to fetch.
     */
    orderBy?: TrainingProgramOrderByWithRelationInput | TrainingProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingPrograms
    **/
    _count?: true | TrainingProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrainingProgramAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrainingProgramSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingProgramMaxAggregateInputType
  }

  export type GetTrainingProgramAggregateType<T extends TrainingProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingProgram[P]>
      : GetScalarType<T[P], AggregateTrainingProgram[P]>
  }




  export type TrainingProgramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingProgramWhereInput
    orderBy?: TrainingProgramOrderByWithAggregationInput | TrainingProgramOrderByWithAggregationInput[]
    by: TrainingProgramScalarFieldEnum[] | TrainingProgramScalarFieldEnum
    having?: TrainingProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingProgramCountAggregateInputType | true
    _avg?: TrainingProgramAvgAggregateInputType
    _sum?: TrainingProgramSumAggregateInputType
    _min?: TrainingProgramMinAggregateInputType
    _max?: TrainingProgramMaxAggregateInputType
  }

  export type TrainingProgramGroupByOutputType = {
    id: string
    title: string
    description: string | null
    trainer: string | null
    location: string | null
    startDate: Date
    endDate: Date
    status: $Enums.TrainingStatus
    mode: string | null
    maxSeats: number | null
    createdAt: Date
    updatedAt: Date
    _count: TrainingProgramCountAggregateOutputType | null
    _avg: TrainingProgramAvgAggregateOutputType | null
    _sum: TrainingProgramSumAggregateOutputType | null
    _min: TrainingProgramMinAggregateOutputType | null
    _max: TrainingProgramMaxAggregateOutputType | null
  }

  type GetTrainingProgramGroupByPayload<T extends TrainingProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingProgramGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingProgramGroupByOutputType[P]>
        }
      >
    >


  export type TrainingProgramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    trainer?: boolean
    location?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    mode?: boolean
    maxSeats?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    enrollments?: boolean | TrainingProgram$enrollmentsArgs<ExtArgs>
    _count?: boolean | TrainingProgramCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingProgram"]>



  export type TrainingProgramSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    trainer?: boolean
    location?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    mode?: boolean
    maxSeats?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TrainingProgramOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "trainer" | "location" | "startDate" | "endDate" | "status" | "mode" | "maxSeats" | "createdAt" | "updatedAt", ExtArgs["result"]["trainingProgram"]>
  export type TrainingProgramInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollments?: boolean | TrainingProgram$enrollmentsArgs<ExtArgs>
    _count?: boolean | TrainingProgramCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TrainingProgramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingProgram"
    objects: {
      enrollments: Prisma.$TrainingEnrollmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      trainer: string | null
      location: string | null
      startDate: Date
      endDate: Date
      status: $Enums.TrainingStatus
      mode: string | null
      maxSeats: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trainingProgram"]>
    composites: {}
  }

  type TrainingProgramGetPayload<S extends boolean | null | undefined | TrainingProgramDefaultArgs> = $Result.GetResult<Prisma.$TrainingProgramPayload, S>

  type TrainingProgramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrainingProgramFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrainingProgramCountAggregateInputType | true
    }

  export interface TrainingProgramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingProgram'], meta: { name: 'TrainingProgram' } }
    /**
     * Find zero or one TrainingProgram that matches the filter.
     * @param {TrainingProgramFindUniqueArgs} args - Arguments to find a TrainingProgram
     * @example
     * // Get one TrainingProgram
     * const trainingProgram = await prisma.trainingProgram.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingProgramFindUniqueArgs>(args: SelectSubset<T, TrainingProgramFindUniqueArgs<ExtArgs>>): Prisma__TrainingProgramClient<$Result.GetResult<Prisma.$TrainingProgramPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrainingProgram that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrainingProgramFindUniqueOrThrowArgs} args - Arguments to find a TrainingProgram
     * @example
     * // Get one TrainingProgram
     * const trainingProgram = await prisma.trainingProgram.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingProgramFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingProgramFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingProgramClient<$Result.GetResult<Prisma.$TrainingProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingProgram that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingProgramFindFirstArgs} args - Arguments to find a TrainingProgram
     * @example
     * // Get one TrainingProgram
     * const trainingProgram = await prisma.trainingProgram.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingProgramFindFirstArgs>(args?: SelectSubset<T, TrainingProgramFindFirstArgs<ExtArgs>>): Prisma__TrainingProgramClient<$Result.GetResult<Prisma.$TrainingProgramPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingProgram that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingProgramFindFirstOrThrowArgs} args - Arguments to find a TrainingProgram
     * @example
     * // Get one TrainingProgram
     * const trainingProgram = await prisma.trainingProgram.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingProgramFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingProgramFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingProgramClient<$Result.GetResult<Prisma.$TrainingProgramPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrainingPrograms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingProgramFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingPrograms
     * const trainingPrograms = await prisma.trainingProgram.findMany()
     * 
     * // Get first 10 TrainingPrograms
     * const trainingPrograms = await prisma.trainingProgram.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingProgramWithIdOnly = await prisma.trainingProgram.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingProgramFindManyArgs>(args?: SelectSubset<T, TrainingProgramFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingProgramPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrainingProgram.
     * @param {TrainingProgramCreateArgs} args - Arguments to create a TrainingProgram.
     * @example
     * // Create one TrainingProgram
     * const TrainingProgram = await prisma.trainingProgram.create({
     *   data: {
     *     // ... data to create a TrainingProgram
     *   }
     * })
     * 
     */
    create<T extends TrainingProgramCreateArgs>(args: SelectSubset<T, TrainingProgramCreateArgs<ExtArgs>>): Prisma__TrainingProgramClient<$Result.GetResult<Prisma.$TrainingProgramPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrainingPrograms.
     * @param {TrainingProgramCreateManyArgs} args - Arguments to create many TrainingPrograms.
     * @example
     * // Create many TrainingPrograms
     * const trainingProgram = await prisma.trainingProgram.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingProgramCreateManyArgs>(args?: SelectSubset<T, TrainingProgramCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TrainingProgram.
     * @param {TrainingProgramDeleteArgs} args - Arguments to delete one TrainingProgram.
     * @example
     * // Delete one TrainingProgram
     * const TrainingProgram = await prisma.trainingProgram.delete({
     *   where: {
     *     // ... filter to delete one TrainingProgram
     *   }
     * })
     * 
     */
    delete<T extends TrainingProgramDeleteArgs>(args: SelectSubset<T, TrainingProgramDeleteArgs<ExtArgs>>): Prisma__TrainingProgramClient<$Result.GetResult<Prisma.$TrainingProgramPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrainingProgram.
     * @param {TrainingProgramUpdateArgs} args - Arguments to update one TrainingProgram.
     * @example
     * // Update one TrainingProgram
     * const trainingProgram = await prisma.trainingProgram.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingProgramUpdateArgs>(args: SelectSubset<T, TrainingProgramUpdateArgs<ExtArgs>>): Prisma__TrainingProgramClient<$Result.GetResult<Prisma.$TrainingProgramPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrainingPrograms.
     * @param {TrainingProgramDeleteManyArgs} args - Arguments to filter TrainingPrograms to delete.
     * @example
     * // Delete a few TrainingPrograms
     * const { count } = await prisma.trainingProgram.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingProgramDeleteManyArgs>(args?: SelectSubset<T, TrainingProgramDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingPrograms
     * const trainingProgram = await prisma.trainingProgram.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingProgramUpdateManyArgs>(args: SelectSubset<T, TrainingProgramUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrainingProgram.
     * @param {TrainingProgramUpsertArgs} args - Arguments to update or create a TrainingProgram.
     * @example
     * // Update or create a TrainingProgram
     * const trainingProgram = await prisma.trainingProgram.upsert({
     *   create: {
     *     // ... data to create a TrainingProgram
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingProgram we want to update
     *   }
     * })
     */
    upsert<T extends TrainingProgramUpsertArgs>(args: SelectSubset<T, TrainingProgramUpsertArgs<ExtArgs>>): Prisma__TrainingProgramClient<$Result.GetResult<Prisma.$TrainingProgramPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrainingPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingProgramCountArgs} args - Arguments to filter TrainingPrograms to count.
     * @example
     * // Count the number of TrainingPrograms
     * const count = await prisma.trainingProgram.count({
     *   where: {
     *     // ... the filter for the TrainingPrograms we want to count
     *   }
     * })
    **/
    count<T extends TrainingProgramCountArgs>(
      args?: Subset<T, TrainingProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingProgramAggregateArgs>(args: Subset<T, TrainingProgramAggregateArgs>): Prisma.PrismaPromise<GetTrainingProgramAggregateType<T>>

    /**
     * Group by TrainingProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingProgramGroupByArgs['orderBy'] }
        : { orderBy?: TrainingProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingProgram model
   */
  readonly fields: TrainingProgramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingProgram.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingProgramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    enrollments<T extends TrainingProgram$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, TrainingProgram$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingEnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingProgram model
   */
  interface TrainingProgramFieldRefs {
    readonly id: FieldRef<"TrainingProgram", 'String'>
    readonly title: FieldRef<"TrainingProgram", 'String'>
    readonly description: FieldRef<"TrainingProgram", 'String'>
    readonly trainer: FieldRef<"TrainingProgram", 'String'>
    readonly location: FieldRef<"TrainingProgram", 'String'>
    readonly startDate: FieldRef<"TrainingProgram", 'DateTime'>
    readonly endDate: FieldRef<"TrainingProgram", 'DateTime'>
    readonly status: FieldRef<"TrainingProgram", 'TrainingStatus'>
    readonly mode: FieldRef<"TrainingProgram", 'String'>
    readonly maxSeats: FieldRef<"TrainingProgram", 'Int'>
    readonly createdAt: FieldRef<"TrainingProgram", 'DateTime'>
    readonly updatedAt: FieldRef<"TrainingProgram", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingProgram findUnique
   */
  export type TrainingProgramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingProgram
     */
    select?: TrainingProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingProgram
     */
    omit?: TrainingProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingProgramInclude<ExtArgs> | null
    /**
     * Filter, which TrainingProgram to fetch.
     */
    where: TrainingProgramWhereUniqueInput
  }

  /**
   * TrainingProgram findUniqueOrThrow
   */
  export type TrainingProgramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingProgram
     */
    select?: TrainingProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingProgram
     */
    omit?: TrainingProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingProgramInclude<ExtArgs> | null
    /**
     * Filter, which TrainingProgram to fetch.
     */
    where: TrainingProgramWhereUniqueInput
  }

  /**
   * TrainingProgram findFirst
   */
  export type TrainingProgramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingProgram
     */
    select?: TrainingProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingProgram
     */
    omit?: TrainingProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingProgramInclude<ExtArgs> | null
    /**
     * Filter, which TrainingProgram to fetch.
     */
    where?: TrainingProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingPrograms to fetch.
     */
    orderBy?: TrainingProgramOrderByWithRelationInput | TrainingProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingPrograms.
     */
    cursor?: TrainingProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingPrograms.
     */
    distinct?: TrainingProgramScalarFieldEnum | TrainingProgramScalarFieldEnum[]
  }

  /**
   * TrainingProgram findFirstOrThrow
   */
  export type TrainingProgramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingProgram
     */
    select?: TrainingProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingProgram
     */
    omit?: TrainingProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingProgramInclude<ExtArgs> | null
    /**
     * Filter, which TrainingProgram to fetch.
     */
    where?: TrainingProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingPrograms to fetch.
     */
    orderBy?: TrainingProgramOrderByWithRelationInput | TrainingProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingPrograms.
     */
    cursor?: TrainingProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingPrograms.
     */
    distinct?: TrainingProgramScalarFieldEnum | TrainingProgramScalarFieldEnum[]
  }

  /**
   * TrainingProgram findMany
   */
  export type TrainingProgramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingProgram
     */
    select?: TrainingProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingProgram
     */
    omit?: TrainingProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingProgramInclude<ExtArgs> | null
    /**
     * Filter, which TrainingPrograms to fetch.
     */
    where?: TrainingProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingPrograms to fetch.
     */
    orderBy?: TrainingProgramOrderByWithRelationInput | TrainingProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingPrograms.
     */
    cursor?: TrainingProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingPrograms.
     */
    skip?: number
    distinct?: TrainingProgramScalarFieldEnum | TrainingProgramScalarFieldEnum[]
  }

  /**
   * TrainingProgram create
   */
  export type TrainingProgramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingProgram
     */
    select?: TrainingProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingProgram
     */
    omit?: TrainingProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingProgramInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingProgram.
     */
    data: XOR<TrainingProgramCreateInput, TrainingProgramUncheckedCreateInput>
  }

  /**
   * TrainingProgram createMany
   */
  export type TrainingProgramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingPrograms.
     */
    data: TrainingProgramCreateManyInput | TrainingProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingProgram update
   */
  export type TrainingProgramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingProgram
     */
    select?: TrainingProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingProgram
     */
    omit?: TrainingProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingProgramInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingProgram.
     */
    data: XOR<TrainingProgramUpdateInput, TrainingProgramUncheckedUpdateInput>
    /**
     * Choose, which TrainingProgram to update.
     */
    where: TrainingProgramWhereUniqueInput
  }

  /**
   * TrainingProgram updateMany
   */
  export type TrainingProgramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingPrograms.
     */
    data: XOR<TrainingProgramUpdateManyMutationInput, TrainingProgramUncheckedUpdateManyInput>
    /**
     * Filter which TrainingPrograms to update
     */
    where?: TrainingProgramWhereInput
    /**
     * Limit how many TrainingPrograms to update.
     */
    limit?: number
  }

  /**
   * TrainingProgram upsert
   */
  export type TrainingProgramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingProgram
     */
    select?: TrainingProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingProgram
     */
    omit?: TrainingProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingProgramInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingProgram to update in case it exists.
     */
    where: TrainingProgramWhereUniqueInput
    /**
     * In case the TrainingProgram found by the `where` argument doesn't exist, create a new TrainingProgram with this data.
     */
    create: XOR<TrainingProgramCreateInput, TrainingProgramUncheckedCreateInput>
    /**
     * In case the TrainingProgram was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingProgramUpdateInput, TrainingProgramUncheckedUpdateInput>
  }

  /**
   * TrainingProgram delete
   */
  export type TrainingProgramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingProgram
     */
    select?: TrainingProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingProgram
     */
    omit?: TrainingProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingProgramInclude<ExtArgs> | null
    /**
     * Filter which TrainingProgram to delete.
     */
    where: TrainingProgramWhereUniqueInput
  }

  /**
   * TrainingProgram deleteMany
   */
  export type TrainingProgramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingPrograms to delete
     */
    where?: TrainingProgramWhereInput
    /**
     * Limit how many TrainingPrograms to delete.
     */
    limit?: number
  }

  /**
   * TrainingProgram.enrollments
   */
  export type TrainingProgram$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingEnrollment
     */
    select?: TrainingEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingEnrollment
     */
    omit?: TrainingEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingEnrollmentInclude<ExtArgs> | null
    where?: TrainingEnrollmentWhereInput
    orderBy?: TrainingEnrollmentOrderByWithRelationInput | TrainingEnrollmentOrderByWithRelationInput[]
    cursor?: TrainingEnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingEnrollmentScalarFieldEnum | TrainingEnrollmentScalarFieldEnum[]
  }

  /**
   * TrainingProgram without action
   */
  export type TrainingProgramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingProgram
     */
    select?: TrainingProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingProgram
     */
    omit?: TrainingProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingProgramInclude<ExtArgs> | null
  }


  /**
   * Model TrainingEnrollment
   */

  export type AggregateTrainingEnrollment = {
    _count: TrainingEnrollmentCountAggregateOutputType | null
    _min: TrainingEnrollmentMinAggregateOutputType | null
    _max: TrainingEnrollmentMaxAggregateOutputType | null
  }

  export type TrainingEnrollmentMinAggregateOutputType = {
    id: string | null
    trainingId: string | null
    userId: string | null
    enrolledAt: Date | null
    completedAt: Date | null
    certificateUrl: string | null
  }

  export type TrainingEnrollmentMaxAggregateOutputType = {
    id: string | null
    trainingId: string | null
    userId: string | null
    enrolledAt: Date | null
    completedAt: Date | null
    certificateUrl: string | null
  }

  export type TrainingEnrollmentCountAggregateOutputType = {
    id: number
    trainingId: number
    userId: number
    enrolledAt: number
    completedAt: number
    certificateUrl: number
    _all: number
  }


  export type TrainingEnrollmentMinAggregateInputType = {
    id?: true
    trainingId?: true
    userId?: true
    enrolledAt?: true
    completedAt?: true
    certificateUrl?: true
  }

  export type TrainingEnrollmentMaxAggregateInputType = {
    id?: true
    trainingId?: true
    userId?: true
    enrolledAt?: true
    completedAt?: true
    certificateUrl?: true
  }

  export type TrainingEnrollmentCountAggregateInputType = {
    id?: true
    trainingId?: true
    userId?: true
    enrolledAt?: true
    completedAt?: true
    certificateUrl?: true
    _all?: true
  }

  export type TrainingEnrollmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingEnrollment to aggregate.
     */
    where?: TrainingEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingEnrollments to fetch.
     */
    orderBy?: TrainingEnrollmentOrderByWithRelationInput | TrainingEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingEnrollments
    **/
    _count?: true | TrainingEnrollmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingEnrollmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingEnrollmentMaxAggregateInputType
  }

  export type GetTrainingEnrollmentAggregateType<T extends TrainingEnrollmentAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingEnrollment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingEnrollment[P]>
      : GetScalarType<T[P], AggregateTrainingEnrollment[P]>
  }




  export type TrainingEnrollmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingEnrollmentWhereInput
    orderBy?: TrainingEnrollmentOrderByWithAggregationInput | TrainingEnrollmentOrderByWithAggregationInput[]
    by: TrainingEnrollmentScalarFieldEnum[] | TrainingEnrollmentScalarFieldEnum
    having?: TrainingEnrollmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingEnrollmentCountAggregateInputType | true
    _min?: TrainingEnrollmentMinAggregateInputType
    _max?: TrainingEnrollmentMaxAggregateInputType
  }

  export type TrainingEnrollmentGroupByOutputType = {
    id: string
    trainingId: string
    userId: string
    enrolledAt: Date
    completedAt: Date | null
    certificateUrl: string | null
    _count: TrainingEnrollmentCountAggregateOutputType | null
    _min: TrainingEnrollmentMinAggregateOutputType | null
    _max: TrainingEnrollmentMaxAggregateOutputType | null
  }

  type GetTrainingEnrollmentGroupByPayload<T extends TrainingEnrollmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingEnrollmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingEnrollmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingEnrollmentGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingEnrollmentGroupByOutputType[P]>
        }
      >
    >


  export type TrainingEnrollmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    userId?: boolean
    enrolledAt?: boolean
    completedAt?: boolean
    certificateUrl?: boolean
    training?: boolean | TrainingProgramDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingEnrollment"]>



  export type TrainingEnrollmentSelectScalar = {
    id?: boolean
    trainingId?: boolean
    userId?: boolean
    enrolledAt?: boolean
    completedAt?: boolean
    certificateUrl?: boolean
  }

  export type TrainingEnrollmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "trainingId" | "userId" | "enrolledAt" | "completedAt" | "certificateUrl", ExtArgs["result"]["trainingEnrollment"]>
  export type TrainingEnrollmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingProgramDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TrainingEnrollmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingEnrollment"
    objects: {
      training: Prisma.$TrainingProgramPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trainingId: string
      userId: string
      enrolledAt: Date
      completedAt: Date | null
      certificateUrl: string | null
    }, ExtArgs["result"]["trainingEnrollment"]>
    composites: {}
  }

  type TrainingEnrollmentGetPayload<S extends boolean | null | undefined | TrainingEnrollmentDefaultArgs> = $Result.GetResult<Prisma.$TrainingEnrollmentPayload, S>

  type TrainingEnrollmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrainingEnrollmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrainingEnrollmentCountAggregateInputType | true
    }

  export interface TrainingEnrollmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingEnrollment'], meta: { name: 'TrainingEnrollment' } }
    /**
     * Find zero or one TrainingEnrollment that matches the filter.
     * @param {TrainingEnrollmentFindUniqueArgs} args - Arguments to find a TrainingEnrollment
     * @example
     * // Get one TrainingEnrollment
     * const trainingEnrollment = await prisma.trainingEnrollment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingEnrollmentFindUniqueArgs>(args: SelectSubset<T, TrainingEnrollmentFindUniqueArgs<ExtArgs>>): Prisma__TrainingEnrollmentClient<$Result.GetResult<Prisma.$TrainingEnrollmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrainingEnrollment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrainingEnrollmentFindUniqueOrThrowArgs} args - Arguments to find a TrainingEnrollment
     * @example
     * // Get one TrainingEnrollment
     * const trainingEnrollment = await prisma.trainingEnrollment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingEnrollmentFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingEnrollmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingEnrollmentClient<$Result.GetResult<Prisma.$TrainingEnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingEnrollment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingEnrollmentFindFirstArgs} args - Arguments to find a TrainingEnrollment
     * @example
     * // Get one TrainingEnrollment
     * const trainingEnrollment = await prisma.trainingEnrollment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingEnrollmentFindFirstArgs>(args?: SelectSubset<T, TrainingEnrollmentFindFirstArgs<ExtArgs>>): Prisma__TrainingEnrollmentClient<$Result.GetResult<Prisma.$TrainingEnrollmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingEnrollment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingEnrollmentFindFirstOrThrowArgs} args - Arguments to find a TrainingEnrollment
     * @example
     * // Get one TrainingEnrollment
     * const trainingEnrollment = await prisma.trainingEnrollment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingEnrollmentFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingEnrollmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingEnrollmentClient<$Result.GetResult<Prisma.$TrainingEnrollmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrainingEnrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingEnrollmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingEnrollments
     * const trainingEnrollments = await prisma.trainingEnrollment.findMany()
     * 
     * // Get first 10 TrainingEnrollments
     * const trainingEnrollments = await prisma.trainingEnrollment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingEnrollmentWithIdOnly = await prisma.trainingEnrollment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingEnrollmentFindManyArgs>(args?: SelectSubset<T, TrainingEnrollmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingEnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrainingEnrollment.
     * @param {TrainingEnrollmentCreateArgs} args - Arguments to create a TrainingEnrollment.
     * @example
     * // Create one TrainingEnrollment
     * const TrainingEnrollment = await prisma.trainingEnrollment.create({
     *   data: {
     *     // ... data to create a TrainingEnrollment
     *   }
     * })
     * 
     */
    create<T extends TrainingEnrollmentCreateArgs>(args: SelectSubset<T, TrainingEnrollmentCreateArgs<ExtArgs>>): Prisma__TrainingEnrollmentClient<$Result.GetResult<Prisma.$TrainingEnrollmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrainingEnrollments.
     * @param {TrainingEnrollmentCreateManyArgs} args - Arguments to create many TrainingEnrollments.
     * @example
     * // Create many TrainingEnrollments
     * const trainingEnrollment = await prisma.trainingEnrollment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingEnrollmentCreateManyArgs>(args?: SelectSubset<T, TrainingEnrollmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TrainingEnrollment.
     * @param {TrainingEnrollmentDeleteArgs} args - Arguments to delete one TrainingEnrollment.
     * @example
     * // Delete one TrainingEnrollment
     * const TrainingEnrollment = await prisma.trainingEnrollment.delete({
     *   where: {
     *     // ... filter to delete one TrainingEnrollment
     *   }
     * })
     * 
     */
    delete<T extends TrainingEnrollmentDeleteArgs>(args: SelectSubset<T, TrainingEnrollmentDeleteArgs<ExtArgs>>): Prisma__TrainingEnrollmentClient<$Result.GetResult<Prisma.$TrainingEnrollmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrainingEnrollment.
     * @param {TrainingEnrollmentUpdateArgs} args - Arguments to update one TrainingEnrollment.
     * @example
     * // Update one TrainingEnrollment
     * const trainingEnrollment = await prisma.trainingEnrollment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingEnrollmentUpdateArgs>(args: SelectSubset<T, TrainingEnrollmentUpdateArgs<ExtArgs>>): Prisma__TrainingEnrollmentClient<$Result.GetResult<Prisma.$TrainingEnrollmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrainingEnrollments.
     * @param {TrainingEnrollmentDeleteManyArgs} args - Arguments to filter TrainingEnrollments to delete.
     * @example
     * // Delete a few TrainingEnrollments
     * const { count } = await prisma.trainingEnrollment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingEnrollmentDeleteManyArgs>(args?: SelectSubset<T, TrainingEnrollmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingEnrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingEnrollmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingEnrollments
     * const trainingEnrollment = await prisma.trainingEnrollment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingEnrollmentUpdateManyArgs>(args: SelectSubset<T, TrainingEnrollmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrainingEnrollment.
     * @param {TrainingEnrollmentUpsertArgs} args - Arguments to update or create a TrainingEnrollment.
     * @example
     * // Update or create a TrainingEnrollment
     * const trainingEnrollment = await prisma.trainingEnrollment.upsert({
     *   create: {
     *     // ... data to create a TrainingEnrollment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingEnrollment we want to update
     *   }
     * })
     */
    upsert<T extends TrainingEnrollmentUpsertArgs>(args: SelectSubset<T, TrainingEnrollmentUpsertArgs<ExtArgs>>): Prisma__TrainingEnrollmentClient<$Result.GetResult<Prisma.$TrainingEnrollmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrainingEnrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingEnrollmentCountArgs} args - Arguments to filter TrainingEnrollments to count.
     * @example
     * // Count the number of TrainingEnrollments
     * const count = await prisma.trainingEnrollment.count({
     *   where: {
     *     // ... the filter for the TrainingEnrollments we want to count
     *   }
     * })
    **/
    count<T extends TrainingEnrollmentCountArgs>(
      args?: Subset<T, TrainingEnrollmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingEnrollmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingEnrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingEnrollmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingEnrollmentAggregateArgs>(args: Subset<T, TrainingEnrollmentAggregateArgs>): Prisma.PrismaPromise<GetTrainingEnrollmentAggregateType<T>>

    /**
     * Group by TrainingEnrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingEnrollmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingEnrollmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingEnrollmentGroupByArgs['orderBy'] }
        : { orderBy?: TrainingEnrollmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingEnrollmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingEnrollmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingEnrollment model
   */
  readonly fields: TrainingEnrollmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingEnrollment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingEnrollmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    training<T extends TrainingProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingProgramDefaultArgs<ExtArgs>>): Prisma__TrainingProgramClient<$Result.GetResult<Prisma.$TrainingProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingEnrollment model
   */
  interface TrainingEnrollmentFieldRefs {
    readonly id: FieldRef<"TrainingEnrollment", 'String'>
    readonly trainingId: FieldRef<"TrainingEnrollment", 'String'>
    readonly userId: FieldRef<"TrainingEnrollment", 'String'>
    readonly enrolledAt: FieldRef<"TrainingEnrollment", 'DateTime'>
    readonly completedAt: FieldRef<"TrainingEnrollment", 'DateTime'>
    readonly certificateUrl: FieldRef<"TrainingEnrollment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TrainingEnrollment findUnique
   */
  export type TrainingEnrollmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingEnrollment
     */
    select?: TrainingEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingEnrollment
     */
    omit?: TrainingEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which TrainingEnrollment to fetch.
     */
    where: TrainingEnrollmentWhereUniqueInput
  }

  /**
   * TrainingEnrollment findUniqueOrThrow
   */
  export type TrainingEnrollmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingEnrollment
     */
    select?: TrainingEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingEnrollment
     */
    omit?: TrainingEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which TrainingEnrollment to fetch.
     */
    where: TrainingEnrollmentWhereUniqueInput
  }

  /**
   * TrainingEnrollment findFirst
   */
  export type TrainingEnrollmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingEnrollment
     */
    select?: TrainingEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingEnrollment
     */
    omit?: TrainingEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which TrainingEnrollment to fetch.
     */
    where?: TrainingEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingEnrollments to fetch.
     */
    orderBy?: TrainingEnrollmentOrderByWithRelationInput | TrainingEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingEnrollments.
     */
    cursor?: TrainingEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingEnrollments.
     */
    distinct?: TrainingEnrollmentScalarFieldEnum | TrainingEnrollmentScalarFieldEnum[]
  }

  /**
   * TrainingEnrollment findFirstOrThrow
   */
  export type TrainingEnrollmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingEnrollment
     */
    select?: TrainingEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingEnrollment
     */
    omit?: TrainingEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which TrainingEnrollment to fetch.
     */
    where?: TrainingEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingEnrollments to fetch.
     */
    orderBy?: TrainingEnrollmentOrderByWithRelationInput | TrainingEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingEnrollments.
     */
    cursor?: TrainingEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingEnrollments.
     */
    distinct?: TrainingEnrollmentScalarFieldEnum | TrainingEnrollmentScalarFieldEnum[]
  }

  /**
   * TrainingEnrollment findMany
   */
  export type TrainingEnrollmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingEnrollment
     */
    select?: TrainingEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingEnrollment
     */
    omit?: TrainingEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which TrainingEnrollments to fetch.
     */
    where?: TrainingEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingEnrollments to fetch.
     */
    orderBy?: TrainingEnrollmentOrderByWithRelationInput | TrainingEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingEnrollments.
     */
    cursor?: TrainingEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingEnrollments.
     */
    skip?: number
    distinct?: TrainingEnrollmentScalarFieldEnum | TrainingEnrollmentScalarFieldEnum[]
  }

  /**
   * TrainingEnrollment create
   */
  export type TrainingEnrollmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingEnrollment
     */
    select?: TrainingEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingEnrollment
     */
    omit?: TrainingEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingEnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingEnrollment.
     */
    data: XOR<TrainingEnrollmentCreateInput, TrainingEnrollmentUncheckedCreateInput>
  }

  /**
   * TrainingEnrollment createMany
   */
  export type TrainingEnrollmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingEnrollments.
     */
    data: TrainingEnrollmentCreateManyInput | TrainingEnrollmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingEnrollment update
   */
  export type TrainingEnrollmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingEnrollment
     */
    select?: TrainingEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingEnrollment
     */
    omit?: TrainingEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingEnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingEnrollment.
     */
    data: XOR<TrainingEnrollmentUpdateInput, TrainingEnrollmentUncheckedUpdateInput>
    /**
     * Choose, which TrainingEnrollment to update.
     */
    where: TrainingEnrollmentWhereUniqueInput
  }

  /**
   * TrainingEnrollment updateMany
   */
  export type TrainingEnrollmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingEnrollments.
     */
    data: XOR<TrainingEnrollmentUpdateManyMutationInput, TrainingEnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which TrainingEnrollments to update
     */
    where?: TrainingEnrollmentWhereInput
    /**
     * Limit how many TrainingEnrollments to update.
     */
    limit?: number
  }

  /**
   * TrainingEnrollment upsert
   */
  export type TrainingEnrollmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingEnrollment
     */
    select?: TrainingEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingEnrollment
     */
    omit?: TrainingEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingEnrollmentInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingEnrollment to update in case it exists.
     */
    where: TrainingEnrollmentWhereUniqueInput
    /**
     * In case the TrainingEnrollment found by the `where` argument doesn't exist, create a new TrainingEnrollment with this data.
     */
    create: XOR<TrainingEnrollmentCreateInput, TrainingEnrollmentUncheckedCreateInput>
    /**
     * In case the TrainingEnrollment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingEnrollmentUpdateInput, TrainingEnrollmentUncheckedUpdateInput>
  }

  /**
   * TrainingEnrollment delete
   */
  export type TrainingEnrollmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingEnrollment
     */
    select?: TrainingEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingEnrollment
     */
    omit?: TrainingEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingEnrollmentInclude<ExtArgs> | null
    /**
     * Filter which TrainingEnrollment to delete.
     */
    where: TrainingEnrollmentWhereUniqueInput
  }

  /**
   * TrainingEnrollment deleteMany
   */
  export type TrainingEnrollmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingEnrollments to delete
     */
    where?: TrainingEnrollmentWhereInput
    /**
     * Limit how many TrainingEnrollments to delete.
     */
    limit?: number
  }

  /**
   * TrainingEnrollment without action
   */
  export type TrainingEnrollmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingEnrollment
     */
    select?: TrainingEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingEnrollment
     */
    omit?: TrainingEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingEnrollmentInclude<ExtArgs> | null
  }


  /**
   * Model CalendarEvent
   */

  export type AggregateCalendarEvent = {
    _count: CalendarEventCountAggregateOutputType | null
    _min: CalendarEventMinAggregateOutputType | null
    _max: CalendarEventMaxAggregateOutputType | null
  }

  export type CalendarEventMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    organizerId: string | null
    startTime: Date | null
    endTime: Date | null
    source: $Enums.EventSource | null
    googleMeetLink: string | null
    location: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CalendarEventMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    organizerId: string | null
    startTime: Date | null
    endTime: Date | null
    source: $Enums.EventSource | null
    googleMeetLink: string | null
    location: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CalendarEventCountAggregateOutputType = {
    id: number
    title: number
    description: number
    organizerId: number
    startTime: number
    endTime: number
    source: number
    googleMeetLink: number
    location: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CalendarEventMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    organizerId?: true
    startTime?: true
    endTime?: true
    source?: true
    googleMeetLink?: true
    location?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CalendarEventMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    organizerId?: true
    startTime?: true
    endTime?: true
    source?: true
    googleMeetLink?: true
    location?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CalendarEventCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    organizerId?: true
    startTime?: true
    endTime?: true
    source?: true
    googleMeetLink?: true
    location?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CalendarEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarEvent to aggregate.
     */
    where?: CalendarEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEvents to fetch.
     */
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CalendarEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CalendarEvents
    **/
    _count?: true | CalendarEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalendarEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalendarEventMaxAggregateInputType
  }

  export type GetCalendarEventAggregateType<T extends CalendarEventAggregateArgs> = {
        [P in keyof T & keyof AggregateCalendarEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalendarEvent[P]>
      : GetScalarType<T[P], AggregateCalendarEvent[P]>
  }




  export type CalendarEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarEventWhereInput
    orderBy?: CalendarEventOrderByWithAggregationInput | CalendarEventOrderByWithAggregationInput[]
    by: CalendarEventScalarFieldEnum[] | CalendarEventScalarFieldEnum
    having?: CalendarEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalendarEventCountAggregateInputType | true
    _min?: CalendarEventMinAggregateInputType
    _max?: CalendarEventMaxAggregateInputType
  }

  export type CalendarEventGroupByOutputType = {
    id: string
    title: string
    description: string | null
    organizerId: string
    startTime: Date
    endTime: Date
    source: $Enums.EventSource
    googleMeetLink: string | null
    location: string | null
    createdAt: Date
    updatedAt: Date
    _count: CalendarEventCountAggregateOutputType | null
    _min: CalendarEventMinAggregateOutputType | null
    _max: CalendarEventMaxAggregateOutputType | null
  }

  type GetCalendarEventGroupByPayload<T extends CalendarEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CalendarEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalendarEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalendarEventGroupByOutputType[P]>
            : GetScalarType<T[P], CalendarEventGroupByOutputType[P]>
        }
      >
    >


  export type CalendarEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    organizerId?: boolean
    startTime?: boolean
    endTime?: boolean
    source?: boolean
    googleMeetLink?: boolean
    location?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organizer?: boolean | UserDefaultArgs<ExtArgs>
    attendees?: boolean | CalendarEvent$attendeesArgs<ExtArgs>
    _count?: boolean | CalendarEventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calendarEvent"]>



  export type CalendarEventSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    organizerId?: boolean
    startTime?: boolean
    endTime?: boolean
    source?: boolean
    googleMeetLink?: boolean
    location?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CalendarEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "organizerId" | "startTime" | "endTime" | "source" | "googleMeetLink" | "location" | "createdAt" | "updatedAt", ExtArgs["result"]["calendarEvent"]>
  export type CalendarEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizer?: boolean | UserDefaultArgs<ExtArgs>
    attendees?: boolean | CalendarEvent$attendeesArgs<ExtArgs>
    _count?: boolean | CalendarEventCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CalendarEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CalendarEvent"
    objects: {
      organizer: Prisma.$UserPayload<ExtArgs>
      attendees: Prisma.$CalendarAttendeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      organizerId: string
      startTime: Date
      endTime: Date
      source: $Enums.EventSource
      googleMeetLink: string | null
      location: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["calendarEvent"]>
    composites: {}
  }

  type CalendarEventGetPayload<S extends boolean | null | undefined | CalendarEventDefaultArgs> = $Result.GetResult<Prisma.$CalendarEventPayload, S>

  type CalendarEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CalendarEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CalendarEventCountAggregateInputType | true
    }

  export interface CalendarEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CalendarEvent'], meta: { name: 'CalendarEvent' } }
    /**
     * Find zero or one CalendarEvent that matches the filter.
     * @param {CalendarEventFindUniqueArgs} args - Arguments to find a CalendarEvent
     * @example
     * // Get one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CalendarEventFindUniqueArgs>(args: SelectSubset<T, CalendarEventFindUniqueArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CalendarEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CalendarEventFindUniqueOrThrowArgs} args - Arguments to find a CalendarEvent
     * @example
     * // Get one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CalendarEventFindUniqueOrThrowArgs>(args: SelectSubset<T, CalendarEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CalendarEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventFindFirstArgs} args - Arguments to find a CalendarEvent
     * @example
     * // Get one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CalendarEventFindFirstArgs>(args?: SelectSubset<T, CalendarEventFindFirstArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CalendarEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventFindFirstOrThrowArgs} args - Arguments to find a CalendarEvent
     * @example
     * // Get one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CalendarEventFindFirstOrThrowArgs>(args?: SelectSubset<T, CalendarEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CalendarEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CalendarEvents
     * const calendarEvents = await prisma.calendarEvent.findMany()
     * 
     * // Get first 10 CalendarEvents
     * const calendarEvents = await prisma.calendarEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calendarEventWithIdOnly = await prisma.calendarEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CalendarEventFindManyArgs>(args?: SelectSubset<T, CalendarEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CalendarEvent.
     * @param {CalendarEventCreateArgs} args - Arguments to create a CalendarEvent.
     * @example
     * // Create one CalendarEvent
     * const CalendarEvent = await prisma.calendarEvent.create({
     *   data: {
     *     // ... data to create a CalendarEvent
     *   }
     * })
     * 
     */
    create<T extends CalendarEventCreateArgs>(args: SelectSubset<T, CalendarEventCreateArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CalendarEvents.
     * @param {CalendarEventCreateManyArgs} args - Arguments to create many CalendarEvents.
     * @example
     * // Create many CalendarEvents
     * const calendarEvent = await prisma.calendarEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CalendarEventCreateManyArgs>(args?: SelectSubset<T, CalendarEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CalendarEvent.
     * @param {CalendarEventDeleteArgs} args - Arguments to delete one CalendarEvent.
     * @example
     * // Delete one CalendarEvent
     * const CalendarEvent = await prisma.calendarEvent.delete({
     *   where: {
     *     // ... filter to delete one CalendarEvent
     *   }
     * })
     * 
     */
    delete<T extends CalendarEventDeleteArgs>(args: SelectSubset<T, CalendarEventDeleteArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CalendarEvent.
     * @param {CalendarEventUpdateArgs} args - Arguments to update one CalendarEvent.
     * @example
     * // Update one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CalendarEventUpdateArgs>(args: SelectSubset<T, CalendarEventUpdateArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CalendarEvents.
     * @param {CalendarEventDeleteManyArgs} args - Arguments to filter CalendarEvents to delete.
     * @example
     * // Delete a few CalendarEvents
     * const { count } = await prisma.calendarEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CalendarEventDeleteManyArgs>(args?: SelectSubset<T, CalendarEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalendarEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CalendarEvents
     * const calendarEvent = await prisma.calendarEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CalendarEventUpdateManyArgs>(args: SelectSubset<T, CalendarEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CalendarEvent.
     * @param {CalendarEventUpsertArgs} args - Arguments to update or create a CalendarEvent.
     * @example
     * // Update or create a CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.upsert({
     *   create: {
     *     // ... data to create a CalendarEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CalendarEvent we want to update
     *   }
     * })
     */
    upsert<T extends CalendarEventUpsertArgs>(args: SelectSubset<T, CalendarEventUpsertArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CalendarEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventCountArgs} args - Arguments to filter CalendarEvents to count.
     * @example
     * // Count the number of CalendarEvents
     * const count = await prisma.calendarEvent.count({
     *   where: {
     *     // ... the filter for the CalendarEvents we want to count
     *   }
     * })
    **/
    count<T extends CalendarEventCountArgs>(
      args?: Subset<T, CalendarEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalendarEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CalendarEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalendarEventAggregateArgs>(args: Subset<T, CalendarEventAggregateArgs>): Prisma.PrismaPromise<GetCalendarEventAggregateType<T>>

    /**
     * Group by CalendarEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalendarEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalendarEventGroupByArgs['orderBy'] }
        : { orderBy?: CalendarEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalendarEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalendarEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CalendarEvent model
   */
  readonly fields: CalendarEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CalendarEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CalendarEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organizer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attendees<T extends CalendarEvent$attendeesArgs<ExtArgs> = {}>(args?: Subset<T, CalendarEvent$attendeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarAttendeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CalendarEvent model
   */
  interface CalendarEventFieldRefs {
    readonly id: FieldRef<"CalendarEvent", 'String'>
    readonly title: FieldRef<"CalendarEvent", 'String'>
    readonly description: FieldRef<"CalendarEvent", 'String'>
    readonly organizerId: FieldRef<"CalendarEvent", 'String'>
    readonly startTime: FieldRef<"CalendarEvent", 'DateTime'>
    readonly endTime: FieldRef<"CalendarEvent", 'DateTime'>
    readonly source: FieldRef<"CalendarEvent", 'EventSource'>
    readonly googleMeetLink: FieldRef<"CalendarEvent", 'String'>
    readonly location: FieldRef<"CalendarEvent", 'String'>
    readonly createdAt: FieldRef<"CalendarEvent", 'DateTime'>
    readonly updatedAt: FieldRef<"CalendarEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CalendarEvent findUnique
   */
  export type CalendarEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEvent to fetch.
     */
    where: CalendarEventWhereUniqueInput
  }

  /**
   * CalendarEvent findUniqueOrThrow
   */
  export type CalendarEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEvent to fetch.
     */
    where: CalendarEventWhereUniqueInput
  }

  /**
   * CalendarEvent findFirst
   */
  export type CalendarEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEvent to fetch.
     */
    where?: CalendarEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEvents to fetch.
     */
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarEvents.
     */
    cursor?: CalendarEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarEvents.
     */
    distinct?: CalendarEventScalarFieldEnum | CalendarEventScalarFieldEnum[]
  }

  /**
   * CalendarEvent findFirstOrThrow
   */
  export type CalendarEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEvent to fetch.
     */
    where?: CalendarEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEvents to fetch.
     */
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarEvents.
     */
    cursor?: CalendarEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarEvents.
     */
    distinct?: CalendarEventScalarFieldEnum | CalendarEventScalarFieldEnum[]
  }

  /**
   * CalendarEvent findMany
   */
  export type CalendarEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEvents to fetch.
     */
    where?: CalendarEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEvents to fetch.
     */
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CalendarEvents.
     */
    cursor?: CalendarEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEvents.
     */
    skip?: number
    distinct?: CalendarEventScalarFieldEnum | CalendarEventScalarFieldEnum[]
  }

  /**
   * CalendarEvent create
   */
  export type CalendarEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * The data needed to create a CalendarEvent.
     */
    data: XOR<CalendarEventCreateInput, CalendarEventUncheckedCreateInput>
  }

  /**
   * CalendarEvent createMany
   */
  export type CalendarEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CalendarEvents.
     */
    data: CalendarEventCreateManyInput | CalendarEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CalendarEvent update
   */
  export type CalendarEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * The data needed to update a CalendarEvent.
     */
    data: XOR<CalendarEventUpdateInput, CalendarEventUncheckedUpdateInput>
    /**
     * Choose, which CalendarEvent to update.
     */
    where: CalendarEventWhereUniqueInput
  }

  /**
   * CalendarEvent updateMany
   */
  export type CalendarEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CalendarEvents.
     */
    data: XOR<CalendarEventUpdateManyMutationInput, CalendarEventUncheckedUpdateManyInput>
    /**
     * Filter which CalendarEvents to update
     */
    where?: CalendarEventWhereInput
    /**
     * Limit how many CalendarEvents to update.
     */
    limit?: number
  }

  /**
   * CalendarEvent upsert
   */
  export type CalendarEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * The filter to search for the CalendarEvent to update in case it exists.
     */
    where: CalendarEventWhereUniqueInput
    /**
     * In case the CalendarEvent found by the `where` argument doesn't exist, create a new CalendarEvent with this data.
     */
    create: XOR<CalendarEventCreateInput, CalendarEventUncheckedCreateInput>
    /**
     * In case the CalendarEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CalendarEventUpdateInput, CalendarEventUncheckedUpdateInput>
  }

  /**
   * CalendarEvent delete
   */
  export type CalendarEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter which CalendarEvent to delete.
     */
    where: CalendarEventWhereUniqueInput
  }

  /**
   * CalendarEvent deleteMany
   */
  export type CalendarEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarEvents to delete
     */
    where?: CalendarEventWhereInput
    /**
     * Limit how many CalendarEvents to delete.
     */
    limit?: number
  }

  /**
   * CalendarEvent.attendees
   */
  export type CalendarEvent$attendeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarAttendee
     */
    select?: CalendarAttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarAttendee
     */
    omit?: CalendarAttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarAttendeeInclude<ExtArgs> | null
    where?: CalendarAttendeeWhereInput
    orderBy?: CalendarAttendeeOrderByWithRelationInput | CalendarAttendeeOrderByWithRelationInput[]
    cursor?: CalendarAttendeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarAttendeeScalarFieldEnum | CalendarAttendeeScalarFieldEnum[]
  }

  /**
   * CalendarEvent without action
   */
  export type CalendarEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
  }


  /**
   * Model CalendarAttendee
   */

  export type AggregateCalendarAttendee = {
    _count: CalendarAttendeeCountAggregateOutputType | null
    _min: CalendarAttendeeMinAggregateOutputType | null
    _max: CalendarAttendeeMaxAggregateOutputType | null
  }

  export type CalendarAttendeeMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    userId: string | null
    response: string | null
  }

  export type CalendarAttendeeMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    userId: string | null
    response: string | null
  }

  export type CalendarAttendeeCountAggregateOutputType = {
    id: number
    eventId: number
    userId: number
    response: number
    _all: number
  }


  export type CalendarAttendeeMinAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    response?: true
  }

  export type CalendarAttendeeMaxAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    response?: true
  }

  export type CalendarAttendeeCountAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    response?: true
    _all?: true
  }

  export type CalendarAttendeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarAttendee to aggregate.
     */
    where?: CalendarAttendeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarAttendees to fetch.
     */
    orderBy?: CalendarAttendeeOrderByWithRelationInput | CalendarAttendeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CalendarAttendeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarAttendees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarAttendees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CalendarAttendees
    **/
    _count?: true | CalendarAttendeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalendarAttendeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalendarAttendeeMaxAggregateInputType
  }

  export type GetCalendarAttendeeAggregateType<T extends CalendarAttendeeAggregateArgs> = {
        [P in keyof T & keyof AggregateCalendarAttendee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalendarAttendee[P]>
      : GetScalarType<T[P], AggregateCalendarAttendee[P]>
  }




  export type CalendarAttendeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarAttendeeWhereInput
    orderBy?: CalendarAttendeeOrderByWithAggregationInput | CalendarAttendeeOrderByWithAggregationInput[]
    by: CalendarAttendeeScalarFieldEnum[] | CalendarAttendeeScalarFieldEnum
    having?: CalendarAttendeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalendarAttendeeCountAggregateInputType | true
    _min?: CalendarAttendeeMinAggregateInputType
    _max?: CalendarAttendeeMaxAggregateInputType
  }

  export type CalendarAttendeeGroupByOutputType = {
    id: string
    eventId: string
    userId: string
    response: string | null
    _count: CalendarAttendeeCountAggregateOutputType | null
    _min: CalendarAttendeeMinAggregateOutputType | null
    _max: CalendarAttendeeMaxAggregateOutputType | null
  }

  type GetCalendarAttendeeGroupByPayload<T extends CalendarAttendeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CalendarAttendeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalendarAttendeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalendarAttendeeGroupByOutputType[P]>
            : GetScalarType<T[P], CalendarAttendeeGroupByOutputType[P]>
        }
      >
    >


  export type CalendarAttendeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    userId?: boolean
    response?: boolean
    event?: boolean | CalendarEventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calendarAttendee"]>



  export type CalendarAttendeeSelectScalar = {
    id?: boolean
    eventId?: boolean
    userId?: boolean
    response?: boolean
  }

  export type CalendarAttendeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventId" | "userId" | "response", ExtArgs["result"]["calendarAttendee"]>
  export type CalendarAttendeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | CalendarEventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CalendarAttendeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CalendarAttendee"
    objects: {
      event: Prisma.$CalendarEventPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      userId: string
      response: string | null
    }, ExtArgs["result"]["calendarAttendee"]>
    composites: {}
  }

  type CalendarAttendeeGetPayload<S extends boolean | null | undefined | CalendarAttendeeDefaultArgs> = $Result.GetResult<Prisma.$CalendarAttendeePayload, S>

  type CalendarAttendeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CalendarAttendeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CalendarAttendeeCountAggregateInputType | true
    }

  export interface CalendarAttendeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CalendarAttendee'], meta: { name: 'CalendarAttendee' } }
    /**
     * Find zero or one CalendarAttendee that matches the filter.
     * @param {CalendarAttendeeFindUniqueArgs} args - Arguments to find a CalendarAttendee
     * @example
     * // Get one CalendarAttendee
     * const calendarAttendee = await prisma.calendarAttendee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CalendarAttendeeFindUniqueArgs>(args: SelectSubset<T, CalendarAttendeeFindUniqueArgs<ExtArgs>>): Prisma__CalendarAttendeeClient<$Result.GetResult<Prisma.$CalendarAttendeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CalendarAttendee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CalendarAttendeeFindUniqueOrThrowArgs} args - Arguments to find a CalendarAttendee
     * @example
     * // Get one CalendarAttendee
     * const calendarAttendee = await prisma.calendarAttendee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CalendarAttendeeFindUniqueOrThrowArgs>(args: SelectSubset<T, CalendarAttendeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CalendarAttendeeClient<$Result.GetResult<Prisma.$CalendarAttendeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CalendarAttendee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarAttendeeFindFirstArgs} args - Arguments to find a CalendarAttendee
     * @example
     * // Get one CalendarAttendee
     * const calendarAttendee = await prisma.calendarAttendee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CalendarAttendeeFindFirstArgs>(args?: SelectSubset<T, CalendarAttendeeFindFirstArgs<ExtArgs>>): Prisma__CalendarAttendeeClient<$Result.GetResult<Prisma.$CalendarAttendeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CalendarAttendee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarAttendeeFindFirstOrThrowArgs} args - Arguments to find a CalendarAttendee
     * @example
     * // Get one CalendarAttendee
     * const calendarAttendee = await prisma.calendarAttendee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CalendarAttendeeFindFirstOrThrowArgs>(args?: SelectSubset<T, CalendarAttendeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__CalendarAttendeeClient<$Result.GetResult<Prisma.$CalendarAttendeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CalendarAttendees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarAttendeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CalendarAttendees
     * const calendarAttendees = await prisma.calendarAttendee.findMany()
     * 
     * // Get first 10 CalendarAttendees
     * const calendarAttendees = await prisma.calendarAttendee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calendarAttendeeWithIdOnly = await prisma.calendarAttendee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CalendarAttendeeFindManyArgs>(args?: SelectSubset<T, CalendarAttendeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarAttendeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CalendarAttendee.
     * @param {CalendarAttendeeCreateArgs} args - Arguments to create a CalendarAttendee.
     * @example
     * // Create one CalendarAttendee
     * const CalendarAttendee = await prisma.calendarAttendee.create({
     *   data: {
     *     // ... data to create a CalendarAttendee
     *   }
     * })
     * 
     */
    create<T extends CalendarAttendeeCreateArgs>(args: SelectSubset<T, CalendarAttendeeCreateArgs<ExtArgs>>): Prisma__CalendarAttendeeClient<$Result.GetResult<Prisma.$CalendarAttendeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CalendarAttendees.
     * @param {CalendarAttendeeCreateManyArgs} args - Arguments to create many CalendarAttendees.
     * @example
     * // Create many CalendarAttendees
     * const calendarAttendee = await prisma.calendarAttendee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CalendarAttendeeCreateManyArgs>(args?: SelectSubset<T, CalendarAttendeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CalendarAttendee.
     * @param {CalendarAttendeeDeleteArgs} args - Arguments to delete one CalendarAttendee.
     * @example
     * // Delete one CalendarAttendee
     * const CalendarAttendee = await prisma.calendarAttendee.delete({
     *   where: {
     *     // ... filter to delete one CalendarAttendee
     *   }
     * })
     * 
     */
    delete<T extends CalendarAttendeeDeleteArgs>(args: SelectSubset<T, CalendarAttendeeDeleteArgs<ExtArgs>>): Prisma__CalendarAttendeeClient<$Result.GetResult<Prisma.$CalendarAttendeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CalendarAttendee.
     * @param {CalendarAttendeeUpdateArgs} args - Arguments to update one CalendarAttendee.
     * @example
     * // Update one CalendarAttendee
     * const calendarAttendee = await prisma.calendarAttendee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CalendarAttendeeUpdateArgs>(args: SelectSubset<T, CalendarAttendeeUpdateArgs<ExtArgs>>): Prisma__CalendarAttendeeClient<$Result.GetResult<Prisma.$CalendarAttendeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CalendarAttendees.
     * @param {CalendarAttendeeDeleteManyArgs} args - Arguments to filter CalendarAttendees to delete.
     * @example
     * // Delete a few CalendarAttendees
     * const { count } = await prisma.calendarAttendee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CalendarAttendeeDeleteManyArgs>(args?: SelectSubset<T, CalendarAttendeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalendarAttendees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarAttendeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CalendarAttendees
     * const calendarAttendee = await prisma.calendarAttendee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CalendarAttendeeUpdateManyArgs>(args: SelectSubset<T, CalendarAttendeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CalendarAttendee.
     * @param {CalendarAttendeeUpsertArgs} args - Arguments to update or create a CalendarAttendee.
     * @example
     * // Update or create a CalendarAttendee
     * const calendarAttendee = await prisma.calendarAttendee.upsert({
     *   create: {
     *     // ... data to create a CalendarAttendee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CalendarAttendee we want to update
     *   }
     * })
     */
    upsert<T extends CalendarAttendeeUpsertArgs>(args: SelectSubset<T, CalendarAttendeeUpsertArgs<ExtArgs>>): Prisma__CalendarAttendeeClient<$Result.GetResult<Prisma.$CalendarAttendeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CalendarAttendees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarAttendeeCountArgs} args - Arguments to filter CalendarAttendees to count.
     * @example
     * // Count the number of CalendarAttendees
     * const count = await prisma.calendarAttendee.count({
     *   where: {
     *     // ... the filter for the CalendarAttendees we want to count
     *   }
     * })
    **/
    count<T extends CalendarAttendeeCountArgs>(
      args?: Subset<T, CalendarAttendeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalendarAttendeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CalendarAttendee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarAttendeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalendarAttendeeAggregateArgs>(args: Subset<T, CalendarAttendeeAggregateArgs>): Prisma.PrismaPromise<GetCalendarAttendeeAggregateType<T>>

    /**
     * Group by CalendarAttendee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarAttendeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalendarAttendeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalendarAttendeeGroupByArgs['orderBy'] }
        : { orderBy?: CalendarAttendeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalendarAttendeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalendarAttendeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CalendarAttendee model
   */
  readonly fields: CalendarAttendeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CalendarAttendee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CalendarAttendeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends CalendarEventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CalendarEventDefaultArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CalendarAttendee model
   */
  interface CalendarAttendeeFieldRefs {
    readonly id: FieldRef<"CalendarAttendee", 'String'>
    readonly eventId: FieldRef<"CalendarAttendee", 'String'>
    readonly userId: FieldRef<"CalendarAttendee", 'String'>
    readonly response: FieldRef<"CalendarAttendee", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CalendarAttendee findUnique
   */
  export type CalendarAttendeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarAttendee
     */
    select?: CalendarAttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarAttendee
     */
    omit?: CalendarAttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarAttendeeInclude<ExtArgs> | null
    /**
     * Filter, which CalendarAttendee to fetch.
     */
    where: CalendarAttendeeWhereUniqueInput
  }

  /**
   * CalendarAttendee findUniqueOrThrow
   */
  export type CalendarAttendeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarAttendee
     */
    select?: CalendarAttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarAttendee
     */
    omit?: CalendarAttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarAttendeeInclude<ExtArgs> | null
    /**
     * Filter, which CalendarAttendee to fetch.
     */
    where: CalendarAttendeeWhereUniqueInput
  }

  /**
   * CalendarAttendee findFirst
   */
  export type CalendarAttendeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarAttendee
     */
    select?: CalendarAttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarAttendee
     */
    omit?: CalendarAttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarAttendeeInclude<ExtArgs> | null
    /**
     * Filter, which CalendarAttendee to fetch.
     */
    where?: CalendarAttendeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarAttendees to fetch.
     */
    orderBy?: CalendarAttendeeOrderByWithRelationInput | CalendarAttendeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarAttendees.
     */
    cursor?: CalendarAttendeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarAttendees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarAttendees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarAttendees.
     */
    distinct?: CalendarAttendeeScalarFieldEnum | CalendarAttendeeScalarFieldEnum[]
  }

  /**
   * CalendarAttendee findFirstOrThrow
   */
  export type CalendarAttendeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarAttendee
     */
    select?: CalendarAttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarAttendee
     */
    omit?: CalendarAttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarAttendeeInclude<ExtArgs> | null
    /**
     * Filter, which CalendarAttendee to fetch.
     */
    where?: CalendarAttendeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarAttendees to fetch.
     */
    orderBy?: CalendarAttendeeOrderByWithRelationInput | CalendarAttendeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarAttendees.
     */
    cursor?: CalendarAttendeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarAttendees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarAttendees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarAttendees.
     */
    distinct?: CalendarAttendeeScalarFieldEnum | CalendarAttendeeScalarFieldEnum[]
  }

  /**
   * CalendarAttendee findMany
   */
  export type CalendarAttendeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarAttendee
     */
    select?: CalendarAttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarAttendee
     */
    omit?: CalendarAttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarAttendeeInclude<ExtArgs> | null
    /**
     * Filter, which CalendarAttendees to fetch.
     */
    where?: CalendarAttendeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarAttendees to fetch.
     */
    orderBy?: CalendarAttendeeOrderByWithRelationInput | CalendarAttendeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CalendarAttendees.
     */
    cursor?: CalendarAttendeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarAttendees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarAttendees.
     */
    skip?: number
    distinct?: CalendarAttendeeScalarFieldEnum | CalendarAttendeeScalarFieldEnum[]
  }

  /**
   * CalendarAttendee create
   */
  export type CalendarAttendeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarAttendee
     */
    select?: CalendarAttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarAttendee
     */
    omit?: CalendarAttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarAttendeeInclude<ExtArgs> | null
    /**
     * The data needed to create a CalendarAttendee.
     */
    data: XOR<CalendarAttendeeCreateInput, CalendarAttendeeUncheckedCreateInput>
  }

  /**
   * CalendarAttendee createMany
   */
  export type CalendarAttendeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CalendarAttendees.
     */
    data: CalendarAttendeeCreateManyInput | CalendarAttendeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CalendarAttendee update
   */
  export type CalendarAttendeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarAttendee
     */
    select?: CalendarAttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarAttendee
     */
    omit?: CalendarAttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarAttendeeInclude<ExtArgs> | null
    /**
     * The data needed to update a CalendarAttendee.
     */
    data: XOR<CalendarAttendeeUpdateInput, CalendarAttendeeUncheckedUpdateInput>
    /**
     * Choose, which CalendarAttendee to update.
     */
    where: CalendarAttendeeWhereUniqueInput
  }

  /**
   * CalendarAttendee updateMany
   */
  export type CalendarAttendeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CalendarAttendees.
     */
    data: XOR<CalendarAttendeeUpdateManyMutationInput, CalendarAttendeeUncheckedUpdateManyInput>
    /**
     * Filter which CalendarAttendees to update
     */
    where?: CalendarAttendeeWhereInput
    /**
     * Limit how many CalendarAttendees to update.
     */
    limit?: number
  }

  /**
   * CalendarAttendee upsert
   */
  export type CalendarAttendeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarAttendee
     */
    select?: CalendarAttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarAttendee
     */
    omit?: CalendarAttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarAttendeeInclude<ExtArgs> | null
    /**
     * The filter to search for the CalendarAttendee to update in case it exists.
     */
    where: CalendarAttendeeWhereUniqueInput
    /**
     * In case the CalendarAttendee found by the `where` argument doesn't exist, create a new CalendarAttendee with this data.
     */
    create: XOR<CalendarAttendeeCreateInput, CalendarAttendeeUncheckedCreateInput>
    /**
     * In case the CalendarAttendee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CalendarAttendeeUpdateInput, CalendarAttendeeUncheckedUpdateInput>
  }

  /**
   * CalendarAttendee delete
   */
  export type CalendarAttendeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarAttendee
     */
    select?: CalendarAttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarAttendee
     */
    omit?: CalendarAttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarAttendeeInclude<ExtArgs> | null
    /**
     * Filter which CalendarAttendee to delete.
     */
    where: CalendarAttendeeWhereUniqueInput
  }

  /**
   * CalendarAttendee deleteMany
   */
  export type CalendarAttendeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarAttendees to delete
     */
    where?: CalendarAttendeeWhereInput
    /**
     * Limit how many CalendarAttendees to delete.
     */
    limit?: number
  }

  /**
   * CalendarAttendee without action
   */
  export type CalendarAttendeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarAttendee
     */
    select?: CalendarAttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarAttendee
     */
    omit?: CalendarAttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarAttendeeInclude<ExtArgs> | null
  }


  /**
   * Model UserPreference
   */

  export type AggregateUserPreference = {
    _count: UserPreferenceCountAggregateOutputType | null
    _min: UserPreferenceMinAggregateOutputType | null
    _max: UserPreferenceMaxAggregateOutputType | null
  }

  export type UserPreferenceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    theme: string | null
    locale: string | null
    notificationsEnabled: boolean | null
  }

  export type UserPreferenceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    theme: string | null
    locale: string | null
    notificationsEnabled: boolean | null
  }

  export type UserPreferenceCountAggregateOutputType = {
    id: number
    userId: number
    theme: number
    locale: number
    notificationsEnabled: number
    _all: number
  }


  export type UserPreferenceMinAggregateInputType = {
    id?: true
    userId?: true
    theme?: true
    locale?: true
    notificationsEnabled?: true
  }

  export type UserPreferenceMaxAggregateInputType = {
    id?: true
    userId?: true
    theme?: true
    locale?: true
    notificationsEnabled?: true
  }

  export type UserPreferenceCountAggregateInputType = {
    id?: true
    userId?: true
    theme?: true
    locale?: true
    notificationsEnabled?: true
    _all?: true
  }

  export type UserPreferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPreference to aggregate.
     */
    where?: UserPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferenceOrderByWithRelationInput | UserPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPreferences
    **/
    _count?: true | UserPreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPreferenceMaxAggregateInputType
  }

  export type GetUserPreferenceAggregateType<T extends UserPreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPreference[P]>
      : GetScalarType<T[P], AggregateUserPreference[P]>
  }




  export type UserPreferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPreferenceWhereInput
    orderBy?: UserPreferenceOrderByWithAggregationInput | UserPreferenceOrderByWithAggregationInput[]
    by: UserPreferenceScalarFieldEnum[] | UserPreferenceScalarFieldEnum
    having?: UserPreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPreferenceCountAggregateInputType | true
    _min?: UserPreferenceMinAggregateInputType
    _max?: UserPreferenceMaxAggregateInputType
  }

  export type UserPreferenceGroupByOutputType = {
    id: string
    userId: string
    theme: string | null
    locale: string | null
    notificationsEnabled: boolean
    _count: UserPreferenceCountAggregateOutputType | null
    _min: UserPreferenceMinAggregateOutputType | null
    _max: UserPreferenceMaxAggregateOutputType | null
  }

  type GetUserPreferenceGroupByPayload<T extends UserPreferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], UserPreferenceGroupByOutputType[P]>
        }
      >
    >


  export type UserPreferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    theme?: boolean
    locale?: boolean
    notificationsEnabled?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPreference"]>



  export type UserPreferenceSelectScalar = {
    id?: boolean
    userId?: boolean
    theme?: boolean
    locale?: boolean
    notificationsEnabled?: boolean
  }

  export type UserPreferenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "theme" | "locale" | "notificationsEnabled", ExtArgs["result"]["userPreference"]>
  export type UserPreferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserPreferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPreference"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      theme: string | null
      locale: string | null
      notificationsEnabled: boolean
    }, ExtArgs["result"]["userPreference"]>
    composites: {}
  }

  type UserPreferenceGetPayload<S extends boolean | null | undefined | UserPreferenceDefaultArgs> = $Result.GetResult<Prisma.$UserPreferencePayload, S>

  type UserPreferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPreferenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPreferenceCountAggregateInputType | true
    }

  export interface UserPreferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPreference'], meta: { name: 'UserPreference' } }
    /**
     * Find zero or one UserPreference that matches the filter.
     * @param {UserPreferenceFindUniqueArgs} args - Arguments to find a UserPreference
     * @example
     * // Get one UserPreference
     * const userPreference = await prisma.userPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPreferenceFindUniqueArgs>(args: SelectSubset<T, UserPreferenceFindUniqueArgs<ExtArgs>>): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPreference that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPreferenceFindUniqueOrThrowArgs} args - Arguments to find a UserPreference
     * @example
     * // Get one UserPreference
     * const userPreference = await prisma.userPreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPreferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPreferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferenceFindFirstArgs} args - Arguments to find a UserPreference
     * @example
     * // Get one UserPreference
     * const userPreference = await prisma.userPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPreferenceFindFirstArgs>(args?: SelectSubset<T, UserPreferenceFindFirstArgs<ExtArgs>>): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPreference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferenceFindFirstOrThrowArgs} args - Arguments to find a UserPreference
     * @example
     * // Get one UserPreference
     * const userPreference = await prisma.userPreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPreferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPreferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPreferences
     * const userPreferences = await prisma.userPreference.findMany()
     * 
     * // Get first 10 UserPreferences
     * const userPreferences = await prisma.userPreference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPreferenceWithIdOnly = await prisma.userPreference.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPreferenceFindManyArgs>(args?: SelectSubset<T, UserPreferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPreference.
     * @param {UserPreferenceCreateArgs} args - Arguments to create a UserPreference.
     * @example
     * // Create one UserPreference
     * const UserPreference = await prisma.userPreference.create({
     *   data: {
     *     // ... data to create a UserPreference
     *   }
     * })
     * 
     */
    create<T extends UserPreferenceCreateArgs>(args: SelectSubset<T, UserPreferenceCreateArgs<ExtArgs>>): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPreferences.
     * @param {UserPreferenceCreateManyArgs} args - Arguments to create many UserPreferences.
     * @example
     * // Create many UserPreferences
     * const userPreference = await prisma.userPreference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPreferenceCreateManyArgs>(args?: SelectSubset<T, UserPreferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserPreference.
     * @param {UserPreferenceDeleteArgs} args - Arguments to delete one UserPreference.
     * @example
     * // Delete one UserPreference
     * const UserPreference = await prisma.userPreference.delete({
     *   where: {
     *     // ... filter to delete one UserPreference
     *   }
     * })
     * 
     */
    delete<T extends UserPreferenceDeleteArgs>(args: SelectSubset<T, UserPreferenceDeleteArgs<ExtArgs>>): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPreference.
     * @param {UserPreferenceUpdateArgs} args - Arguments to update one UserPreference.
     * @example
     * // Update one UserPreference
     * const userPreference = await prisma.userPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPreferenceUpdateArgs>(args: SelectSubset<T, UserPreferenceUpdateArgs<ExtArgs>>): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPreferences.
     * @param {UserPreferenceDeleteManyArgs} args - Arguments to filter UserPreferences to delete.
     * @example
     * // Delete a few UserPreferences
     * const { count } = await prisma.userPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPreferenceDeleteManyArgs>(args?: SelectSubset<T, UserPreferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPreferences
     * const userPreference = await prisma.userPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPreferenceUpdateManyArgs>(args: SelectSubset<T, UserPreferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserPreference.
     * @param {UserPreferenceUpsertArgs} args - Arguments to update or create a UserPreference.
     * @example
     * // Update or create a UserPreference
     * const userPreference = await prisma.userPreference.upsert({
     *   create: {
     *     // ... data to create a UserPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPreference we want to update
     *   }
     * })
     */
    upsert<T extends UserPreferenceUpsertArgs>(args: SelectSubset<T, UserPreferenceUpsertArgs<ExtArgs>>): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferenceCountArgs} args - Arguments to filter UserPreferences to count.
     * @example
     * // Count the number of UserPreferences
     * const count = await prisma.userPreference.count({
     *   where: {
     *     // ... the filter for the UserPreferences we want to count
     *   }
     * })
    **/
    count<T extends UserPreferenceCountArgs>(
      args?: Subset<T, UserPreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPreferenceAggregateArgs>(args: Subset<T, UserPreferenceAggregateArgs>): Prisma.PrismaPromise<GetUserPreferenceAggregateType<T>>

    /**
     * Group by UserPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: UserPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPreferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPreference model
   */
  readonly fields: UserPreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPreferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPreference model
   */
  interface UserPreferenceFieldRefs {
    readonly id: FieldRef<"UserPreference", 'String'>
    readonly userId: FieldRef<"UserPreference", 'String'>
    readonly theme: FieldRef<"UserPreference", 'String'>
    readonly locale: FieldRef<"UserPreference", 'String'>
    readonly notificationsEnabled: FieldRef<"UserPreference", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * UserPreference findUnique
   */
  export type UserPreferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which UserPreference to fetch.
     */
    where: UserPreferenceWhereUniqueInput
  }

  /**
   * UserPreference findUniqueOrThrow
   */
  export type UserPreferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which UserPreference to fetch.
     */
    where: UserPreferenceWhereUniqueInput
  }

  /**
   * UserPreference findFirst
   */
  export type UserPreferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which UserPreference to fetch.
     */
    where?: UserPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferenceOrderByWithRelationInput | UserPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPreferences.
     */
    cursor?: UserPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPreferences.
     */
    distinct?: UserPreferenceScalarFieldEnum | UserPreferenceScalarFieldEnum[]
  }

  /**
   * UserPreference findFirstOrThrow
   */
  export type UserPreferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which UserPreference to fetch.
     */
    where?: UserPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferenceOrderByWithRelationInput | UserPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPreferences.
     */
    cursor?: UserPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPreferences.
     */
    distinct?: UserPreferenceScalarFieldEnum | UserPreferenceScalarFieldEnum[]
  }

  /**
   * UserPreference findMany
   */
  export type UserPreferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferenceOrderByWithRelationInput | UserPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPreferences.
     */
    cursor?: UserPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    distinct?: UserPreferenceScalarFieldEnum | UserPreferenceScalarFieldEnum[]
  }

  /**
   * UserPreference create
   */
  export type UserPreferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPreference.
     */
    data: XOR<UserPreferenceCreateInput, UserPreferenceUncheckedCreateInput>
  }

  /**
   * UserPreference createMany
   */
  export type UserPreferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPreferences.
     */
    data: UserPreferenceCreateManyInput | UserPreferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPreference update
   */
  export type UserPreferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPreference.
     */
    data: XOR<UserPreferenceUpdateInput, UserPreferenceUncheckedUpdateInput>
    /**
     * Choose, which UserPreference to update.
     */
    where: UserPreferenceWhereUniqueInput
  }

  /**
   * UserPreference updateMany
   */
  export type UserPreferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPreferences.
     */
    data: XOR<UserPreferenceUpdateManyMutationInput, UserPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which UserPreferences to update
     */
    where?: UserPreferenceWhereInput
    /**
     * Limit how many UserPreferences to update.
     */
    limit?: number
  }

  /**
   * UserPreference upsert
   */
  export type UserPreferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPreference to update in case it exists.
     */
    where: UserPreferenceWhereUniqueInput
    /**
     * In case the UserPreference found by the `where` argument doesn't exist, create a new UserPreference with this data.
     */
    create: XOR<UserPreferenceCreateInput, UserPreferenceUncheckedCreateInput>
    /**
     * In case the UserPreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPreferenceUpdateInput, UserPreferenceUncheckedUpdateInput>
  }

  /**
   * UserPreference delete
   */
  export type UserPreferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * Filter which UserPreference to delete.
     */
    where: UserPreferenceWhereUniqueInput
  }

  /**
   * UserPreference deleteMany
   */
  export type UserPreferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPreferences to delete
     */
    where?: UserPreferenceWhereInput
    /**
     * Limit how many UserPreferences to delete.
     */
    limit?: number
  }

  /**
   * UserPreference without action
   */
  export type UserPreferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    actorId: string | null
    entity: string | null
    entityId: string | null
    action: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    actorId: string | null
    entity: string | null
    entityId: string | null
    action: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    actorId: number
    entity: number
    entityId: number
    action: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    actorId?: true
    entity?: true
    entityId?: true
    action?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    actorId?: true
    entity?: true
    entityId?: true
    action?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    actorId?: true
    entity?: true
    entityId?: true
    action?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    actorId: string | null
    entity: string
    entityId: string
    action: string
    metadata: JsonValue | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorId?: boolean
    entity?: boolean
    entityId?: boolean
    action?: boolean
    metadata?: boolean
    createdAt?: boolean
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>



  export type AuditLogSelectScalar = {
    id?: boolean
    actorId?: boolean
    entity?: boolean
    entityId?: boolean
    action?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "actorId" | "entity" | "entityId" | "action" | "metadata" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      actor: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      actorId: string | null
      entity: string
      entityId: string
      action: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    actor<T extends AuditLog$actorArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$actorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly actorId: FieldRef<"AuditLog", 'String'>
    readonly entity: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly metadata: FieldRef<"AuditLog", 'Json'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.actor
   */
  export type AuditLog$actorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    role: 'role',
    employment: 'employment',
    phone: 'phone',
    address: 'address',
    joinDate: 'joinDate',
    salary: 'salary',
    notes: 'notes',
    departmentId: 'departmentId',
    managerId: 'managerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    headId: 'headId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    priority: 'priority',
    status: 'status',
    dueDate: 'dueDate',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const TaskAssignmentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    taskId: 'taskId',
    assignedAt: 'assignedAt'
  };

  export type TaskAssignmentScalarFieldEnum = (typeof TaskAssignmentScalarFieldEnum)[keyof typeof TaskAssignmentScalarFieldEnum]


  export const TaskCommentScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    userId: 'userId',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type TaskCommentScalarFieldEnum = (typeof TaskCommentScalarFieldEnum)[keyof typeof TaskCommentScalarFieldEnum]


  export const TaskTimeLogScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    userId: 'userId',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    durationSeconds: 'durationSeconds'
  };

  export type TaskTimeLogScalarFieldEnum = (typeof TaskTimeLogScalarFieldEnum)[keyof typeof TaskTimeLogScalarFieldEnum]


  export const AttendanceRecordScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    date: 'date',
    clockIn: 'clockIn',
    clockOut: 'clockOut',
    status: 'status',
    ipAddress: 'ipAddress',
    location: 'location'
  };

  export type AttendanceRecordScalarFieldEnum = (typeof AttendanceRecordScalarFieldEnum)[keyof typeof AttendanceRecordScalarFieldEnum]


  export const LeaveScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    startDate: 'startDate',
    endDate: 'endDate',
    reason: 'reason',
    status: 'status',
    approverId: 'approverId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeaveScalarFieldEnum = (typeof LeaveScalarFieldEnum)[keyof typeof LeaveScalarFieldEnum]


  export const ChatMessageScalarFieldEnum: {
    id: 'id',
    senderId: 'senderId',
    receiverId: 'receiverId',
    groupId: 'groupId',
    content: 'content',
    timestamp: 'timestamp'
  };

  export type ChatMessageScalarFieldEnum = (typeof ChatMessageScalarFieldEnum)[keyof typeof ChatMessageScalarFieldEnum]


  export const ChatGroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt'
  };

  export type ChatGroupScalarFieldEnum = (typeof ChatGroupScalarFieldEnum)[keyof typeof ChatGroupScalarFieldEnum]


  export const ChatGroupMemberScalarFieldEnum: {
    id: 'id',
    groupId: 'groupId',
    userId: 'userId',
    joinedAt: 'joinedAt'
  };

  export type ChatGroupMemberScalarFieldEnum = (typeof ChatGroupMemberScalarFieldEnum)[keyof typeof ChatGroupMemberScalarFieldEnum]


  export const AnnouncementScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    authorId: 'authorId',
    departmentId: 'departmentId',
    createdAt: 'createdAt'
  };

  export type AnnouncementScalarFieldEnum = (typeof AnnouncementScalarFieldEnum)[keyof typeof AnnouncementScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    message: 'message',
    type: 'type',
    data: 'data',
    read: 'read',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    fileUrl: 'fileUrl',
    createdAt: 'createdAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const CompanyDocumentScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    fileUrl: 'fileUrl',
    uploadedBy: 'uploadedBy',
    createdAt: 'createdAt'
  };

  export type CompanyDocumentScalarFieldEnum = (typeof CompanyDocumentScalarFieldEnum)[keyof typeof CompanyDocumentScalarFieldEnum]


  export const ExpenseScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    description: 'description',
    category: 'category',
    amount: 'amount',
    currency: 'currency',
    date: 'date',
    status: 'status',
    receiptUrl: 'receiptUrl',
    submittedAt: 'submittedAt',
    approvedAt: 'approvedAt',
    approvedById: 'approvedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExpenseScalarFieldEnum = (typeof ExpenseScalarFieldEnum)[keyof typeof ExpenseScalarFieldEnum]


  export const AssetScalarFieldEnum: {
    id: 'id',
    tag: 'tag',
    name: 'name',
    type: 'type',
    serialNumber: 'serialNumber',
    purchaseDate: 'purchaseDate',
    status: 'status',
    assignedToId: 'assignedToId',
    assignedAt: 'assignedAt',
    location: 'location',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AssetScalarFieldEnum = (typeof AssetScalarFieldEnum)[keyof typeof AssetScalarFieldEnum]


  export const PayrollScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    month: 'month',
    year: 'year',
    baseSalary: 'baseSalary',
    allowances: 'allowances',
    deductions: 'deductions',
    netPay: 'netPay',
    currency: 'currency',
    status: 'status',
    generatedById: 'generatedById',
    generatedAt: 'generatedAt',
    paidAt: 'paidAt',
    slipUrl: 'slipUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PayrollScalarFieldEnum = (typeof PayrollScalarFieldEnum)[keyof typeof PayrollScalarFieldEnum]


  export const PerformanceReviewScalarFieldEnum: {
    id: 'id',
    revieweeId: 'revieweeId',
    reviewerId: 'reviewerId',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    overallScore: 'overallScore',
    kpiScores: 'kpiScores',
    feedback: 'feedback',
    createdAt: 'createdAt'
  };

  export type PerformanceReviewScalarFieldEnum = (typeof PerformanceReviewScalarFieldEnum)[keyof typeof PerformanceReviewScalarFieldEnum]


  export const JobPostScalarFieldEnum: {
    id: 'id',
    title: 'title',
    departmentId: 'departmentId',
    type: 'type',
    location: 'location',
    description: 'description',
    postedById: 'postedById',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type JobPostScalarFieldEnum = (typeof JobPostScalarFieldEnum)[keyof typeof JobPostScalarFieldEnum]


  export const ApplicationScalarFieldEnum: {
    id: 'id',
    jobPostId: 'jobPostId',
    applicantUserId: 'applicantUserId',
    applicantName: 'applicantName',
    applicantEmail: 'applicantEmail',
    resumeUrl: 'resumeUrl',
    coverLetter: 'coverLetter',
    status: 'status',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ApplicationScalarFieldEnum = (typeof ApplicationScalarFieldEnum)[keyof typeof ApplicationScalarFieldEnum]


  export const TrainingProgramScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    trainer: 'trainer',
    location: 'location',
    startDate: 'startDate',
    endDate: 'endDate',
    status: 'status',
    mode: 'mode',
    maxSeats: 'maxSeats',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrainingProgramScalarFieldEnum = (typeof TrainingProgramScalarFieldEnum)[keyof typeof TrainingProgramScalarFieldEnum]


  export const TrainingEnrollmentScalarFieldEnum: {
    id: 'id',
    trainingId: 'trainingId',
    userId: 'userId',
    enrolledAt: 'enrolledAt',
    completedAt: 'completedAt',
    certificateUrl: 'certificateUrl'
  };

  export type TrainingEnrollmentScalarFieldEnum = (typeof TrainingEnrollmentScalarFieldEnum)[keyof typeof TrainingEnrollmentScalarFieldEnum]


  export const CalendarEventScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    organizerId: 'organizerId',
    startTime: 'startTime',
    endTime: 'endTime',
    source: 'source',
    googleMeetLink: 'googleMeetLink',
    location: 'location',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CalendarEventScalarFieldEnum = (typeof CalendarEventScalarFieldEnum)[keyof typeof CalendarEventScalarFieldEnum]


  export const CalendarAttendeeScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    userId: 'userId',
    response: 'response'
  };

  export type CalendarAttendeeScalarFieldEnum = (typeof CalendarAttendeeScalarFieldEnum)[keyof typeof CalendarAttendeeScalarFieldEnum]


  export const UserPreferenceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    theme: 'theme',
    locale: 'locale',
    notificationsEnabled: 'notificationsEnabled'
  };

  export type UserPreferenceScalarFieldEnum = (typeof UserPreferenceScalarFieldEnum)[keyof typeof UserPreferenceScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    actorId: 'actorId',
    entity: 'entity',
    entityId: 'entityId',
    action: 'action',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const UserOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    phone: 'phone',
    address: 'address',
    notes: 'notes',
    departmentId: 'departmentId',
    managerId: 'managerId'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const DepartmentOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    headId: 'headId'
  };

  export type DepartmentOrderByRelevanceFieldEnum = (typeof DepartmentOrderByRelevanceFieldEnum)[keyof typeof DepartmentOrderByRelevanceFieldEnum]


  export const TaskOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    createdById: 'createdById'
  };

  export type TaskOrderByRelevanceFieldEnum = (typeof TaskOrderByRelevanceFieldEnum)[keyof typeof TaskOrderByRelevanceFieldEnum]


  export const TaskAssignmentOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    taskId: 'taskId'
  };

  export type TaskAssignmentOrderByRelevanceFieldEnum = (typeof TaskAssignmentOrderByRelevanceFieldEnum)[keyof typeof TaskAssignmentOrderByRelevanceFieldEnum]


  export const TaskCommentOrderByRelevanceFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    userId: 'userId',
    content: 'content'
  };

  export type TaskCommentOrderByRelevanceFieldEnum = (typeof TaskCommentOrderByRelevanceFieldEnum)[keyof typeof TaskCommentOrderByRelevanceFieldEnum]


  export const TaskTimeLogOrderByRelevanceFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    userId: 'userId'
  };

  export type TaskTimeLogOrderByRelevanceFieldEnum = (typeof TaskTimeLogOrderByRelevanceFieldEnum)[keyof typeof TaskTimeLogOrderByRelevanceFieldEnum]


  export const AttendanceRecordOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    ipAddress: 'ipAddress',
    location: 'location'
  };

  export type AttendanceRecordOrderByRelevanceFieldEnum = (typeof AttendanceRecordOrderByRelevanceFieldEnum)[keyof typeof AttendanceRecordOrderByRelevanceFieldEnum]


  export const LeaveOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    reason: 'reason',
    approverId: 'approverId'
  };

  export type LeaveOrderByRelevanceFieldEnum = (typeof LeaveOrderByRelevanceFieldEnum)[keyof typeof LeaveOrderByRelevanceFieldEnum]


  export const ChatMessageOrderByRelevanceFieldEnum: {
    id: 'id',
    senderId: 'senderId',
    receiverId: 'receiverId',
    groupId: 'groupId',
    content: 'content'
  };

  export type ChatMessageOrderByRelevanceFieldEnum = (typeof ChatMessageOrderByRelevanceFieldEnum)[keyof typeof ChatMessageOrderByRelevanceFieldEnum]


  export const ChatGroupOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type ChatGroupOrderByRelevanceFieldEnum = (typeof ChatGroupOrderByRelevanceFieldEnum)[keyof typeof ChatGroupOrderByRelevanceFieldEnum]


  export const ChatGroupMemberOrderByRelevanceFieldEnum: {
    id: 'id',
    groupId: 'groupId',
    userId: 'userId'
  };

  export type ChatGroupMemberOrderByRelevanceFieldEnum = (typeof ChatGroupMemberOrderByRelevanceFieldEnum)[keyof typeof ChatGroupMemberOrderByRelevanceFieldEnum]


  export const AnnouncementOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    authorId: 'authorId',
    departmentId: 'departmentId'
  };

  export type AnnouncementOrderByRelevanceFieldEnum = (typeof AnnouncementOrderByRelevanceFieldEnum)[keyof typeof AnnouncementOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NotificationOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    message: 'message'
  };

  export type NotificationOrderByRelevanceFieldEnum = (typeof NotificationOrderByRelevanceFieldEnum)[keyof typeof NotificationOrderByRelevanceFieldEnum]


  export const DocumentOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    fileUrl: 'fileUrl'
  };

  export type DocumentOrderByRelevanceFieldEnum = (typeof DocumentOrderByRelevanceFieldEnum)[keyof typeof DocumentOrderByRelevanceFieldEnum]


  export const CompanyDocumentOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    fileUrl: 'fileUrl',
    uploadedBy: 'uploadedBy'
  };

  export type CompanyDocumentOrderByRelevanceFieldEnum = (typeof CompanyDocumentOrderByRelevanceFieldEnum)[keyof typeof CompanyDocumentOrderByRelevanceFieldEnum]


  export const ExpenseOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    description: 'description',
    category: 'category',
    currency: 'currency',
    receiptUrl: 'receiptUrl',
    approvedById: 'approvedById'
  };

  export type ExpenseOrderByRelevanceFieldEnum = (typeof ExpenseOrderByRelevanceFieldEnum)[keyof typeof ExpenseOrderByRelevanceFieldEnum]


  export const AssetOrderByRelevanceFieldEnum: {
    id: 'id',
    tag: 'tag',
    name: 'name',
    type: 'type',
    serialNumber: 'serialNumber',
    assignedToId: 'assignedToId',
    location: 'location',
    notes: 'notes'
  };

  export type AssetOrderByRelevanceFieldEnum = (typeof AssetOrderByRelevanceFieldEnum)[keyof typeof AssetOrderByRelevanceFieldEnum]


  export const PayrollOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    currency: 'currency',
    generatedById: 'generatedById',
    slipUrl: 'slipUrl'
  };

  export type PayrollOrderByRelevanceFieldEnum = (typeof PayrollOrderByRelevanceFieldEnum)[keyof typeof PayrollOrderByRelevanceFieldEnum]


  export const PerformanceReviewOrderByRelevanceFieldEnum: {
    id: 'id',
    revieweeId: 'revieweeId',
    reviewerId: 'reviewerId',
    feedback: 'feedback'
  };

  export type PerformanceReviewOrderByRelevanceFieldEnum = (typeof PerformanceReviewOrderByRelevanceFieldEnum)[keyof typeof PerformanceReviewOrderByRelevanceFieldEnum]


  export const JobPostOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    departmentId: 'departmentId',
    location: 'location',
    description: 'description',
    postedById: 'postedById'
  };

  export type JobPostOrderByRelevanceFieldEnum = (typeof JobPostOrderByRelevanceFieldEnum)[keyof typeof JobPostOrderByRelevanceFieldEnum]


  export const ApplicationOrderByRelevanceFieldEnum: {
    id: 'id',
    jobPostId: 'jobPostId',
    applicantUserId: 'applicantUserId',
    applicantName: 'applicantName',
    applicantEmail: 'applicantEmail',
    resumeUrl: 'resumeUrl',
    coverLetter: 'coverLetter',
    notes: 'notes'
  };

  export type ApplicationOrderByRelevanceFieldEnum = (typeof ApplicationOrderByRelevanceFieldEnum)[keyof typeof ApplicationOrderByRelevanceFieldEnum]


  export const TrainingProgramOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    trainer: 'trainer',
    location: 'location',
    mode: 'mode'
  };

  export type TrainingProgramOrderByRelevanceFieldEnum = (typeof TrainingProgramOrderByRelevanceFieldEnum)[keyof typeof TrainingProgramOrderByRelevanceFieldEnum]


  export const TrainingEnrollmentOrderByRelevanceFieldEnum: {
    id: 'id',
    trainingId: 'trainingId',
    userId: 'userId',
    certificateUrl: 'certificateUrl'
  };

  export type TrainingEnrollmentOrderByRelevanceFieldEnum = (typeof TrainingEnrollmentOrderByRelevanceFieldEnum)[keyof typeof TrainingEnrollmentOrderByRelevanceFieldEnum]


  export const CalendarEventOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    organizerId: 'organizerId',
    googleMeetLink: 'googleMeetLink',
    location: 'location'
  };

  export type CalendarEventOrderByRelevanceFieldEnum = (typeof CalendarEventOrderByRelevanceFieldEnum)[keyof typeof CalendarEventOrderByRelevanceFieldEnum]


  export const CalendarAttendeeOrderByRelevanceFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    userId: 'userId',
    response: 'response'
  };

  export type CalendarAttendeeOrderByRelevanceFieldEnum = (typeof CalendarAttendeeOrderByRelevanceFieldEnum)[keyof typeof CalendarAttendeeOrderByRelevanceFieldEnum]


  export const UserPreferenceOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    theme: 'theme',
    locale: 'locale'
  };

  export type UserPreferenceOrderByRelevanceFieldEnum = (typeof UserPreferenceOrderByRelevanceFieldEnum)[keyof typeof UserPreferenceOrderByRelevanceFieldEnum]


  export const AuditLogOrderByRelevanceFieldEnum: {
    id: 'id',
    actorId: 'actorId',
    entity: 'entity',
    entityId: 'entityId',
    action: 'action'
  };

  export type AuditLogOrderByRelevanceFieldEnum = (typeof AuditLogOrderByRelevanceFieldEnum)[keyof typeof AuditLogOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'EmploymentStatus'
   */
  export type EnumEmploymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmploymentStatus'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'TaskPriority'
   */
  export type EnumTaskPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskPriority'>
    


  /**
   * Reference to a field of type 'TaskStatus'
   */
  export type EnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'AttendanceStatus'
   */
  export type EnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus'>
    


  /**
   * Reference to a field of type 'LeaveStatus'
   */
  export type EnumLeaveStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveStatus'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ExpenseStatus'
   */
  export type EnumExpenseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExpenseStatus'>
    


  /**
   * Reference to a field of type 'AssetStatus'
   */
  export type EnumAssetStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssetStatus'>
    


  /**
   * Reference to a field of type 'PayrollStatus'
   */
  export type EnumPayrollStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayrollStatus'>
    


  /**
   * Reference to a field of type 'JobType'
   */
  export type EnumJobTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobType'>
    


  /**
   * Reference to a field of type 'ApplicationStatus'
   */
  export type EnumApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationStatus'>
    


  /**
   * Reference to a field of type 'TrainingStatus'
   */
  export type EnumTrainingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrainingStatus'>
    


  /**
   * Reference to a field of type 'EventSource'
   */
  export type EnumEventSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventSource'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    employment?: EnumEmploymentStatusFilter<"User"> | $Enums.EmploymentStatus
    phone?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    joinDate?: DateTimeNullableFilter<"User"> | Date | string | null
    salary?: DecimalNullableFilter<"User"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"User"> | string | null
    departmentId?: StringNullableFilter<"User"> | string | null
    managerId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    manager?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    reports?: UserListRelationFilter
    tasksCreated?: TaskListRelationFilter
    taskAssignments?: TaskAssignmentListRelationFilter
    taskComments?: TaskCommentListRelationFilter
    timeLogs?: TaskTimeLogListRelationFilter
    attendance?: AttendanceRecordListRelationFilter
    leaves?: LeaveListRelationFilter
    leavesToApprove?: LeaveListRelationFilter
    messagesSent?: ChatMessageListRelationFilter
    messagesRecv?: ChatMessageListRelationFilter
    chatGroups?: ChatGroupMemberListRelationFilter
    notifications?: NotificationListRelationFilter
    documents?: DocumentListRelationFilter
    companyDocs?: CompanyDocumentListRelationFilter
    expenses?: ExpenseListRelationFilter
    expensesApproved?: ExpenseListRelationFilter
    payrolls?: PayrollListRelationFilter
    generatedPays?: PayrollListRelationFilter
    performanceReviewsGiven?: PerformanceReviewListRelationFilter
    performanceReviewsGot?: PerformanceReviewListRelationFilter
    assetsOwned?: AssetListRelationFilter
    jobPosts?: JobPostListRelationFilter
    applications?: ApplicationListRelationFilter
    eventsOrganized?: CalendarEventListRelationFilter
    eventAttendees?: CalendarAttendeeListRelationFilter
    trainingEnrollments?: TrainingEnrollmentListRelationFilter
    announcementsMade?: AnnouncementListRelationFilter
    preferences?: XOR<UserPreferenceNullableScalarRelationFilter, UserPreferenceWhereInput> | null
    auditLogs?: AuditLogListRelationFilter
    headedDepartments?: DepartmentListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    employment?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    joinDate?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    department?: DepartmentOrderByWithRelationInput
    manager?: UserOrderByWithRelationInput
    reports?: UserOrderByRelationAggregateInput
    tasksCreated?: TaskOrderByRelationAggregateInput
    taskAssignments?: TaskAssignmentOrderByRelationAggregateInput
    taskComments?: TaskCommentOrderByRelationAggregateInput
    timeLogs?: TaskTimeLogOrderByRelationAggregateInput
    attendance?: AttendanceRecordOrderByRelationAggregateInput
    leaves?: LeaveOrderByRelationAggregateInput
    leavesToApprove?: LeaveOrderByRelationAggregateInput
    messagesSent?: ChatMessageOrderByRelationAggregateInput
    messagesRecv?: ChatMessageOrderByRelationAggregateInput
    chatGroups?: ChatGroupMemberOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    companyDocs?: CompanyDocumentOrderByRelationAggregateInput
    expenses?: ExpenseOrderByRelationAggregateInput
    expensesApproved?: ExpenseOrderByRelationAggregateInput
    payrolls?: PayrollOrderByRelationAggregateInput
    generatedPays?: PayrollOrderByRelationAggregateInput
    performanceReviewsGiven?: PerformanceReviewOrderByRelationAggregateInput
    performanceReviewsGot?: PerformanceReviewOrderByRelationAggregateInput
    assetsOwned?: AssetOrderByRelationAggregateInput
    jobPosts?: JobPostOrderByRelationAggregateInput
    applications?: ApplicationOrderByRelationAggregateInput
    eventsOrganized?: CalendarEventOrderByRelationAggregateInput
    eventAttendees?: CalendarAttendeeOrderByRelationAggregateInput
    trainingEnrollments?: TrainingEnrollmentOrderByRelationAggregateInput
    announcementsMade?: AnnouncementOrderByRelationAggregateInput
    preferences?: UserPreferenceOrderByWithRelationInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    headedDepartments?: DepartmentOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    employment?: EnumEmploymentStatusFilter<"User"> | $Enums.EmploymentStatus
    phone?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    joinDate?: DateTimeNullableFilter<"User"> | Date | string | null
    salary?: DecimalNullableFilter<"User"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"User"> | string | null
    departmentId?: StringNullableFilter<"User"> | string | null
    managerId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    manager?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    reports?: UserListRelationFilter
    tasksCreated?: TaskListRelationFilter
    taskAssignments?: TaskAssignmentListRelationFilter
    taskComments?: TaskCommentListRelationFilter
    timeLogs?: TaskTimeLogListRelationFilter
    attendance?: AttendanceRecordListRelationFilter
    leaves?: LeaveListRelationFilter
    leavesToApprove?: LeaveListRelationFilter
    messagesSent?: ChatMessageListRelationFilter
    messagesRecv?: ChatMessageListRelationFilter
    chatGroups?: ChatGroupMemberListRelationFilter
    notifications?: NotificationListRelationFilter
    documents?: DocumentListRelationFilter
    companyDocs?: CompanyDocumentListRelationFilter
    expenses?: ExpenseListRelationFilter
    expensesApproved?: ExpenseListRelationFilter
    payrolls?: PayrollListRelationFilter
    generatedPays?: PayrollListRelationFilter
    performanceReviewsGiven?: PerformanceReviewListRelationFilter
    performanceReviewsGot?: PerformanceReviewListRelationFilter
    assetsOwned?: AssetListRelationFilter
    jobPosts?: JobPostListRelationFilter
    applications?: ApplicationListRelationFilter
    eventsOrganized?: CalendarEventListRelationFilter
    eventAttendees?: CalendarAttendeeListRelationFilter
    trainingEnrollments?: TrainingEnrollmentListRelationFilter
    announcementsMade?: AnnouncementListRelationFilter
    preferences?: XOR<UserPreferenceNullableScalarRelationFilter, UserPreferenceWhereInput> | null
    auditLogs?: AuditLogListRelationFilter
    headedDepartments?: DepartmentListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    employment?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    joinDate?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    employment?: EnumEmploymentStatusWithAggregatesFilter<"User"> | $Enums.EmploymentStatus
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    address?: StringNullableWithAggregatesFilter<"User"> | string | null
    joinDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    salary?: DecimalNullableWithAggregatesFilter<"User"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableWithAggregatesFilter<"User"> | string | null
    departmentId?: StringNullableWithAggregatesFilter<"User"> | string | null
    managerId?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    id?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    description?: StringNullableFilter<"Department"> | string | null
    headId?: StringNullableFilter<"Department"> | string | null
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    head?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    users?: UserListRelationFilter
    Announcement?: AnnouncementListRelationFilter
    JobPost?: JobPostListRelationFilter
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    headId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    head?: UserOrderByWithRelationInput
    users?: UserOrderByRelationAggregateInput
    Announcement?: AnnouncementOrderByRelationAggregateInput
    JobPost?: JobPostOrderByRelationAggregateInput
    _relevance?: DepartmentOrderByRelevanceInput
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    description?: StringNullableFilter<"Department"> | string | null
    headId?: StringNullableFilter<"Department"> | string | null
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    head?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    users?: UserListRelationFilter
    Announcement?: AnnouncementListRelationFilter
    JobPost?: JobPostListRelationFilter
  }, "id" | "name">

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    headId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Department"> | string
    name?: StringWithAggregatesFilter<"Department"> | string
    description?: StringNullableWithAggregatesFilter<"Department"> | string | null
    headId?: StringNullableWithAggregatesFilter<"Department"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    priority?: EnumTaskPriorityFilter<"Task"> | $Enums.TaskPriority
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    createdById?: StringFilter<"Task"> | string
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    assignments?: TaskAssignmentListRelationFilter
    comments?: TaskCommentListRelationFilter
    timeLogs?: TaskTimeLogListRelationFilter
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    priority?: SortOrder
    status?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    assignments?: TaskAssignmentOrderByRelationAggregateInput
    comments?: TaskCommentOrderByRelationAggregateInput
    timeLogs?: TaskTimeLogOrderByRelationAggregateInput
    _relevance?: TaskOrderByRelevanceInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    priority?: EnumTaskPriorityFilter<"Task"> | $Enums.TaskPriority
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    createdById?: StringFilter<"Task"> | string
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    assignments?: TaskAssignmentListRelationFilter
    comments?: TaskCommentListRelationFilter
    timeLogs?: TaskTimeLogListRelationFilter
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    priority?: SortOrder
    status?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaskCountOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Task"> | string
    title?: StringWithAggregatesFilter<"Task"> | string
    description?: StringNullableWithAggregatesFilter<"Task"> | string | null
    priority?: EnumTaskPriorityWithAggregatesFilter<"Task"> | $Enums.TaskPriority
    status?: EnumTaskStatusWithAggregatesFilter<"Task"> | $Enums.TaskStatus
    dueDate?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    createdById?: StringWithAggregatesFilter<"Task"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
  }

  export type TaskAssignmentWhereInput = {
    AND?: TaskAssignmentWhereInput | TaskAssignmentWhereInput[]
    OR?: TaskAssignmentWhereInput[]
    NOT?: TaskAssignmentWhereInput | TaskAssignmentWhereInput[]
    id?: StringFilter<"TaskAssignment"> | string
    userId?: StringFilter<"TaskAssignment"> | string
    taskId?: StringFilter<"TaskAssignment"> | string
    assignedAt?: DateTimeFilter<"TaskAssignment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }

  export type TaskAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    taskId?: SortOrder
    assignedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    task?: TaskOrderByWithRelationInput
    _relevance?: TaskAssignmentOrderByRelevanceInput
  }

  export type TaskAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_taskId?: TaskAssignmentUserIdTaskIdCompoundUniqueInput
    AND?: TaskAssignmentWhereInput | TaskAssignmentWhereInput[]
    OR?: TaskAssignmentWhereInput[]
    NOT?: TaskAssignmentWhereInput | TaskAssignmentWhereInput[]
    userId?: StringFilter<"TaskAssignment"> | string
    taskId?: StringFilter<"TaskAssignment"> | string
    assignedAt?: DateTimeFilter<"TaskAssignment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }, "id" | "userId_taskId">

  export type TaskAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    taskId?: SortOrder
    assignedAt?: SortOrder
    _count?: TaskAssignmentCountOrderByAggregateInput
    _max?: TaskAssignmentMaxOrderByAggregateInput
    _min?: TaskAssignmentMinOrderByAggregateInput
  }

  export type TaskAssignmentScalarWhereWithAggregatesInput = {
    AND?: TaskAssignmentScalarWhereWithAggregatesInput | TaskAssignmentScalarWhereWithAggregatesInput[]
    OR?: TaskAssignmentScalarWhereWithAggregatesInput[]
    NOT?: TaskAssignmentScalarWhereWithAggregatesInput | TaskAssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaskAssignment"> | string
    userId?: StringWithAggregatesFilter<"TaskAssignment"> | string
    taskId?: StringWithAggregatesFilter<"TaskAssignment"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"TaskAssignment"> | Date | string
  }

  export type TaskCommentWhereInput = {
    AND?: TaskCommentWhereInput | TaskCommentWhereInput[]
    OR?: TaskCommentWhereInput[]
    NOT?: TaskCommentWhereInput | TaskCommentWhereInput[]
    id?: StringFilter<"TaskComment"> | string
    taskId?: StringFilter<"TaskComment"> | string
    userId?: StringFilter<"TaskComment"> | string
    content?: StringFilter<"TaskComment"> | string
    createdAt?: DateTimeFilter<"TaskComment"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TaskCommentOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    task?: TaskOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    _relevance?: TaskCommentOrderByRelevanceInput
  }

  export type TaskCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskCommentWhereInput | TaskCommentWhereInput[]
    OR?: TaskCommentWhereInput[]
    NOT?: TaskCommentWhereInput | TaskCommentWhereInput[]
    taskId?: StringFilter<"TaskComment"> | string
    userId?: StringFilter<"TaskComment"> | string
    content?: StringFilter<"TaskComment"> | string
    createdAt?: DateTimeFilter<"TaskComment"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TaskCommentOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: TaskCommentCountOrderByAggregateInput
    _max?: TaskCommentMaxOrderByAggregateInput
    _min?: TaskCommentMinOrderByAggregateInput
  }

  export type TaskCommentScalarWhereWithAggregatesInput = {
    AND?: TaskCommentScalarWhereWithAggregatesInput | TaskCommentScalarWhereWithAggregatesInput[]
    OR?: TaskCommentScalarWhereWithAggregatesInput[]
    NOT?: TaskCommentScalarWhereWithAggregatesInput | TaskCommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaskComment"> | string
    taskId?: StringWithAggregatesFilter<"TaskComment"> | string
    userId?: StringWithAggregatesFilter<"TaskComment"> | string
    content?: StringWithAggregatesFilter<"TaskComment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TaskComment"> | Date | string
  }

  export type TaskTimeLogWhereInput = {
    AND?: TaskTimeLogWhereInput | TaskTimeLogWhereInput[]
    OR?: TaskTimeLogWhereInput[]
    NOT?: TaskTimeLogWhereInput | TaskTimeLogWhereInput[]
    id?: StringFilter<"TaskTimeLog"> | string
    taskId?: StringFilter<"TaskTimeLog"> | string
    userId?: StringFilter<"TaskTimeLog"> | string
    startedAt?: DateTimeFilter<"TaskTimeLog"> | Date | string
    endedAt?: DateTimeNullableFilter<"TaskTimeLog"> | Date | string | null
    durationSeconds?: IntNullableFilter<"TaskTimeLog"> | number | null
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TaskTimeLogOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    durationSeconds?: SortOrderInput | SortOrder
    task?: TaskOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    _relevance?: TaskTimeLogOrderByRelevanceInput
  }

  export type TaskTimeLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskTimeLogWhereInput | TaskTimeLogWhereInput[]
    OR?: TaskTimeLogWhereInput[]
    NOT?: TaskTimeLogWhereInput | TaskTimeLogWhereInput[]
    taskId?: StringFilter<"TaskTimeLog"> | string
    userId?: StringFilter<"TaskTimeLog"> | string
    startedAt?: DateTimeFilter<"TaskTimeLog"> | Date | string
    endedAt?: DateTimeNullableFilter<"TaskTimeLog"> | Date | string | null
    durationSeconds?: IntNullableFilter<"TaskTimeLog"> | number | null
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TaskTimeLogOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    durationSeconds?: SortOrderInput | SortOrder
    _count?: TaskTimeLogCountOrderByAggregateInput
    _avg?: TaskTimeLogAvgOrderByAggregateInput
    _max?: TaskTimeLogMaxOrderByAggregateInput
    _min?: TaskTimeLogMinOrderByAggregateInput
    _sum?: TaskTimeLogSumOrderByAggregateInput
  }

  export type TaskTimeLogScalarWhereWithAggregatesInput = {
    AND?: TaskTimeLogScalarWhereWithAggregatesInput | TaskTimeLogScalarWhereWithAggregatesInput[]
    OR?: TaskTimeLogScalarWhereWithAggregatesInput[]
    NOT?: TaskTimeLogScalarWhereWithAggregatesInput | TaskTimeLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaskTimeLog"> | string
    taskId?: StringWithAggregatesFilter<"TaskTimeLog"> | string
    userId?: StringWithAggregatesFilter<"TaskTimeLog"> | string
    startedAt?: DateTimeWithAggregatesFilter<"TaskTimeLog"> | Date | string
    endedAt?: DateTimeNullableWithAggregatesFilter<"TaskTimeLog"> | Date | string | null
    durationSeconds?: IntNullableWithAggregatesFilter<"TaskTimeLog"> | number | null
  }

  export type AttendanceRecordWhereInput = {
    AND?: AttendanceRecordWhereInput | AttendanceRecordWhereInput[]
    OR?: AttendanceRecordWhereInput[]
    NOT?: AttendanceRecordWhereInput | AttendanceRecordWhereInput[]
    id?: StringFilter<"AttendanceRecord"> | string
    userId?: StringFilter<"AttendanceRecord"> | string
    date?: DateTimeFilter<"AttendanceRecord"> | Date | string
    clockIn?: DateTimeNullableFilter<"AttendanceRecord"> | Date | string | null
    clockOut?: DateTimeNullableFilter<"AttendanceRecord"> | Date | string | null
    status?: EnumAttendanceStatusFilter<"AttendanceRecord"> | $Enums.AttendanceStatus
    ipAddress?: StringNullableFilter<"AttendanceRecord"> | string | null
    location?: StringNullableFilter<"AttendanceRecord"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AttendanceRecordOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    clockIn?: SortOrderInput | SortOrder
    clockOut?: SortOrderInput | SortOrder
    status?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: AttendanceRecordOrderByRelevanceInput
  }

  export type AttendanceRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_date?: AttendanceRecordUserIdDateCompoundUniqueInput
    AND?: AttendanceRecordWhereInput | AttendanceRecordWhereInput[]
    OR?: AttendanceRecordWhereInput[]
    NOT?: AttendanceRecordWhereInput | AttendanceRecordWhereInput[]
    userId?: StringFilter<"AttendanceRecord"> | string
    date?: DateTimeFilter<"AttendanceRecord"> | Date | string
    clockIn?: DateTimeNullableFilter<"AttendanceRecord"> | Date | string | null
    clockOut?: DateTimeNullableFilter<"AttendanceRecord"> | Date | string | null
    status?: EnumAttendanceStatusFilter<"AttendanceRecord"> | $Enums.AttendanceStatus
    ipAddress?: StringNullableFilter<"AttendanceRecord"> | string | null
    location?: StringNullableFilter<"AttendanceRecord"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_date">

  export type AttendanceRecordOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    clockIn?: SortOrderInput | SortOrder
    clockOut?: SortOrderInput | SortOrder
    status?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    _count?: AttendanceRecordCountOrderByAggregateInput
    _max?: AttendanceRecordMaxOrderByAggregateInput
    _min?: AttendanceRecordMinOrderByAggregateInput
  }

  export type AttendanceRecordScalarWhereWithAggregatesInput = {
    AND?: AttendanceRecordScalarWhereWithAggregatesInput | AttendanceRecordScalarWhereWithAggregatesInput[]
    OR?: AttendanceRecordScalarWhereWithAggregatesInput[]
    NOT?: AttendanceRecordScalarWhereWithAggregatesInput | AttendanceRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AttendanceRecord"> | string
    userId?: StringWithAggregatesFilter<"AttendanceRecord"> | string
    date?: DateTimeWithAggregatesFilter<"AttendanceRecord"> | Date | string
    clockIn?: DateTimeNullableWithAggregatesFilter<"AttendanceRecord"> | Date | string | null
    clockOut?: DateTimeNullableWithAggregatesFilter<"AttendanceRecord"> | Date | string | null
    status?: EnumAttendanceStatusWithAggregatesFilter<"AttendanceRecord"> | $Enums.AttendanceStatus
    ipAddress?: StringNullableWithAggregatesFilter<"AttendanceRecord"> | string | null
    location?: StringNullableWithAggregatesFilter<"AttendanceRecord"> | string | null
  }

  export type LeaveWhereInput = {
    AND?: LeaveWhereInput | LeaveWhereInput[]
    OR?: LeaveWhereInput[]
    NOT?: LeaveWhereInput | LeaveWhereInput[]
    id?: StringFilter<"Leave"> | string
    userId?: StringFilter<"Leave"> | string
    startDate?: DateTimeFilter<"Leave"> | Date | string
    endDate?: DateTimeFilter<"Leave"> | Date | string
    reason?: StringNullableFilter<"Leave"> | string | null
    status?: EnumLeaveStatusFilter<"Leave"> | $Enums.LeaveStatus
    approverId?: StringNullableFilter<"Leave"> | string | null
    createdAt?: DateTimeFilter<"Leave"> | Date | string
    updatedAt?: DateTimeFilter<"Leave"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type LeaveOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    approverId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    approver?: UserOrderByWithRelationInput
    _relevance?: LeaveOrderByRelevanceInput
  }

  export type LeaveWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeaveWhereInput | LeaveWhereInput[]
    OR?: LeaveWhereInput[]
    NOT?: LeaveWhereInput | LeaveWhereInput[]
    userId?: StringFilter<"Leave"> | string
    startDate?: DateTimeFilter<"Leave"> | Date | string
    endDate?: DateTimeFilter<"Leave"> | Date | string
    reason?: StringNullableFilter<"Leave"> | string | null
    status?: EnumLeaveStatusFilter<"Leave"> | $Enums.LeaveStatus
    approverId?: StringNullableFilter<"Leave"> | string | null
    createdAt?: DateTimeFilter<"Leave"> | Date | string
    updatedAt?: DateTimeFilter<"Leave"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type LeaveOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    approverId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeaveCountOrderByAggregateInput
    _max?: LeaveMaxOrderByAggregateInput
    _min?: LeaveMinOrderByAggregateInput
  }

  export type LeaveScalarWhereWithAggregatesInput = {
    AND?: LeaveScalarWhereWithAggregatesInput | LeaveScalarWhereWithAggregatesInput[]
    OR?: LeaveScalarWhereWithAggregatesInput[]
    NOT?: LeaveScalarWhereWithAggregatesInput | LeaveScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Leave"> | string
    userId?: StringWithAggregatesFilter<"Leave"> | string
    startDate?: DateTimeWithAggregatesFilter<"Leave"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Leave"> | Date | string
    reason?: StringNullableWithAggregatesFilter<"Leave"> | string | null
    status?: EnumLeaveStatusWithAggregatesFilter<"Leave"> | $Enums.LeaveStatus
    approverId?: StringNullableWithAggregatesFilter<"Leave"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Leave"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Leave"> | Date | string
  }

  export type ChatMessageWhereInput = {
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    id?: StringFilter<"ChatMessage"> | string
    senderId?: StringFilter<"ChatMessage"> | string
    receiverId?: StringNullableFilter<"ChatMessage"> | string | null
    groupId?: StringNullableFilter<"ChatMessage"> | string | null
    content?: StringFilter<"ChatMessage"> | string
    timestamp?: DateTimeFilter<"ChatMessage"> | Date | string
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    receiver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    group?: XOR<ChatGroupNullableScalarRelationFilter, ChatGroupWhereInput> | null
  }

  export type ChatMessageOrderByWithRelationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrderInput | SortOrder
    groupId?: SortOrderInput | SortOrder
    content?: SortOrder
    timestamp?: SortOrder
    sender?: UserOrderByWithRelationInput
    receiver?: UserOrderByWithRelationInput
    group?: ChatGroupOrderByWithRelationInput
    _relevance?: ChatMessageOrderByRelevanceInput
  }

  export type ChatMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    senderId?: StringFilter<"ChatMessage"> | string
    receiverId?: StringNullableFilter<"ChatMessage"> | string | null
    groupId?: StringNullableFilter<"ChatMessage"> | string | null
    content?: StringFilter<"ChatMessage"> | string
    timestamp?: DateTimeFilter<"ChatMessage"> | Date | string
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    receiver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    group?: XOR<ChatGroupNullableScalarRelationFilter, ChatGroupWhereInput> | null
  }, "id">

  export type ChatMessageOrderByWithAggregationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrderInput | SortOrder
    groupId?: SortOrderInput | SortOrder
    content?: SortOrder
    timestamp?: SortOrder
    _count?: ChatMessageCountOrderByAggregateInput
    _max?: ChatMessageMaxOrderByAggregateInput
    _min?: ChatMessageMinOrderByAggregateInput
  }

  export type ChatMessageScalarWhereWithAggregatesInput = {
    AND?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    OR?: ChatMessageScalarWhereWithAggregatesInput[]
    NOT?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChatMessage"> | string
    senderId?: StringWithAggregatesFilter<"ChatMessage"> | string
    receiverId?: StringNullableWithAggregatesFilter<"ChatMessage"> | string | null
    groupId?: StringNullableWithAggregatesFilter<"ChatMessage"> | string | null
    content?: StringWithAggregatesFilter<"ChatMessage"> | string
    timestamp?: DateTimeWithAggregatesFilter<"ChatMessage"> | Date | string
  }

  export type ChatGroupWhereInput = {
    AND?: ChatGroupWhereInput | ChatGroupWhereInput[]
    OR?: ChatGroupWhereInput[]
    NOT?: ChatGroupWhereInput | ChatGroupWhereInput[]
    id?: StringFilter<"ChatGroup"> | string
    name?: StringFilter<"ChatGroup"> | string
    createdAt?: DateTimeFilter<"ChatGroup"> | Date | string
    messages?: ChatMessageListRelationFilter
    members?: ChatGroupMemberListRelationFilter
  }

  export type ChatGroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    messages?: ChatMessageOrderByRelationAggregateInput
    members?: ChatGroupMemberOrderByRelationAggregateInput
    _relevance?: ChatGroupOrderByRelevanceInput
  }

  export type ChatGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatGroupWhereInput | ChatGroupWhereInput[]
    OR?: ChatGroupWhereInput[]
    NOT?: ChatGroupWhereInput | ChatGroupWhereInput[]
    name?: StringFilter<"ChatGroup"> | string
    createdAt?: DateTimeFilter<"ChatGroup"> | Date | string
    messages?: ChatMessageListRelationFilter
    members?: ChatGroupMemberListRelationFilter
  }, "id">

  export type ChatGroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    _count?: ChatGroupCountOrderByAggregateInput
    _max?: ChatGroupMaxOrderByAggregateInput
    _min?: ChatGroupMinOrderByAggregateInput
  }

  export type ChatGroupScalarWhereWithAggregatesInput = {
    AND?: ChatGroupScalarWhereWithAggregatesInput | ChatGroupScalarWhereWithAggregatesInput[]
    OR?: ChatGroupScalarWhereWithAggregatesInput[]
    NOT?: ChatGroupScalarWhereWithAggregatesInput | ChatGroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChatGroup"> | string
    name?: StringWithAggregatesFilter<"ChatGroup"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ChatGroup"> | Date | string
  }

  export type ChatGroupMemberWhereInput = {
    AND?: ChatGroupMemberWhereInput | ChatGroupMemberWhereInput[]
    OR?: ChatGroupMemberWhereInput[]
    NOT?: ChatGroupMemberWhereInput | ChatGroupMemberWhereInput[]
    id?: StringFilter<"ChatGroupMember"> | string
    groupId?: StringFilter<"ChatGroupMember"> | string
    userId?: StringFilter<"ChatGroupMember"> | string
    joinedAt?: DateTimeFilter<"ChatGroupMember"> | Date | string
    group?: XOR<ChatGroupScalarRelationFilter, ChatGroupWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ChatGroupMemberOrderByWithRelationInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
    group?: ChatGroupOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    _relevance?: ChatGroupMemberOrderByRelevanceInput
  }

  export type ChatGroupMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    groupId_userId?: ChatGroupMemberGroupIdUserIdCompoundUniqueInput
    AND?: ChatGroupMemberWhereInput | ChatGroupMemberWhereInput[]
    OR?: ChatGroupMemberWhereInput[]
    NOT?: ChatGroupMemberWhereInput | ChatGroupMemberWhereInput[]
    groupId?: StringFilter<"ChatGroupMember"> | string
    userId?: StringFilter<"ChatGroupMember"> | string
    joinedAt?: DateTimeFilter<"ChatGroupMember"> | Date | string
    group?: XOR<ChatGroupScalarRelationFilter, ChatGroupWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "groupId_userId">

  export type ChatGroupMemberOrderByWithAggregationInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
    _count?: ChatGroupMemberCountOrderByAggregateInput
    _max?: ChatGroupMemberMaxOrderByAggregateInput
    _min?: ChatGroupMemberMinOrderByAggregateInput
  }

  export type ChatGroupMemberScalarWhereWithAggregatesInput = {
    AND?: ChatGroupMemberScalarWhereWithAggregatesInput | ChatGroupMemberScalarWhereWithAggregatesInput[]
    OR?: ChatGroupMemberScalarWhereWithAggregatesInput[]
    NOT?: ChatGroupMemberScalarWhereWithAggregatesInput | ChatGroupMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChatGroupMember"> | string
    groupId?: StringWithAggregatesFilter<"ChatGroupMember"> | string
    userId?: StringWithAggregatesFilter<"ChatGroupMember"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"ChatGroupMember"> | Date | string
  }

  export type AnnouncementWhereInput = {
    AND?: AnnouncementWhereInput | AnnouncementWhereInput[]
    OR?: AnnouncementWhereInput[]
    NOT?: AnnouncementWhereInput | AnnouncementWhereInput[]
    id?: StringFilter<"Announcement"> | string
    title?: StringFilter<"Announcement"> | string
    content?: StringFilter<"Announcement"> | string
    authorId?: StringFilter<"Announcement"> | string
    departmentId?: StringNullableFilter<"Announcement"> | string | null
    createdAt?: DateTimeFilter<"Announcement"> | Date | string
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
  }

  export type AnnouncementOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    author?: UserOrderByWithRelationInput
    department?: DepartmentOrderByWithRelationInput
    _relevance?: AnnouncementOrderByRelevanceInput
  }

  export type AnnouncementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnnouncementWhereInput | AnnouncementWhereInput[]
    OR?: AnnouncementWhereInput[]
    NOT?: AnnouncementWhereInput | AnnouncementWhereInput[]
    title?: StringFilter<"Announcement"> | string
    content?: StringFilter<"Announcement"> | string
    authorId?: StringFilter<"Announcement"> | string
    departmentId?: StringNullableFilter<"Announcement"> | string | null
    createdAt?: DateTimeFilter<"Announcement"> | Date | string
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
  }, "id">

  export type AnnouncementOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AnnouncementCountOrderByAggregateInput
    _max?: AnnouncementMaxOrderByAggregateInput
    _min?: AnnouncementMinOrderByAggregateInput
  }

  export type AnnouncementScalarWhereWithAggregatesInput = {
    AND?: AnnouncementScalarWhereWithAggregatesInput | AnnouncementScalarWhereWithAggregatesInput[]
    OR?: AnnouncementScalarWhereWithAggregatesInput[]
    NOT?: AnnouncementScalarWhereWithAggregatesInput | AnnouncementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Announcement"> | string
    title?: StringWithAggregatesFilter<"Announcement"> | string
    content?: StringWithAggregatesFilter<"Announcement"> | string
    authorId?: StringWithAggregatesFilter<"Announcement"> | string
    departmentId?: StringNullableWithAggregatesFilter<"Announcement"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Announcement"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    data?: JsonNullableFilter<"Notification">
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    data?: SortOrderInput | SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: NotificationOrderByRelevanceInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    data?: JsonNullableFilter<"Notification">
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    data?: SortOrderInput | SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    data?: JsonNullableWithAggregatesFilter<"Notification">
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    userId?: StringFilter<"Document"> | string
    title?: StringFilter<"Document"> | string
    fileUrl?: StringFilter<"Document"> | string
    createdAt?: DateTimeFilter<"Document"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    fileUrl?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: DocumentOrderByRelevanceInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    userId?: StringFilter<"Document"> | string
    title?: StringFilter<"Document"> | string
    fileUrl?: StringFilter<"Document"> | string
    createdAt?: DateTimeFilter<"Document"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    fileUrl?: SortOrder
    createdAt?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    userId?: StringWithAggregatesFilter<"Document"> | string
    title?: StringWithAggregatesFilter<"Document"> | string
    fileUrl?: StringWithAggregatesFilter<"Document"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
  }

  export type CompanyDocumentWhereInput = {
    AND?: CompanyDocumentWhereInput | CompanyDocumentWhereInput[]
    OR?: CompanyDocumentWhereInput[]
    NOT?: CompanyDocumentWhereInput | CompanyDocumentWhereInput[]
    id?: StringFilter<"CompanyDocument"> | string
    title?: StringFilter<"CompanyDocument"> | string
    description?: StringNullableFilter<"CompanyDocument"> | string | null
    fileUrl?: StringFilter<"CompanyDocument"> | string
    uploadedBy?: StringFilter<"CompanyDocument"> | string
    createdAt?: DateTimeFilter<"CompanyDocument"> | Date | string
    uploader?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CompanyDocumentOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    fileUrl?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    uploader?: UserOrderByWithRelationInput
    _relevance?: CompanyDocumentOrderByRelevanceInput
  }

  export type CompanyDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CompanyDocumentWhereInput | CompanyDocumentWhereInput[]
    OR?: CompanyDocumentWhereInput[]
    NOT?: CompanyDocumentWhereInput | CompanyDocumentWhereInput[]
    title?: StringFilter<"CompanyDocument"> | string
    description?: StringNullableFilter<"CompanyDocument"> | string | null
    fileUrl?: StringFilter<"CompanyDocument"> | string
    uploadedBy?: StringFilter<"CompanyDocument"> | string
    createdAt?: DateTimeFilter<"CompanyDocument"> | Date | string
    uploader?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CompanyDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    fileUrl?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    _count?: CompanyDocumentCountOrderByAggregateInput
    _max?: CompanyDocumentMaxOrderByAggregateInput
    _min?: CompanyDocumentMinOrderByAggregateInput
  }

  export type CompanyDocumentScalarWhereWithAggregatesInput = {
    AND?: CompanyDocumentScalarWhereWithAggregatesInput | CompanyDocumentScalarWhereWithAggregatesInput[]
    OR?: CompanyDocumentScalarWhereWithAggregatesInput[]
    NOT?: CompanyDocumentScalarWhereWithAggregatesInput | CompanyDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CompanyDocument"> | string
    title?: StringWithAggregatesFilter<"CompanyDocument"> | string
    description?: StringNullableWithAggregatesFilter<"CompanyDocument"> | string | null
    fileUrl?: StringWithAggregatesFilter<"CompanyDocument"> | string
    uploadedBy?: StringWithAggregatesFilter<"CompanyDocument"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CompanyDocument"> | Date | string
  }

  export type ExpenseWhereInput = {
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    id?: StringFilter<"Expense"> | string
    userId?: StringFilter<"Expense"> | string
    title?: StringFilter<"Expense"> | string
    description?: StringNullableFilter<"Expense"> | string | null
    category?: StringNullableFilter<"Expense"> | string | null
    amount?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Expense"> | string
    date?: DateTimeFilter<"Expense"> | Date | string
    status?: EnumExpenseStatusFilter<"Expense"> | $Enums.ExpenseStatus
    receiptUrl?: StringNullableFilter<"Expense"> | string | null
    submittedAt?: DateTimeFilter<"Expense"> | Date | string
    approvedAt?: DateTimeNullableFilter<"Expense"> | Date | string | null
    approvedById?: StringNullableFilter<"Expense"> | string | null
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ExpenseOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    date?: SortOrder
    status?: SortOrder
    receiptUrl?: SortOrderInput | SortOrder
    submittedAt?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    approvedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    approver?: UserOrderByWithRelationInput
    _relevance?: ExpenseOrderByRelevanceInput
  }

  export type ExpenseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    userId?: StringFilter<"Expense"> | string
    title?: StringFilter<"Expense"> | string
    description?: StringNullableFilter<"Expense"> | string | null
    category?: StringNullableFilter<"Expense"> | string | null
    amount?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Expense"> | string
    date?: DateTimeFilter<"Expense"> | Date | string
    status?: EnumExpenseStatusFilter<"Expense"> | $Enums.ExpenseStatus
    receiptUrl?: StringNullableFilter<"Expense"> | string | null
    submittedAt?: DateTimeFilter<"Expense"> | Date | string
    approvedAt?: DateTimeNullableFilter<"Expense"> | Date | string | null
    approvedById?: StringNullableFilter<"Expense"> | string | null
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type ExpenseOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    date?: SortOrder
    status?: SortOrder
    receiptUrl?: SortOrderInput | SortOrder
    submittedAt?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    approvedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExpenseCountOrderByAggregateInput
    _avg?: ExpenseAvgOrderByAggregateInput
    _max?: ExpenseMaxOrderByAggregateInput
    _min?: ExpenseMinOrderByAggregateInput
    _sum?: ExpenseSumOrderByAggregateInput
  }

  export type ExpenseScalarWhereWithAggregatesInput = {
    AND?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    OR?: ExpenseScalarWhereWithAggregatesInput[]
    NOT?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Expense"> | string
    userId?: StringWithAggregatesFilter<"Expense"> | string
    title?: StringWithAggregatesFilter<"Expense"> | string
    description?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    category?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    amount?: DecimalWithAggregatesFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Expense"> | string
    date?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    status?: EnumExpenseStatusWithAggregatesFilter<"Expense"> | $Enums.ExpenseStatus
    receiptUrl?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    submittedAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Expense"> | Date | string | null
    approvedById?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
  }

  export type AssetWhereInput = {
    AND?: AssetWhereInput | AssetWhereInput[]
    OR?: AssetWhereInput[]
    NOT?: AssetWhereInput | AssetWhereInput[]
    id?: StringFilter<"Asset"> | string
    tag?: StringFilter<"Asset"> | string
    name?: StringFilter<"Asset"> | string
    type?: StringNullableFilter<"Asset"> | string | null
    serialNumber?: StringNullableFilter<"Asset"> | string | null
    purchaseDate?: DateTimeNullableFilter<"Asset"> | Date | string | null
    status?: EnumAssetStatusFilter<"Asset"> | $Enums.AssetStatus
    assignedToId?: StringNullableFilter<"Asset"> | string | null
    assignedAt?: DateTimeNullableFilter<"Asset"> | Date | string | null
    location?: StringNullableFilter<"Asset"> | string | null
    notes?: StringNullableFilter<"Asset"> | string | null
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    updatedAt?: DateTimeFilter<"Asset"> | Date | string
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AssetOrderByWithRelationInput = {
    id?: SortOrder
    tag?: SortOrder
    name?: SortOrder
    type?: SortOrderInput | SortOrder
    serialNumber?: SortOrderInput | SortOrder
    purchaseDate?: SortOrderInput | SortOrder
    status?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    assignedAt?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedTo?: UserOrderByWithRelationInput
    _relevance?: AssetOrderByRelevanceInput
  }

  export type AssetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tag?: string
    serialNumber?: string
    AND?: AssetWhereInput | AssetWhereInput[]
    OR?: AssetWhereInput[]
    NOT?: AssetWhereInput | AssetWhereInput[]
    name?: StringFilter<"Asset"> | string
    type?: StringNullableFilter<"Asset"> | string | null
    purchaseDate?: DateTimeNullableFilter<"Asset"> | Date | string | null
    status?: EnumAssetStatusFilter<"Asset"> | $Enums.AssetStatus
    assignedToId?: StringNullableFilter<"Asset"> | string | null
    assignedAt?: DateTimeNullableFilter<"Asset"> | Date | string | null
    location?: StringNullableFilter<"Asset"> | string | null
    notes?: StringNullableFilter<"Asset"> | string | null
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    updatedAt?: DateTimeFilter<"Asset"> | Date | string
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "tag" | "serialNumber">

  export type AssetOrderByWithAggregationInput = {
    id?: SortOrder
    tag?: SortOrder
    name?: SortOrder
    type?: SortOrderInput | SortOrder
    serialNumber?: SortOrderInput | SortOrder
    purchaseDate?: SortOrderInput | SortOrder
    status?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    assignedAt?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AssetCountOrderByAggregateInput
    _max?: AssetMaxOrderByAggregateInput
    _min?: AssetMinOrderByAggregateInput
  }

  export type AssetScalarWhereWithAggregatesInput = {
    AND?: AssetScalarWhereWithAggregatesInput | AssetScalarWhereWithAggregatesInput[]
    OR?: AssetScalarWhereWithAggregatesInput[]
    NOT?: AssetScalarWhereWithAggregatesInput | AssetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Asset"> | string
    tag?: StringWithAggregatesFilter<"Asset"> | string
    name?: StringWithAggregatesFilter<"Asset"> | string
    type?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    serialNumber?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    purchaseDate?: DateTimeNullableWithAggregatesFilter<"Asset"> | Date | string | null
    status?: EnumAssetStatusWithAggregatesFilter<"Asset"> | $Enums.AssetStatus
    assignedToId?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    assignedAt?: DateTimeNullableWithAggregatesFilter<"Asset"> | Date | string | null
    location?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Asset"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Asset"> | Date | string
  }

  export type PayrollWhereInput = {
    AND?: PayrollWhereInput | PayrollWhereInput[]
    OR?: PayrollWhereInput[]
    NOT?: PayrollWhereInput | PayrollWhereInput[]
    id?: StringFilter<"Payroll"> | string
    userId?: StringFilter<"Payroll"> | string
    month?: IntFilter<"Payroll"> | number
    year?: IntFilter<"Payroll"> | number
    baseSalary?: DecimalFilter<"Payroll"> | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFilter<"Payroll"> | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFilter<"Payroll"> | Decimal | DecimalJsLike | number | string
    netPay?: DecimalFilter<"Payroll"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payroll"> | string
    status?: EnumPayrollStatusFilter<"Payroll"> | $Enums.PayrollStatus
    generatedById?: StringNullableFilter<"Payroll"> | string | null
    generatedAt?: DateTimeNullableFilter<"Payroll"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"Payroll"> | Date | string | null
    slipUrl?: StringNullableFilter<"Payroll"> | string | null
    createdAt?: DateTimeFilter<"Payroll"> | Date | string
    updatedAt?: DateTimeFilter<"Payroll"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    generatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type PayrollOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    baseSalary?: SortOrder
    allowances?: SortOrder
    deductions?: SortOrder
    netPay?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    generatedById?: SortOrderInput | SortOrder
    generatedAt?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    slipUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    generatedBy?: UserOrderByWithRelationInput
    _relevance?: PayrollOrderByRelevanceInput
  }

  export type PayrollWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_month_year?: PayrollUserIdMonthYearCompoundUniqueInput
    AND?: PayrollWhereInput | PayrollWhereInput[]
    OR?: PayrollWhereInput[]
    NOT?: PayrollWhereInput | PayrollWhereInput[]
    userId?: StringFilter<"Payroll"> | string
    month?: IntFilter<"Payroll"> | number
    year?: IntFilter<"Payroll"> | number
    baseSalary?: DecimalFilter<"Payroll"> | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFilter<"Payroll"> | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFilter<"Payroll"> | Decimal | DecimalJsLike | number | string
    netPay?: DecimalFilter<"Payroll"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payroll"> | string
    status?: EnumPayrollStatusFilter<"Payroll"> | $Enums.PayrollStatus
    generatedById?: StringNullableFilter<"Payroll"> | string | null
    generatedAt?: DateTimeNullableFilter<"Payroll"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"Payroll"> | Date | string | null
    slipUrl?: StringNullableFilter<"Payroll"> | string | null
    createdAt?: DateTimeFilter<"Payroll"> | Date | string
    updatedAt?: DateTimeFilter<"Payroll"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    generatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "userId_month_year">

  export type PayrollOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    baseSalary?: SortOrder
    allowances?: SortOrder
    deductions?: SortOrder
    netPay?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    generatedById?: SortOrderInput | SortOrder
    generatedAt?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    slipUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PayrollCountOrderByAggregateInput
    _avg?: PayrollAvgOrderByAggregateInput
    _max?: PayrollMaxOrderByAggregateInput
    _min?: PayrollMinOrderByAggregateInput
    _sum?: PayrollSumOrderByAggregateInput
  }

  export type PayrollScalarWhereWithAggregatesInput = {
    AND?: PayrollScalarWhereWithAggregatesInput | PayrollScalarWhereWithAggregatesInput[]
    OR?: PayrollScalarWhereWithAggregatesInput[]
    NOT?: PayrollScalarWhereWithAggregatesInput | PayrollScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payroll"> | string
    userId?: StringWithAggregatesFilter<"Payroll"> | string
    month?: IntWithAggregatesFilter<"Payroll"> | number
    year?: IntWithAggregatesFilter<"Payroll"> | number
    baseSalary?: DecimalWithAggregatesFilter<"Payroll"> | Decimal | DecimalJsLike | number | string
    allowances?: DecimalWithAggregatesFilter<"Payroll"> | Decimal | DecimalJsLike | number | string
    deductions?: DecimalWithAggregatesFilter<"Payroll"> | Decimal | DecimalJsLike | number | string
    netPay?: DecimalWithAggregatesFilter<"Payroll"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Payroll"> | string
    status?: EnumPayrollStatusWithAggregatesFilter<"Payroll"> | $Enums.PayrollStatus
    generatedById?: StringNullableWithAggregatesFilter<"Payroll"> | string | null
    generatedAt?: DateTimeNullableWithAggregatesFilter<"Payroll"> | Date | string | null
    paidAt?: DateTimeNullableWithAggregatesFilter<"Payroll"> | Date | string | null
    slipUrl?: StringNullableWithAggregatesFilter<"Payroll"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payroll"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payroll"> | Date | string
  }

  export type PerformanceReviewWhereInput = {
    AND?: PerformanceReviewWhereInput | PerformanceReviewWhereInput[]
    OR?: PerformanceReviewWhereInput[]
    NOT?: PerformanceReviewWhereInput | PerformanceReviewWhereInput[]
    id?: StringFilter<"PerformanceReview"> | string
    revieweeId?: StringFilter<"PerformanceReview"> | string
    reviewerId?: StringFilter<"PerformanceReview"> | string
    periodStart?: DateTimeFilter<"PerformanceReview"> | Date | string
    periodEnd?: DateTimeFilter<"PerformanceReview"> | Date | string
    overallScore?: IntFilter<"PerformanceReview"> | number
    kpiScores?: JsonNullableFilter<"PerformanceReview">
    feedback?: StringNullableFilter<"PerformanceReview"> | string | null
    createdAt?: DateTimeFilter<"PerformanceReview"> | Date | string
    reviewee?: XOR<UserScalarRelationFilter, UserWhereInput>
    reviewer?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PerformanceReviewOrderByWithRelationInput = {
    id?: SortOrder
    revieweeId?: SortOrder
    reviewerId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    overallScore?: SortOrder
    kpiScores?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    reviewee?: UserOrderByWithRelationInput
    reviewer?: UserOrderByWithRelationInput
    _relevance?: PerformanceReviewOrderByRelevanceInput
  }

  export type PerformanceReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PerformanceReviewWhereInput | PerformanceReviewWhereInput[]
    OR?: PerformanceReviewWhereInput[]
    NOT?: PerformanceReviewWhereInput | PerformanceReviewWhereInput[]
    revieweeId?: StringFilter<"PerformanceReview"> | string
    reviewerId?: StringFilter<"PerformanceReview"> | string
    periodStart?: DateTimeFilter<"PerformanceReview"> | Date | string
    periodEnd?: DateTimeFilter<"PerformanceReview"> | Date | string
    overallScore?: IntFilter<"PerformanceReview"> | number
    kpiScores?: JsonNullableFilter<"PerformanceReview">
    feedback?: StringNullableFilter<"PerformanceReview"> | string | null
    createdAt?: DateTimeFilter<"PerformanceReview"> | Date | string
    reviewee?: XOR<UserScalarRelationFilter, UserWhereInput>
    reviewer?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PerformanceReviewOrderByWithAggregationInput = {
    id?: SortOrder
    revieweeId?: SortOrder
    reviewerId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    overallScore?: SortOrder
    kpiScores?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PerformanceReviewCountOrderByAggregateInput
    _avg?: PerformanceReviewAvgOrderByAggregateInput
    _max?: PerformanceReviewMaxOrderByAggregateInput
    _min?: PerformanceReviewMinOrderByAggregateInput
    _sum?: PerformanceReviewSumOrderByAggregateInput
  }

  export type PerformanceReviewScalarWhereWithAggregatesInput = {
    AND?: PerformanceReviewScalarWhereWithAggregatesInput | PerformanceReviewScalarWhereWithAggregatesInput[]
    OR?: PerformanceReviewScalarWhereWithAggregatesInput[]
    NOT?: PerformanceReviewScalarWhereWithAggregatesInput | PerformanceReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PerformanceReview"> | string
    revieweeId?: StringWithAggregatesFilter<"PerformanceReview"> | string
    reviewerId?: StringWithAggregatesFilter<"PerformanceReview"> | string
    periodStart?: DateTimeWithAggregatesFilter<"PerformanceReview"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"PerformanceReview"> | Date | string
    overallScore?: IntWithAggregatesFilter<"PerformanceReview"> | number
    kpiScores?: JsonNullableWithAggregatesFilter<"PerformanceReview">
    feedback?: StringNullableWithAggregatesFilter<"PerformanceReview"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PerformanceReview"> | Date | string
  }

  export type JobPostWhereInput = {
    AND?: JobPostWhereInput | JobPostWhereInput[]
    OR?: JobPostWhereInput[]
    NOT?: JobPostWhereInput | JobPostWhereInput[]
    id?: StringFilter<"JobPost"> | string
    title?: StringFilter<"JobPost"> | string
    departmentId?: StringNullableFilter<"JobPost"> | string | null
    type?: EnumJobTypeFilter<"JobPost"> | $Enums.JobType
    location?: StringNullableFilter<"JobPost"> | string | null
    description?: StringNullableFilter<"JobPost"> | string | null
    postedById?: StringFilter<"JobPost"> | string
    isActive?: BoolFilter<"JobPost"> | boolean
    createdAt?: DateTimeFilter<"JobPost"> | Date | string
    updatedAt?: DateTimeFilter<"JobPost"> | Date | string
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    postedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    applications?: ApplicationListRelationFilter
  }

  export type JobPostOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    type?: SortOrder
    location?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    postedById?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    department?: DepartmentOrderByWithRelationInput
    postedBy?: UserOrderByWithRelationInput
    applications?: ApplicationOrderByRelationAggregateInput
    _relevance?: JobPostOrderByRelevanceInput
  }

  export type JobPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JobPostWhereInput | JobPostWhereInput[]
    OR?: JobPostWhereInput[]
    NOT?: JobPostWhereInput | JobPostWhereInput[]
    title?: StringFilter<"JobPost"> | string
    departmentId?: StringNullableFilter<"JobPost"> | string | null
    type?: EnumJobTypeFilter<"JobPost"> | $Enums.JobType
    location?: StringNullableFilter<"JobPost"> | string | null
    description?: StringNullableFilter<"JobPost"> | string | null
    postedById?: StringFilter<"JobPost"> | string
    isActive?: BoolFilter<"JobPost"> | boolean
    createdAt?: DateTimeFilter<"JobPost"> | Date | string
    updatedAt?: DateTimeFilter<"JobPost"> | Date | string
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    postedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    applications?: ApplicationListRelationFilter
  }, "id">

  export type JobPostOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    type?: SortOrder
    location?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    postedById?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: JobPostCountOrderByAggregateInput
    _max?: JobPostMaxOrderByAggregateInput
    _min?: JobPostMinOrderByAggregateInput
  }

  export type JobPostScalarWhereWithAggregatesInput = {
    AND?: JobPostScalarWhereWithAggregatesInput | JobPostScalarWhereWithAggregatesInput[]
    OR?: JobPostScalarWhereWithAggregatesInput[]
    NOT?: JobPostScalarWhereWithAggregatesInput | JobPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JobPost"> | string
    title?: StringWithAggregatesFilter<"JobPost"> | string
    departmentId?: StringNullableWithAggregatesFilter<"JobPost"> | string | null
    type?: EnumJobTypeWithAggregatesFilter<"JobPost"> | $Enums.JobType
    location?: StringNullableWithAggregatesFilter<"JobPost"> | string | null
    description?: StringNullableWithAggregatesFilter<"JobPost"> | string | null
    postedById?: StringWithAggregatesFilter<"JobPost"> | string
    isActive?: BoolWithAggregatesFilter<"JobPost"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"JobPost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"JobPost"> | Date | string
  }

  export type ApplicationWhereInput = {
    AND?: ApplicationWhereInput | ApplicationWhereInput[]
    OR?: ApplicationWhereInput[]
    NOT?: ApplicationWhereInput | ApplicationWhereInput[]
    id?: StringFilter<"Application"> | string
    jobPostId?: StringFilter<"Application"> | string
    applicantUserId?: StringNullableFilter<"Application"> | string | null
    applicantName?: StringFilter<"Application"> | string
    applicantEmail?: StringFilter<"Application"> | string
    resumeUrl?: StringNullableFilter<"Application"> | string | null
    coverLetter?: StringNullableFilter<"Application"> | string | null
    status?: EnumApplicationStatusFilter<"Application"> | $Enums.ApplicationStatus
    notes?: StringNullableFilter<"Application"> | string | null
    createdAt?: DateTimeFilter<"Application"> | Date | string
    updatedAt?: DateTimeFilter<"Application"> | Date | string
    jobPost?: XOR<JobPostScalarRelationFilter, JobPostWhereInput>
    applicant?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ApplicationOrderByWithRelationInput = {
    id?: SortOrder
    jobPostId?: SortOrder
    applicantUserId?: SortOrderInput | SortOrder
    applicantName?: SortOrder
    applicantEmail?: SortOrder
    resumeUrl?: SortOrderInput | SortOrder
    coverLetter?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    jobPost?: JobPostOrderByWithRelationInput
    applicant?: UserOrderByWithRelationInput
    _relevance?: ApplicationOrderByRelevanceInput
  }

  export type ApplicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ApplicationWhereInput | ApplicationWhereInput[]
    OR?: ApplicationWhereInput[]
    NOT?: ApplicationWhereInput | ApplicationWhereInput[]
    jobPostId?: StringFilter<"Application"> | string
    applicantUserId?: StringNullableFilter<"Application"> | string | null
    applicantName?: StringFilter<"Application"> | string
    applicantEmail?: StringFilter<"Application"> | string
    resumeUrl?: StringNullableFilter<"Application"> | string | null
    coverLetter?: StringNullableFilter<"Application"> | string | null
    status?: EnumApplicationStatusFilter<"Application"> | $Enums.ApplicationStatus
    notes?: StringNullableFilter<"Application"> | string | null
    createdAt?: DateTimeFilter<"Application"> | Date | string
    updatedAt?: DateTimeFilter<"Application"> | Date | string
    jobPost?: XOR<JobPostScalarRelationFilter, JobPostWhereInput>
    applicant?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type ApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    jobPostId?: SortOrder
    applicantUserId?: SortOrderInput | SortOrder
    applicantName?: SortOrder
    applicantEmail?: SortOrder
    resumeUrl?: SortOrderInput | SortOrder
    coverLetter?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ApplicationCountOrderByAggregateInput
    _max?: ApplicationMaxOrderByAggregateInput
    _min?: ApplicationMinOrderByAggregateInput
  }

  export type ApplicationScalarWhereWithAggregatesInput = {
    AND?: ApplicationScalarWhereWithAggregatesInput | ApplicationScalarWhereWithAggregatesInput[]
    OR?: ApplicationScalarWhereWithAggregatesInput[]
    NOT?: ApplicationScalarWhereWithAggregatesInput | ApplicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Application"> | string
    jobPostId?: StringWithAggregatesFilter<"Application"> | string
    applicantUserId?: StringNullableWithAggregatesFilter<"Application"> | string | null
    applicantName?: StringWithAggregatesFilter<"Application"> | string
    applicantEmail?: StringWithAggregatesFilter<"Application"> | string
    resumeUrl?: StringNullableWithAggregatesFilter<"Application"> | string | null
    coverLetter?: StringNullableWithAggregatesFilter<"Application"> | string | null
    status?: EnumApplicationStatusWithAggregatesFilter<"Application"> | $Enums.ApplicationStatus
    notes?: StringNullableWithAggregatesFilter<"Application"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Application"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Application"> | Date | string
  }

  export type TrainingProgramWhereInput = {
    AND?: TrainingProgramWhereInput | TrainingProgramWhereInput[]
    OR?: TrainingProgramWhereInput[]
    NOT?: TrainingProgramWhereInput | TrainingProgramWhereInput[]
    id?: StringFilter<"TrainingProgram"> | string
    title?: StringFilter<"TrainingProgram"> | string
    description?: StringNullableFilter<"TrainingProgram"> | string | null
    trainer?: StringNullableFilter<"TrainingProgram"> | string | null
    location?: StringNullableFilter<"TrainingProgram"> | string | null
    startDate?: DateTimeFilter<"TrainingProgram"> | Date | string
    endDate?: DateTimeFilter<"TrainingProgram"> | Date | string
    status?: EnumTrainingStatusFilter<"TrainingProgram"> | $Enums.TrainingStatus
    mode?: StringNullableFilter<"TrainingProgram"> | string | null
    maxSeats?: IntNullableFilter<"TrainingProgram"> | number | null
    createdAt?: DateTimeFilter<"TrainingProgram"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingProgram"> | Date | string
    enrollments?: TrainingEnrollmentListRelationFilter
  }

  export type TrainingProgramOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    trainer?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    mode?: SortOrderInput | SortOrder
    maxSeats?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    enrollments?: TrainingEnrollmentOrderByRelationAggregateInput
    _relevance?: TrainingProgramOrderByRelevanceInput
  }

  export type TrainingProgramWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrainingProgramWhereInput | TrainingProgramWhereInput[]
    OR?: TrainingProgramWhereInput[]
    NOT?: TrainingProgramWhereInput | TrainingProgramWhereInput[]
    title?: StringFilter<"TrainingProgram"> | string
    description?: StringNullableFilter<"TrainingProgram"> | string | null
    trainer?: StringNullableFilter<"TrainingProgram"> | string | null
    location?: StringNullableFilter<"TrainingProgram"> | string | null
    startDate?: DateTimeFilter<"TrainingProgram"> | Date | string
    endDate?: DateTimeFilter<"TrainingProgram"> | Date | string
    status?: EnumTrainingStatusFilter<"TrainingProgram"> | $Enums.TrainingStatus
    mode?: StringNullableFilter<"TrainingProgram"> | string | null
    maxSeats?: IntNullableFilter<"TrainingProgram"> | number | null
    createdAt?: DateTimeFilter<"TrainingProgram"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingProgram"> | Date | string
    enrollments?: TrainingEnrollmentListRelationFilter
  }, "id">

  export type TrainingProgramOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    trainer?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    mode?: SortOrderInput | SortOrder
    maxSeats?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrainingProgramCountOrderByAggregateInput
    _avg?: TrainingProgramAvgOrderByAggregateInput
    _max?: TrainingProgramMaxOrderByAggregateInput
    _min?: TrainingProgramMinOrderByAggregateInput
    _sum?: TrainingProgramSumOrderByAggregateInput
  }

  export type TrainingProgramScalarWhereWithAggregatesInput = {
    AND?: TrainingProgramScalarWhereWithAggregatesInput | TrainingProgramScalarWhereWithAggregatesInput[]
    OR?: TrainingProgramScalarWhereWithAggregatesInput[]
    NOT?: TrainingProgramScalarWhereWithAggregatesInput | TrainingProgramScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingProgram"> | string
    title?: StringWithAggregatesFilter<"TrainingProgram"> | string
    description?: StringNullableWithAggregatesFilter<"TrainingProgram"> | string | null
    trainer?: StringNullableWithAggregatesFilter<"TrainingProgram"> | string | null
    location?: StringNullableWithAggregatesFilter<"TrainingProgram"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"TrainingProgram"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"TrainingProgram"> | Date | string
    status?: EnumTrainingStatusWithAggregatesFilter<"TrainingProgram"> | $Enums.TrainingStatus
    mode?: StringNullableWithAggregatesFilter<"TrainingProgram"> | string | null
    maxSeats?: IntNullableWithAggregatesFilter<"TrainingProgram"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"TrainingProgram"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TrainingProgram"> | Date | string
  }

  export type TrainingEnrollmentWhereInput = {
    AND?: TrainingEnrollmentWhereInput | TrainingEnrollmentWhereInput[]
    OR?: TrainingEnrollmentWhereInput[]
    NOT?: TrainingEnrollmentWhereInput | TrainingEnrollmentWhereInput[]
    id?: StringFilter<"TrainingEnrollment"> | string
    trainingId?: StringFilter<"TrainingEnrollment"> | string
    userId?: StringFilter<"TrainingEnrollment"> | string
    enrolledAt?: DateTimeFilter<"TrainingEnrollment"> | Date | string
    completedAt?: DateTimeNullableFilter<"TrainingEnrollment"> | Date | string | null
    certificateUrl?: StringNullableFilter<"TrainingEnrollment"> | string | null
    training?: XOR<TrainingProgramScalarRelationFilter, TrainingProgramWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TrainingEnrollmentOrderByWithRelationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    userId?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    certificateUrl?: SortOrderInput | SortOrder
    training?: TrainingProgramOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    _relevance?: TrainingEnrollmentOrderByRelevanceInput
  }

  export type TrainingEnrollmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    trainingId_userId?: TrainingEnrollmentTrainingIdUserIdCompoundUniqueInput
    AND?: TrainingEnrollmentWhereInput | TrainingEnrollmentWhereInput[]
    OR?: TrainingEnrollmentWhereInput[]
    NOT?: TrainingEnrollmentWhereInput | TrainingEnrollmentWhereInput[]
    trainingId?: StringFilter<"TrainingEnrollment"> | string
    userId?: StringFilter<"TrainingEnrollment"> | string
    enrolledAt?: DateTimeFilter<"TrainingEnrollment"> | Date | string
    completedAt?: DateTimeNullableFilter<"TrainingEnrollment"> | Date | string | null
    certificateUrl?: StringNullableFilter<"TrainingEnrollment"> | string | null
    training?: XOR<TrainingProgramScalarRelationFilter, TrainingProgramWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "trainingId_userId">

  export type TrainingEnrollmentOrderByWithAggregationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    userId?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    certificateUrl?: SortOrderInput | SortOrder
    _count?: TrainingEnrollmentCountOrderByAggregateInput
    _max?: TrainingEnrollmentMaxOrderByAggregateInput
    _min?: TrainingEnrollmentMinOrderByAggregateInput
  }

  export type TrainingEnrollmentScalarWhereWithAggregatesInput = {
    AND?: TrainingEnrollmentScalarWhereWithAggregatesInput | TrainingEnrollmentScalarWhereWithAggregatesInput[]
    OR?: TrainingEnrollmentScalarWhereWithAggregatesInput[]
    NOT?: TrainingEnrollmentScalarWhereWithAggregatesInput | TrainingEnrollmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingEnrollment"> | string
    trainingId?: StringWithAggregatesFilter<"TrainingEnrollment"> | string
    userId?: StringWithAggregatesFilter<"TrainingEnrollment"> | string
    enrolledAt?: DateTimeWithAggregatesFilter<"TrainingEnrollment"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"TrainingEnrollment"> | Date | string | null
    certificateUrl?: StringNullableWithAggregatesFilter<"TrainingEnrollment"> | string | null
  }

  export type CalendarEventWhereInput = {
    AND?: CalendarEventWhereInput | CalendarEventWhereInput[]
    OR?: CalendarEventWhereInput[]
    NOT?: CalendarEventWhereInput | CalendarEventWhereInput[]
    id?: StringFilter<"CalendarEvent"> | string
    title?: StringFilter<"CalendarEvent"> | string
    description?: StringNullableFilter<"CalendarEvent"> | string | null
    organizerId?: StringFilter<"CalendarEvent"> | string
    startTime?: DateTimeFilter<"CalendarEvent"> | Date | string
    endTime?: DateTimeFilter<"CalendarEvent"> | Date | string
    source?: EnumEventSourceFilter<"CalendarEvent"> | $Enums.EventSource
    googleMeetLink?: StringNullableFilter<"CalendarEvent"> | string | null
    location?: StringNullableFilter<"CalendarEvent"> | string | null
    createdAt?: DateTimeFilter<"CalendarEvent"> | Date | string
    updatedAt?: DateTimeFilter<"CalendarEvent"> | Date | string
    organizer?: XOR<UserScalarRelationFilter, UserWhereInput>
    attendees?: CalendarAttendeeListRelationFilter
  }

  export type CalendarEventOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    organizerId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    source?: SortOrder
    googleMeetLink?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizer?: UserOrderByWithRelationInput
    attendees?: CalendarAttendeeOrderByRelationAggregateInput
    _relevance?: CalendarEventOrderByRelevanceInput
  }

  export type CalendarEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CalendarEventWhereInput | CalendarEventWhereInput[]
    OR?: CalendarEventWhereInput[]
    NOT?: CalendarEventWhereInput | CalendarEventWhereInput[]
    title?: StringFilter<"CalendarEvent"> | string
    description?: StringNullableFilter<"CalendarEvent"> | string | null
    organizerId?: StringFilter<"CalendarEvent"> | string
    startTime?: DateTimeFilter<"CalendarEvent"> | Date | string
    endTime?: DateTimeFilter<"CalendarEvent"> | Date | string
    source?: EnumEventSourceFilter<"CalendarEvent"> | $Enums.EventSource
    googleMeetLink?: StringNullableFilter<"CalendarEvent"> | string | null
    location?: StringNullableFilter<"CalendarEvent"> | string | null
    createdAt?: DateTimeFilter<"CalendarEvent"> | Date | string
    updatedAt?: DateTimeFilter<"CalendarEvent"> | Date | string
    organizer?: XOR<UserScalarRelationFilter, UserWhereInput>
    attendees?: CalendarAttendeeListRelationFilter
  }, "id">

  export type CalendarEventOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    organizerId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    source?: SortOrder
    googleMeetLink?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CalendarEventCountOrderByAggregateInput
    _max?: CalendarEventMaxOrderByAggregateInput
    _min?: CalendarEventMinOrderByAggregateInput
  }

  export type CalendarEventScalarWhereWithAggregatesInput = {
    AND?: CalendarEventScalarWhereWithAggregatesInput | CalendarEventScalarWhereWithAggregatesInput[]
    OR?: CalendarEventScalarWhereWithAggregatesInput[]
    NOT?: CalendarEventScalarWhereWithAggregatesInput | CalendarEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CalendarEvent"> | string
    title?: StringWithAggregatesFilter<"CalendarEvent"> | string
    description?: StringNullableWithAggregatesFilter<"CalendarEvent"> | string | null
    organizerId?: StringWithAggregatesFilter<"CalendarEvent"> | string
    startTime?: DateTimeWithAggregatesFilter<"CalendarEvent"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"CalendarEvent"> | Date | string
    source?: EnumEventSourceWithAggregatesFilter<"CalendarEvent"> | $Enums.EventSource
    googleMeetLink?: StringNullableWithAggregatesFilter<"CalendarEvent"> | string | null
    location?: StringNullableWithAggregatesFilter<"CalendarEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CalendarEvent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CalendarEvent"> | Date | string
  }

  export type CalendarAttendeeWhereInput = {
    AND?: CalendarAttendeeWhereInput | CalendarAttendeeWhereInput[]
    OR?: CalendarAttendeeWhereInput[]
    NOT?: CalendarAttendeeWhereInput | CalendarAttendeeWhereInput[]
    id?: StringFilter<"CalendarAttendee"> | string
    eventId?: StringFilter<"CalendarAttendee"> | string
    userId?: StringFilter<"CalendarAttendee"> | string
    response?: StringNullableFilter<"CalendarAttendee"> | string | null
    event?: XOR<CalendarEventScalarRelationFilter, CalendarEventWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CalendarAttendeeOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    response?: SortOrderInput | SortOrder
    event?: CalendarEventOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    _relevance?: CalendarAttendeeOrderByRelevanceInput
  }

  export type CalendarAttendeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    eventId_userId?: CalendarAttendeeEventIdUserIdCompoundUniqueInput
    AND?: CalendarAttendeeWhereInput | CalendarAttendeeWhereInput[]
    OR?: CalendarAttendeeWhereInput[]
    NOT?: CalendarAttendeeWhereInput | CalendarAttendeeWhereInput[]
    eventId?: StringFilter<"CalendarAttendee"> | string
    userId?: StringFilter<"CalendarAttendee"> | string
    response?: StringNullableFilter<"CalendarAttendee"> | string | null
    event?: XOR<CalendarEventScalarRelationFilter, CalendarEventWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "eventId_userId">

  export type CalendarAttendeeOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    response?: SortOrderInput | SortOrder
    _count?: CalendarAttendeeCountOrderByAggregateInput
    _max?: CalendarAttendeeMaxOrderByAggregateInput
    _min?: CalendarAttendeeMinOrderByAggregateInput
  }

  export type CalendarAttendeeScalarWhereWithAggregatesInput = {
    AND?: CalendarAttendeeScalarWhereWithAggregatesInput | CalendarAttendeeScalarWhereWithAggregatesInput[]
    OR?: CalendarAttendeeScalarWhereWithAggregatesInput[]
    NOT?: CalendarAttendeeScalarWhereWithAggregatesInput | CalendarAttendeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CalendarAttendee"> | string
    eventId?: StringWithAggregatesFilter<"CalendarAttendee"> | string
    userId?: StringWithAggregatesFilter<"CalendarAttendee"> | string
    response?: StringNullableWithAggregatesFilter<"CalendarAttendee"> | string | null
  }

  export type UserPreferenceWhereInput = {
    AND?: UserPreferenceWhereInput | UserPreferenceWhereInput[]
    OR?: UserPreferenceWhereInput[]
    NOT?: UserPreferenceWhereInput | UserPreferenceWhereInput[]
    id?: StringFilter<"UserPreference"> | string
    userId?: StringFilter<"UserPreference"> | string
    theme?: StringNullableFilter<"UserPreference"> | string | null
    locale?: StringNullableFilter<"UserPreference"> | string | null
    notificationsEnabled?: BoolFilter<"UserPreference"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserPreferenceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    theme?: SortOrderInput | SortOrder
    locale?: SortOrderInput | SortOrder
    notificationsEnabled?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: UserPreferenceOrderByRelevanceInput
  }

  export type UserPreferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserPreferenceWhereInput | UserPreferenceWhereInput[]
    OR?: UserPreferenceWhereInput[]
    NOT?: UserPreferenceWhereInput | UserPreferenceWhereInput[]
    theme?: StringNullableFilter<"UserPreference"> | string | null
    locale?: StringNullableFilter<"UserPreference"> | string | null
    notificationsEnabled?: BoolFilter<"UserPreference"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserPreferenceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    theme?: SortOrderInput | SortOrder
    locale?: SortOrderInput | SortOrder
    notificationsEnabled?: SortOrder
    _count?: UserPreferenceCountOrderByAggregateInput
    _max?: UserPreferenceMaxOrderByAggregateInput
    _min?: UserPreferenceMinOrderByAggregateInput
  }

  export type UserPreferenceScalarWhereWithAggregatesInput = {
    AND?: UserPreferenceScalarWhereWithAggregatesInput | UserPreferenceScalarWhereWithAggregatesInput[]
    OR?: UserPreferenceScalarWhereWithAggregatesInput[]
    NOT?: UserPreferenceScalarWhereWithAggregatesInput | UserPreferenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserPreference"> | string
    userId?: StringWithAggregatesFilter<"UserPreference"> | string
    theme?: StringNullableWithAggregatesFilter<"UserPreference"> | string | null
    locale?: StringNullableWithAggregatesFilter<"UserPreference"> | string | null
    notificationsEnabled?: BoolWithAggregatesFilter<"UserPreference"> | boolean
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    actorId?: StringNullableFilter<"AuditLog"> | string | null
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    actor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    actorId?: SortOrderInput | SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    actor?: UserOrderByWithRelationInput
    _relevance?: AuditLogOrderByRelevanceInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    actorId?: StringNullableFilter<"AuditLog"> | string | null
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    actor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    actorId?: SortOrderInput | SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    actorId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    entity?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    metadata?: JsonNullableWithAggregatesFilter<"AuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutReportsInput
    reports?: UserCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseCreateNestedManyWithoutApproverInput
    payrolls?: PayrollCreateNestedManyWithoutUserInput
    generatedPays?: PayrollCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostCreateNestedManyWithoutPostedByInput
    applications?: ApplicationCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    departmentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: UserUncheckedCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveUncheckedCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseUncheckedCreateNestedManyWithoutApproverInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutUserInput
    generatedPays?: PayrollUncheckedCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewUncheckedCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetUncheckedCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostUncheckedCreateNestedManyWithoutPostedByInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventUncheckedCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeUncheckedCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentUncheckedCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutReportsNestedInput
    reports?: UserUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUncheckedUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUncheckedUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUncheckedUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUncheckedUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUncheckedUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUncheckedUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUncheckedUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    departmentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    head?: UserCreateNestedOneWithoutHeadedDepartmentsInput
    users?: UserCreateNestedManyWithoutDepartmentInput
    Announcement?: AnnouncementCreateNestedManyWithoutDepartmentInput
    JobPost?: JobPostCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    headId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutDepartmentInput
    Announcement?: AnnouncementUncheckedCreateNestedManyWithoutDepartmentInput
    JobPost?: JobPostUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    head?: UserUpdateOneWithoutHeadedDepartmentsNestedInput
    users?: UserUpdateManyWithoutDepartmentNestedInput
    Announcement?: AnnouncementUpdateManyWithoutDepartmentNestedInput
    JobPost?: JobPostUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    headId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutDepartmentNestedInput
    Announcement?: AnnouncementUncheckedUpdateManyWithoutDepartmentNestedInput
    JobPost?: JobPostUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    headId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    headId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.TaskPriority
    status?: $Enums.TaskStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutTasksCreatedInput
    assignments?: TaskAssignmentCreateNestedManyWithoutTaskInput
    comments?: TaskCommentCreateNestedManyWithoutTaskInput
    timeLogs?: TaskTimeLogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.TaskPriority
    status?: $Enums.TaskStatus
    dueDate?: Date | string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: TaskAssignmentUncheckedCreateNestedManyWithoutTaskInput
    comments?: TaskCommentUncheckedCreateNestedManyWithoutTaskInput
    timeLogs?: TaskTimeLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    assignments?: TaskAssignmentUpdateManyWithoutTaskNestedInput
    comments?: TaskCommentUpdateManyWithoutTaskNestedInput
    timeLogs?: TaskTimeLogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: TaskAssignmentUncheckedUpdateManyWithoutTaskNestedInput
    comments?: TaskCommentUncheckedUpdateManyWithoutTaskNestedInput
    timeLogs?: TaskTimeLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.TaskPriority
    status?: $Enums.TaskStatus
    dueDate?: Date | string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssignmentCreateInput = {
    id?: string
    assignedAt?: Date | string
    user: UserCreateNestedOneWithoutTaskAssignmentsInput
    task: TaskCreateNestedOneWithoutAssignmentsInput
  }

  export type TaskAssignmentUncheckedCreateInput = {
    id?: string
    userId: string
    taskId: string
    assignedAt?: Date | string
  }

  export type TaskAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTaskAssignmentsNestedInput
    task?: TaskUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type TaskAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssignmentCreateManyInput = {
    id?: string
    userId: string
    taskId: string
    assignedAt?: Date | string
  }

  export type TaskAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCommentCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutTaskCommentsInput
  }

  export type TaskCommentUncheckedCreateInput = {
    id?: string
    taskId: string
    userId: string
    content: string
    createdAt?: Date | string
  }

  export type TaskCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutTaskCommentsNestedInput
  }

  export type TaskCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCommentCreateManyInput = {
    id?: string
    taskId: string
    userId: string
    content: string
    createdAt?: Date | string
  }

  export type TaskCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskTimeLogCreateInput = {
    id?: string
    startedAt: Date | string
    endedAt?: Date | string | null
    durationSeconds?: number | null
    task: TaskCreateNestedOneWithoutTimeLogsInput
    user: UserCreateNestedOneWithoutTimeLogsInput
  }

  export type TaskTimeLogUncheckedCreateInput = {
    id?: string
    taskId: string
    userId: string
    startedAt: Date | string
    endedAt?: Date | string | null
    durationSeconds?: number | null
  }

  export type TaskTimeLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    task?: TaskUpdateOneRequiredWithoutTimeLogsNestedInput
    user?: UserUpdateOneRequiredWithoutTimeLogsNestedInput
  }

  export type TaskTimeLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TaskTimeLogCreateManyInput = {
    id?: string
    taskId: string
    userId: string
    startedAt: Date | string
    endedAt?: Date | string | null
    durationSeconds?: number | null
  }

  export type TaskTimeLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TaskTimeLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AttendanceRecordCreateInput = {
    id?: string
    date: Date | string
    clockIn?: Date | string | null
    clockOut?: Date | string | null
    status?: $Enums.AttendanceStatus
    ipAddress?: string | null
    location?: string | null
    user: UserCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceRecordUncheckedCreateInput = {
    id?: string
    userId: string
    date: Date | string
    clockIn?: Date | string | null
    clockOut?: Date | string | null
    status?: $Enums.AttendanceStatus
    ipAddress?: string | null
    location?: string | null
  }

  export type AttendanceRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    clockIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type AttendanceRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    clockIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttendanceRecordCreateManyInput = {
    id?: string
    userId: string
    date: Date | string
    clockIn?: Date | string | null
    clockOut?: Date | string | null
    status?: $Enums.AttendanceStatus
    ipAddress?: string | null
    location?: string | null
  }

  export type AttendanceRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    clockIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttendanceRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    clockIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LeaveCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    reason?: string | null
    status?: $Enums.LeaveStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLeavesInput
    approver?: UserCreateNestedOneWithoutLeavesToApproveInput
  }

  export type LeaveUncheckedCreateInput = {
    id?: string
    userId: string
    startDate: Date | string
    endDate: Date | string
    reason?: string | null
    status?: $Enums.LeaveStatus
    approverId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLeavesNestedInput
    approver?: UserUpdateOneWithoutLeavesToApproveNestedInput
  }

  export type LeaveUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    approverId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveCreateManyInput = {
    id?: string
    userId: string
    startDate: Date | string
    endDate: Date | string
    reason?: string | null
    status?: $Enums.LeaveStatus
    approverId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    approverId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateInput = {
    id?: string
    content: string
    timestamp?: Date | string
    sender: UserCreateNestedOneWithoutMessagesSentInput
    receiver?: UserCreateNestedOneWithoutMessagesRecvInput
    group?: ChatGroupCreateNestedOneWithoutMessagesInput
  }

  export type ChatMessageUncheckedCreateInput = {
    id?: string
    senderId: string
    receiverId?: string | null
    groupId?: string | null
    content: string
    timestamp?: Date | string
  }

  export type ChatMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutMessagesSentNestedInput
    receiver?: UserUpdateOneWithoutMessagesRecvNestedInput
    group?: ChatGroupUpdateOneWithoutMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateManyInput = {
    id?: string
    senderId: string
    receiverId?: string | null
    groupId?: string | null
    content: string
    timestamp?: Date | string
  }

  export type ChatMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatGroupCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    messages?: ChatMessageCreateNestedManyWithoutGroupInput
    members?: ChatGroupMemberCreateNestedManyWithoutGroupInput
  }

  export type ChatGroupUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    messages?: ChatMessageUncheckedCreateNestedManyWithoutGroupInput
    members?: ChatGroupMemberUncheckedCreateNestedManyWithoutGroupInput
  }

  export type ChatGroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ChatMessageUpdateManyWithoutGroupNestedInput
    members?: ChatGroupMemberUpdateManyWithoutGroupNestedInput
  }

  export type ChatGroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ChatMessageUncheckedUpdateManyWithoutGroupNestedInput
    members?: ChatGroupMemberUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type ChatGroupCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
  }

  export type ChatGroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatGroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatGroupMemberCreateInput = {
    id?: string
    joinedAt?: Date | string
    group: ChatGroupCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutChatGroupsInput
  }

  export type ChatGroupMemberUncheckedCreateInput = {
    id?: string
    groupId: string
    userId: string
    joinedAt?: Date | string
  }

  export type ChatGroupMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: ChatGroupUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutChatGroupsNestedInput
  }

  export type ChatGroupMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatGroupMemberCreateManyInput = {
    id?: string
    groupId: string
    userId: string
    joinedAt?: Date | string
  }

  export type ChatGroupMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatGroupMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementCreateInput = {
    id?: string
    title: string
    content: string
    createdAt?: Date | string
    author: UserCreateNestedOneWithoutAnnouncementsMadeInput
    department?: DepartmentCreateNestedOneWithoutAnnouncementInput
  }

  export type AnnouncementUncheckedCreateInput = {
    id?: string
    title: string
    content: string
    authorId: string
    departmentId?: string | null
    createdAt?: Date | string
  }

  export type AnnouncementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutAnnouncementsMadeNestedInput
    department?: DepartmentUpdateOneWithoutAnnouncementNestedInput
  }

  export type AnnouncementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementCreateManyInput = {
    id?: string
    title: string
    content: string
    authorId: string
    departmentId?: string | null
    createdAt?: Date | string
  }

  export type AnnouncementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    message: string
    type?: $Enums.NotificationType
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    message: string
    type?: $Enums.NotificationType
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    title: string
    message: string
    type?: $Enums.NotificationType
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    id?: string
    title: string
    fileUrl: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    fileUrl: string
    createdAt?: Date | string
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyInput = {
    id?: string
    userId: string
    title: string
    fileUrl: string
    createdAt?: Date | string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyDocumentCreateInput = {
    id?: string
    title: string
    description?: string | null
    fileUrl: string
    createdAt?: Date | string
    uploader: UserCreateNestedOneWithoutCompanyDocsInput
  }

  export type CompanyDocumentUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    fileUrl: string
    uploadedBy: string
    createdAt?: Date | string
  }

  export type CompanyDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader?: UserUpdateOneRequiredWithoutCompanyDocsNestedInput
  }

  export type CompanyDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyDocumentCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    fileUrl: string
    uploadedBy: string
    createdAt?: Date | string
  }

  export type CompanyDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCreateInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    date: Date | string
    status?: $Enums.ExpenseStatus
    receiptUrl?: string | null
    submittedAt?: Date | string
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutExpensesInput
    approver?: UserCreateNestedOneWithoutExpensesApprovedInput
  }

  export type ExpenseUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    category?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    date: Date | string
    status?: $Enums.ExpenseStatus
    receiptUrl?: string | null
    submittedAt?: Date | string
    approvedAt?: Date | string | null
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutExpensesNestedInput
    approver?: UserUpdateOneWithoutExpensesApprovedNestedInput
  }

  export type ExpenseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCreateManyInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    category?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    date: Date | string
    status?: $Enums.ExpenseStatus
    receiptUrl?: string | null
    submittedAt?: Date | string
    approvedAt?: Date | string | null
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetCreateInput = {
    id?: string
    tag: string
    name: string
    type?: string | null
    serialNumber?: string | null
    purchaseDate?: Date | string | null
    status?: $Enums.AssetStatus
    assignedAt?: Date | string | null
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo?: UserCreateNestedOneWithoutAssetsOwnedInput
  }

  export type AssetUncheckedCreateInput = {
    id?: string
    tag: string
    name: string
    type?: string | null
    serialNumber?: string | null
    purchaseDate?: Date | string | null
    status?: $Enums.AssetStatus
    assignedToId?: string | null
    assignedAt?: Date | string | null
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: UserUpdateOneWithoutAssetsOwnedNestedInput
  }

  export type AssetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetCreateManyInput = {
    id?: string
    tag: string
    name: string
    type?: string | null
    serialNumber?: string | null
    purchaseDate?: Date | string | null
    status?: $Enums.AssetStatus
    assignedToId?: string | null
    assignedAt?: Date | string | null
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollCreateInput = {
    id?: string
    month: number
    year: number
    baseSalary: Decimal | DecimalJsLike | number | string
    allowances?: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
    netPay: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PayrollStatus
    generatedAt?: Date | string | null
    paidAt?: Date | string | null
    slipUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPayrollsInput
    generatedBy?: UserCreateNestedOneWithoutGeneratedPaysInput
  }

  export type PayrollUncheckedCreateInput = {
    id?: string
    userId: string
    month: number
    year: number
    baseSalary: Decimal | DecimalJsLike | number | string
    allowances?: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
    netPay: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PayrollStatus
    generatedById?: string | null
    generatedAt?: Date | string | null
    paidAt?: Date | string | null
    slipUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPayrollStatusFieldUpdateOperationsInput | $Enums.PayrollStatus
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slipUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPayrollsNestedInput
    generatedBy?: UserUpdateOneWithoutGeneratedPaysNestedInput
  }

  export type PayrollUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPayrollStatusFieldUpdateOperationsInput | $Enums.PayrollStatus
    generatedById?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slipUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollCreateManyInput = {
    id?: string
    userId: string
    month: number
    year: number
    baseSalary: Decimal | DecimalJsLike | number | string
    allowances?: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
    netPay: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PayrollStatus
    generatedById?: string | null
    generatedAt?: Date | string | null
    paidAt?: Date | string | null
    slipUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPayrollStatusFieldUpdateOperationsInput | $Enums.PayrollStatus
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slipUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPayrollStatusFieldUpdateOperationsInput | $Enums.PayrollStatus
    generatedById?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slipUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceReviewCreateInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    overallScore: number
    kpiScores?: NullableJsonNullValueInput | InputJsonValue
    feedback?: string | null
    createdAt?: Date | string
    reviewee: UserCreateNestedOneWithoutPerformanceReviewsGotInput
    reviewer: UserCreateNestedOneWithoutPerformanceReviewsGivenInput
  }

  export type PerformanceReviewUncheckedCreateInput = {
    id?: string
    revieweeId: string
    reviewerId: string
    periodStart: Date | string
    periodEnd: Date | string
    overallScore: number
    kpiScores?: NullableJsonNullValueInput | InputJsonValue
    feedback?: string | null
    createdAt?: Date | string
  }

  export type PerformanceReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    overallScore?: IntFieldUpdateOperationsInput | number
    kpiScores?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewee?: UserUpdateOneRequiredWithoutPerformanceReviewsGotNestedInput
    reviewer?: UserUpdateOneRequiredWithoutPerformanceReviewsGivenNestedInput
  }

  export type PerformanceReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    revieweeId?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    overallScore?: IntFieldUpdateOperationsInput | number
    kpiScores?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceReviewCreateManyInput = {
    id?: string
    revieweeId: string
    reviewerId: string
    periodStart: Date | string
    periodEnd: Date | string
    overallScore: number
    kpiScores?: NullableJsonNullValueInput | InputJsonValue
    feedback?: string | null
    createdAt?: Date | string
  }

  export type PerformanceReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    overallScore?: IntFieldUpdateOperationsInput | number
    kpiScores?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    revieweeId?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    overallScore?: IntFieldUpdateOperationsInput | number
    kpiScores?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobPostCreateInput = {
    id?: string
    title: string
    type?: $Enums.JobType
    location?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutJobPostInput
    postedBy: UserCreateNestedOneWithoutJobPostsInput
    applications?: ApplicationCreateNestedManyWithoutJobPostInput
  }

  export type JobPostUncheckedCreateInput = {
    id?: string
    title: string
    departmentId?: string | null
    type?: $Enums.JobType
    location?: string | null
    description?: string | null
    postedById: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: ApplicationUncheckedCreateNestedManyWithoutJobPostInput
  }

  export type JobPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutJobPostNestedInput
    postedBy?: UserUpdateOneRequiredWithoutJobPostsNestedInput
    applications?: ApplicationUpdateManyWithoutJobPostNestedInput
  }

  export type JobPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    postedById?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: ApplicationUncheckedUpdateManyWithoutJobPostNestedInput
  }

  export type JobPostCreateManyInput = {
    id?: string
    title: string
    departmentId?: string | null
    type?: $Enums.JobType
    location?: string | null
    description?: string | null
    postedById: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    postedById?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationCreateInput = {
    id?: string
    applicantName: string
    applicantEmail: string
    resumeUrl?: string | null
    coverLetter?: string | null
    status?: $Enums.ApplicationStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobPost: JobPostCreateNestedOneWithoutApplicationsInput
    applicant?: UserCreateNestedOneWithoutApplicationsInput
  }

  export type ApplicationUncheckedCreateInput = {
    id?: string
    jobPostId: string
    applicantUserId?: string | null
    applicantName: string
    applicantEmail: string
    resumeUrl?: string | null
    coverLetter?: string | null
    status?: $Enums.ApplicationStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApplicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantName?: StringFieldUpdateOperationsInput | string
    applicantEmail?: StringFieldUpdateOperationsInput | string
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobPost?: JobPostUpdateOneRequiredWithoutApplicationsNestedInput
    applicant?: UserUpdateOneWithoutApplicationsNestedInput
  }

  export type ApplicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobPostId?: StringFieldUpdateOperationsInput | string
    applicantUserId?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: StringFieldUpdateOperationsInput | string
    applicantEmail?: StringFieldUpdateOperationsInput | string
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationCreateManyInput = {
    id?: string
    jobPostId: string
    applicantUserId?: string | null
    applicantName: string
    applicantEmail: string
    resumeUrl?: string | null
    coverLetter?: string | null
    status?: $Enums.ApplicationStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApplicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantName?: StringFieldUpdateOperationsInput | string
    applicantEmail?: StringFieldUpdateOperationsInput | string
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobPostId?: StringFieldUpdateOperationsInput | string
    applicantUserId?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: StringFieldUpdateOperationsInput | string
    applicantEmail?: StringFieldUpdateOperationsInput | string
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingProgramCreateInput = {
    id?: string
    title: string
    description?: string | null
    trainer?: string | null
    location?: string | null
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.TrainingStatus
    mode?: string | null
    maxSeats?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: TrainingEnrollmentCreateNestedManyWithoutTrainingInput
  }

  export type TrainingProgramUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    trainer?: string | null
    location?: string | null
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.TrainingStatus
    mode?: string | null
    maxSeats?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: TrainingEnrollmentUncheckedCreateNestedManyWithoutTrainingInput
  }

  export type TrainingProgramUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainer?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    maxSeats?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: TrainingEnrollmentUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingProgramUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainer?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    maxSeats?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: TrainingEnrollmentUncheckedUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingProgramCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    trainer?: string | null
    location?: string | null
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.TrainingStatus
    mode?: string | null
    maxSeats?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingProgramUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainer?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    maxSeats?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingProgramUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainer?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    maxSeats?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingEnrollmentCreateInput = {
    id?: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    certificateUrl?: string | null
    training: TrainingProgramCreateNestedOneWithoutEnrollmentsInput
    user: UserCreateNestedOneWithoutTrainingEnrollmentsInput
  }

  export type TrainingEnrollmentUncheckedCreateInput = {
    id?: string
    trainingId: string
    userId: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    certificateUrl?: string | null
  }

  export type TrainingEnrollmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    training?: TrainingProgramUpdateOneRequiredWithoutEnrollmentsNestedInput
    user?: UserUpdateOneRequiredWithoutTrainingEnrollmentsNestedInput
  }

  export type TrainingEnrollmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrainingEnrollmentCreateManyInput = {
    id?: string
    trainingId: string
    userId: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    certificateUrl?: string | null
  }

  export type TrainingEnrollmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrainingEnrollmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CalendarEventCreateInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    source?: $Enums.EventSource
    googleMeetLink?: string | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organizer: UserCreateNestedOneWithoutEventsOrganizedInput
    attendees?: CalendarAttendeeCreateNestedManyWithoutEventInput
  }

  export type CalendarEventUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    organizerId: string
    startTime: Date | string
    endTime: Date | string
    source?: $Enums.EventSource
    googleMeetLink?: string | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendees?: CalendarAttendeeUncheckedCreateNestedManyWithoutEventInput
  }

  export type CalendarEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumEventSourceFieldUpdateOperationsInput | $Enums.EventSource
    googleMeetLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizer?: UserUpdateOneRequiredWithoutEventsOrganizedNestedInput
    attendees?: CalendarAttendeeUpdateManyWithoutEventNestedInput
  }

  export type CalendarEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizerId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumEventSourceFieldUpdateOperationsInput | $Enums.EventSource
    googleMeetLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendees?: CalendarAttendeeUncheckedUpdateManyWithoutEventNestedInput
  }

  export type CalendarEventCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    organizerId: string
    startTime: Date | string
    endTime: Date | string
    source?: $Enums.EventSource
    googleMeetLink?: string | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumEventSourceFieldUpdateOperationsInput | $Enums.EventSource
    googleMeetLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizerId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumEventSourceFieldUpdateOperationsInput | $Enums.EventSource
    googleMeetLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarAttendeeCreateInput = {
    id?: string
    response?: string | null
    event: CalendarEventCreateNestedOneWithoutAttendeesInput
    user: UserCreateNestedOneWithoutEventAttendeesInput
  }

  export type CalendarAttendeeUncheckedCreateInput = {
    id?: string
    eventId: string
    userId: string
    response?: string | null
  }

  export type CalendarAttendeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    event?: CalendarEventUpdateOneRequiredWithoutAttendeesNestedInput
    user?: UserUpdateOneRequiredWithoutEventAttendeesNestedInput
  }

  export type CalendarAttendeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CalendarAttendeeCreateManyInput = {
    id?: string
    eventId: string
    userId: string
    response?: string | null
  }

  export type CalendarAttendeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CalendarAttendeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserPreferenceCreateInput = {
    id?: string
    theme?: string | null
    locale?: string | null
    notificationsEnabled?: boolean
    user: UserCreateNestedOneWithoutPreferencesInput
  }

  export type UserPreferenceUncheckedCreateInput = {
    id?: string
    userId: string
    theme?: string | null
    locale?: string | null
    notificationsEnabled?: boolean
  }

  export type UserPreferenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutPreferencesNestedInput
  }

  export type UserPreferenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserPreferenceCreateManyInput = {
    id?: string
    userId: string
    theme?: string | null
    locale?: string | null
    notificationsEnabled?: boolean
  }

  export type UserPreferenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserPreferenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AuditLogCreateInput = {
    id?: string
    entity: string
    entityId: string
    action: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    actor?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    actorId?: string | null
    entity: string
    entityId: string
    action: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    actorId?: string | null
    entity: string
    entityId: string
    action: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type EnumEmploymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EmploymentStatus | EnumEmploymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmploymentStatus[]
    notIn?: $Enums.EmploymentStatus[]
    not?: NestedEnumEmploymentStatusFilter<$PrismaModel> | $Enums.EmploymentStatus
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DepartmentNullableScalarRelationFilter = {
    is?: DepartmentWhereInput | null
    isNot?: DepartmentWhereInput | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type TaskAssignmentListRelationFilter = {
    every?: TaskAssignmentWhereInput
    some?: TaskAssignmentWhereInput
    none?: TaskAssignmentWhereInput
  }

  export type TaskCommentListRelationFilter = {
    every?: TaskCommentWhereInput
    some?: TaskCommentWhereInput
    none?: TaskCommentWhereInput
  }

  export type TaskTimeLogListRelationFilter = {
    every?: TaskTimeLogWhereInput
    some?: TaskTimeLogWhereInput
    none?: TaskTimeLogWhereInput
  }

  export type AttendanceRecordListRelationFilter = {
    every?: AttendanceRecordWhereInput
    some?: AttendanceRecordWhereInput
    none?: AttendanceRecordWhereInput
  }

  export type LeaveListRelationFilter = {
    every?: LeaveWhereInput
    some?: LeaveWhereInput
    none?: LeaveWhereInput
  }

  export type ChatMessageListRelationFilter = {
    every?: ChatMessageWhereInput
    some?: ChatMessageWhereInput
    none?: ChatMessageWhereInput
  }

  export type ChatGroupMemberListRelationFilter = {
    every?: ChatGroupMemberWhereInput
    some?: ChatGroupMemberWhereInput
    none?: ChatGroupMemberWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type CompanyDocumentListRelationFilter = {
    every?: CompanyDocumentWhereInput
    some?: CompanyDocumentWhereInput
    none?: CompanyDocumentWhereInput
  }

  export type ExpenseListRelationFilter = {
    every?: ExpenseWhereInput
    some?: ExpenseWhereInput
    none?: ExpenseWhereInput
  }

  export type PayrollListRelationFilter = {
    every?: PayrollWhereInput
    some?: PayrollWhereInput
    none?: PayrollWhereInput
  }

  export type PerformanceReviewListRelationFilter = {
    every?: PerformanceReviewWhereInput
    some?: PerformanceReviewWhereInput
    none?: PerformanceReviewWhereInput
  }

  export type AssetListRelationFilter = {
    every?: AssetWhereInput
    some?: AssetWhereInput
    none?: AssetWhereInput
  }

  export type JobPostListRelationFilter = {
    every?: JobPostWhereInput
    some?: JobPostWhereInput
    none?: JobPostWhereInput
  }

  export type ApplicationListRelationFilter = {
    every?: ApplicationWhereInput
    some?: ApplicationWhereInput
    none?: ApplicationWhereInput
  }

  export type CalendarEventListRelationFilter = {
    every?: CalendarEventWhereInput
    some?: CalendarEventWhereInput
    none?: CalendarEventWhereInput
  }

  export type CalendarAttendeeListRelationFilter = {
    every?: CalendarAttendeeWhereInput
    some?: CalendarAttendeeWhereInput
    none?: CalendarAttendeeWhereInput
  }

  export type TrainingEnrollmentListRelationFilter = {
    every?: TrainingEnrollmentWhereInput
    some?: TrainingEnrollmentWhereInput
    none?: TrainingEnrollmentWhereInput
  }

  export type AnnouncementListRelationFilter = {
    every?: AnnouncementWhereInput
    some?: AnnouncementWhereInput
    none?: AnnouncementWhereInput
  }

  export type UserPreferenceNullableScalarRelationFilter = {
    is?: UserPreferenceWhereInput | null
    isNot?: UserPreferenceWhereInput | null
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type DepartmentListRelationFilter = {
    every?: DepartmentWhereInput
    some?: DepartmentWhereInput
    none?: DepartmentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskTimeLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatGroupMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpenseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PayrollOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PerformanceReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CalendarEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CalendarAttendeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingEnrollmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnnouncementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    employment?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    joinDate?: SortOrder
    salary?: SortOrder
    notes?: SortOrder
    departmentId?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    salary?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    employment?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    joinDate?: SortOrder
    salary?: SortOrder
    notes?: SortOrder
    departmentId?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    employment?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    joinDate?: SortOrder
    salary?: SortOrder
    notes?: SortOrder
    departmentId?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    salary?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type EnumEmploymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmploymentStatus | EnumEmploymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmploymentStatus[]
    notIn?: $Enums.EmploymentStatus[]
    not?: NestedEnumEmploymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.EmploymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmploymentStatusFilter<$PrismaModel>
    _max?: NestedEnumEmploymentStatusFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DepartmentOrderByRelevanceInput = {
    fields: DepartmentOrderByRelevanceFieldEnum | DepartmentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    headId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    headId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    headId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTaskPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskPriority | EnumTaskPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TaskPriority[]
    notIn?: $Enums.TaskPriority[]
    not?: NestedEnumTaskPriorityFilter<$PrismaModel> | $Enums.TaskPriority
  }

  export type EnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[]
    notIn?: $Enums.TaskStatus[]
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type TaskOrderByRelevanceInput = {
    fields: TaskOrderByRelevanceFieldEnum | TaskOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTaskPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskPriority | EnumTaskPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TaskPriority[]
    notIn?: $Enums.TaskPriority[]
    not?: NestedEnumTaskPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TaskPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskPriorityFilter<$PrismaModel>
    _max?: NestedEnumTaskPriorityFilter<$PrismaModel>
  }

  export type EnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[]
    notIn?: $Enums.TaskStatus[]
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type TaskScalarRelationFilter = {
    is?: TaskWhereInput
    isNot?: TaskWhereInput
  }

  export type TaskAssignmentOrderByRelevanceInput = {
    fields: TaskAssignmentOrderByRelevanceFieldEnum | TaskAssignmentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TaskAssignmentUserIdTaskIdCompoundUniqueInput = {
    userId: string
    taskId: string
  }

  export type TaskAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    taskId?: SortOrder
    assignedAt?: SortOrder
  }

  export type TaskAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    taskId?: SortOrder
    assignedAt?: SortOrder
  }

  export type TaskAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    taskId?: SortOrder
    assignedAt?: SortOrder
  }

  export type TaskCommentOrderByRelevanceInput = {
    fields: TaskCommentOrderByRelevanceFieldEnum | TaskCommentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TaskCommentCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskCommentMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type TaskTimeLogOrderByRelevanceInput = {
    fields: TaskTimeLogOrderByRelevanceFieldEnum | TaskTimeLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TaskTimeLogCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    durationSeconds?: SortOrder
  }

  export type TaskTimeLogAvgOrderByAggregateInput = {
    durationSeconds?: SortOrder
  }

  export type TaskTimeLogMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    durationSeconds?: SortOrder
  }

  export type TaskTimeLogMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    durationSeconds?: SortOrder
  }

  export type TaskTimeLogSumOrderByAggregateInput = {
    durationSeconds?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[]
    notIn?: $Enums.AttendanceStatus[]
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type AttendanceRecordOrderByRelevanceInput = {
    fields: AttendanceRecordOrderByRelevanceFieldEnum | AttendanceRecordOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AttendanceRecordUserIdDateCompoundUniqueInput = {
    userId: string
    date: Date | string
  }

  export type AttendanceRecordCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    clockIn?: SortOrder
    clockOut?: SortOrder
    status?: SortOrder
    ipAddress?: SortOrder
    location?: SortOrder
  }

  export type AttendanceRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    clockIn?: SortOrder
    clockOut?: SortOrder
    status?: SortOrder
    ipAddress?: SortOrder
    location?: SortOrder
  }

  export type AttendanceRecordMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    clockIn?: SortOrder
    clockOut?: SortOrder
    status?: SortOrder
    ipAddress?: SortOrder
    location?: SortOrder
  }

  export type EnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[]
    notIn?: $Enums.AttendanceStatus[]
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type EnumLeaveStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[]
    notIn?: $Enums.LeaveStatus[]
    not?: NestedEnumLeaveStatusFilter<$PrismaModel> | $Enums.LeaveStatus
  }

  export type LeaveOrderByRelevanceInput = {
    fields: LeaveOrderByRelevanceFieldEnum | LeaveOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type LeaveCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    approverId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    approverId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    approverId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumLeaveStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[]
    notIn?: $Enums.LeaveStatus[]
    not?: NestedEnumLeaveStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeaveStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveStatusFilter<$PrismaModel>
    _max?: NestedEnumLeaveStatusFilter<$PrismaModel>
  }

  export type ChatGroupNullableScalarRelationFilter = {
    is?: ChatGroupWhereInput | null
    isNot?: ChatGroupWhereInput | null
  }

  export type ChatMessageOrderByRelevanceInput = {
    fields: ChatMessageOrderByRelevanceFieldEnum | ChatMessageOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ChatMessageCountOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    groupId?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
  }

  export type ChatMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    groupId?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
  }

  export type ChatMessageMinOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    groupId?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
  }

  export type ChatGroupOrderByRelevanceInput = {
    fields: ChatGroupOrderByRelevanceFieldEnum | ChatGroupOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ChatGroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatGroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatGroupScalarRelationFilter = {
    is?: ChatGroupWhereInput
    isNot?: ChatGroupWhereInput
  }

  export type ChatGroupMemberOrderByRelevanceInput = {
    fields: ChatGroupMemberOrderByRelevanceFieldEnum | ChatGroupMemberOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ChatGroupMemberGroupIdUserIdCompoundUniqueInput = {
    groupId: string
    userId: string
  }

  export type ChatGroupMemberCountOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
  }

  export type ChatGroupMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
  }

  export type ChatGroupMemberMinOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
  }

  export type AnnouncementOrderByRelevanceInput = {
    fields: AnnouncementOrderByRelevanceFieldEnum | AnnouncementOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AnnouncementCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    departmentId?: SortOrder
    createdAt?: SortOrder
  }

  export type AnnouncementMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    departmentId?: SortOrder
    createdAt?: SortOrder
  }

  export type AnnouncementMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    departmentId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[]
    notIn?: $Enums.NotificationType[]
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NotificationOrderByRelevanceInput = {
    fields: NotificationOrderByRelevanceFieldEnum | NotificationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    data?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[]
    notIn?: $Enums.NotificationType[]
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DocumentOrderByRelevanceInput = {
    fields: DocumentOrderByRelevanceFieldEnum | DocumentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    fileUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    fileUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    fileUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type CompanyDocumentOrderByRelevanceInput = {
    fields: CompanyDocumentOrderByRelevanceFieldEnum | CompanyDocumentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CompanyDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type CompanyDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type CompanyDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumExpenseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseStatus | EnumExpenseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseStatus[]
    notIn?: $Enums.ExpenseStatus[]
    not?: NestedEnumExpenseStatusFilter<$PrismaModel> | $Enums.ExpenseStatus
  }

  export type ExpenseOrderByRelevanceInput = {
    fields: ExpenseOrderByRelevanceFieldEnum | ExpenseOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ExpenseCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    date?: SortOrder
    status?: SortOrder
    receiptUrl?: SortOrder
    submittedAt?: SortOrder
    approvedAt?: SortOrder
    approvedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ExpenseMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    date?: SortOrder
    status?: SortOrder
    receiptUrl?: SortOrder
    submittedAt?: SortOrder
    approvedAt?: SortOrder
    approvedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    date?: SortOrder
    status?: SortOrder
    receiptUrl?: SortOrder
    submittedAt?: SortOrder
    approvedAt?: SortOrder
    approvedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumExpenseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseStatus | EnumExpenseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseStatus[]
    notIn?: $Enums.ExpenseStatus[]
    not?: NestedEnumExpenseStatusWithAggregatesFilter<$PrismaModel> | $Enums.ExpenseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExpenseStatusFilter<$PrismaModel>
    _max?: NestedEnumExpenseStatusFilter<$PrismaModel>
  }

  export type EnumAssetStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetStatus | EnumAssetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssetStatus[]
    notIn?: $Enums.AssetStatus[]
    not?: NestedEnumAssetStatusFilter<$PrismaModel> | $Enums.AssetStatus
  }

  export type AssetOrderByRelevanceInput = {
    fields: AssetOrderByRelevanceFieldEnum | AssetOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AssetCountOrderByAggregateInput = {
    id?: SortOrder
    tag?: SortOrder
    name?: SortOrder
    type?: SortOrder
    serialNumber?: SortOrder
    purchaseDate?: SortOrder
    status?: SortOrder
    assignedToId?: SortOrder
    assignedAt?: SortOrder
    location?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssetMaxOrderByAggregateInput = {
    id?: SortOrder
    tag?: SortOrder
    name?: SortOrder
    type?: SortOrder
    serialNumber?: SortOrder
    purchaseDate?: SortOrder
    status?: SortOrder
    assignedToId?: SortOrder
    assignedAt?: SortOrder
    location?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssetMinOrderByAggregateInput = {
    id?: SortOrder
    tag?: SortOrder
    name?: SortOrder
    type?: SortOrder
    serialNumber?: SortOrder
    purchaseDate?: SortOrder
    status?: SortOrder
    assignedToId?: SortOrder
    assignedAt?: SortOrder
    location?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAssetStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetStatus | EnumAssetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssetStatus[]
    notIn?: $Enums.AssetStatus[]
    not?: NestedEnumAssetStatusWithAggregatesFilter<$PrismaModel> | $Enums.AssetStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssetStatusFilter<$PrismaModel>
    _max?: NestedEnumAssetStatusFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumPayrollStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PayrollStatus | EnumPayrollStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayrollStatus[]
    notIn?: $Enums.PayrollStatus[]
    not?: NestedEnumPayrollStatusFilter<$PrismaModel> | $Enums.PayrollStatus
  }

  export type PayrollOrderByRelevanceInput = {
    fields: PayrollOrderByRelevanceFieldEnum | PayrollOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PayrollUserIdMonthYearCompoundUniqueInput = {
    userId: string
    month: number
    year: number
  }

  export type PayrollCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    baseSalary?: SortOrder
    allowances?: SortOrder
    deductions?: SortOrder
    netPay?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    generatedById?: SortOrder
    generatedAt?: SortOrder
    paidAt?: SortOrder
    slipUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollAvgOrderByAggregateInput = {
    month?: SortOrder
    year?: SortOrder
    baseSalary?: SortOrder
    allowances?: SortOrder
    deductions?: SortOrder
    netPay?: SortOrder
  }

  export type PayrollMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    baseSalary?: SortOrder
    allowances?: SortOrder
    deductions?: SortOrder
    netPay?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    generatedById?: SortOrder
    generatedAt?: SortOrder
    paidAt?: SortOrder
    slipUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    baseSalary?: SortOrder
    allowances?: SortOrder
    deductions?: SortOrder
    netPay?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    generatedById?: SortOrder
    generatedAt?: SortOrder
    paidAt?: SortOrder
    slipUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollSumOrderByAggregateInput = {
    month?: SortOrder
    year?: SortOrder
    baseSalary?: SortOrder
    allowances?: SortOrder
    deductions?: SortOrder
    netPay?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumPayrollStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayrollStatus | EnumPayrollStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayrollStatus[]
    notIn?: $Enums.PayrollStatus[]
    not?: NestedEnumPayrollStatusWithAggregatesFilter<$PrismaModel> | $Enums.PayrollStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayrollStatusFilter<$PrismaModel>
    _max?: NestedEnumPayrollStatusFilter<$PrismaModel>
  }

  export type PerformanceReviewOrderByRelevanceInput = {
    fields: PerformanceReviewOrderByRelevanceFieldEnum | PerformanceReviewOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PerformanceReviewCountOrderByAggregateInput = {
    id?: SortOrder
    revieweeId?: SortOrder
    reviewerId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    overallScore?: SortOrder
    kpiScores?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
  }

  export type PerformanceReviewAvgOrderByAggregateInput = {
    overallScore?: SortOrder
  }

  export type PerformanceReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    revieweeId?: SortOrder
    reviewerId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    overallScore?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
  }

  export type PerformanceReviewMinOrderByAggregateInput = {
    id?: SortOrder
    revieweeId?: SortOrder
    reviewerId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    overallScore?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
  }

  export type PerformanceReviewSumOrderByAggregateInput = {
    overallScore?: SortOrder
  }

  export type EnumJobTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.JobType | EnumJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JobType[]
    notIn?: $Enums.JobType[]
    not?: NestedEnumJobTypeFilter<$PrismaModel> | $Enums.JobType
  }

  export type JobPostOrderByRelevanceInput = {
    fields: JobPostOrderByRelevanceFieldEnum | JobPostOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type JobPostCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    departmentId?: SortOrder
    type?: SortOrder
    location?: SortOrder
    description?: SortOrder
    postedById?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobPostMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    departmentId?: SortOrder
    type?: SortOrder
    location?: SortOrder
    description?: SortOrder
    postedById?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobPostMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    departmentId?: SortOrder
    type?: SortOrder
    location?: SortOrder
    description?: SortOrder
    postedById?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumJobTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobType | EnumJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JobType[]
    notIn?: $Enums.JobType[]
    not?: NestedEnumJobTypeWithAggregatesFilter<$PrismaModel> | $Enums.JobType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobTypeFilter<$PrismaModel>
    _max?: NestedEnumJobTypeFilter<$PrismaModel>
  }

  export type EnumApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[]
    notIn?: $Enums.ApplicationStatus[]
    not?: NestedEnumApplicationStatusFilter<$PrismaModel> | $Enums.ApplicationStatus
  }

  export type JobPostScalarRelationFilter = {
    is?: JobPostWhereInput
    isNot?: JobPostWhereInput
  }

  export type ApplicationOrderByRelevanceInput = {
    fields: ApplicationOrderByRelevanceFieldEnum | ApplicationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    jobPostId?: SortOrder
    applicantUserId?: SortOrder
    applicantName?: SortOrder
    applicantEmail?: SortOrder
    resumeUrl?: SortOrder
    coverLetter?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    jobPostId?: SortOrder
    applicantUserId?: SortOrder
    applicantName?: SortOrder
    applicantEmail?: SortOrder
    resumeUrl?: SortOrder
    coverLetter?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    jobPostId?: SortOrder
    applicantUserId?: SortOrder
    applicantName?: SortOrder
    applicantEmail?: SortOrder
    resumeUrl?: SortOrder
    coverLetter?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[]
    notIn?: $Enums.ApplicationStatus[]
    not?: NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumApplicationStatusFilter<$PrismaModel>
  }

  export type EnumTrainingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingStatus | EnumTrainingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingStatus[]
    notIn?: $Enums.TrainingStatus[]
    not?: NestedEnumTrainingStatusFilter<$PrismaModel> | $Enums.TrainingStatus
  }

  export type TrainingProgramOrderByRelevanceInput = {
    fields: TrainingProgramOrderByRelevanceFieldEnum | TrainingProgramOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TrainingProgramCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    trainer?: SortOrder
    location?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    mode?: SortOrder
    maxSeats?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingProgramAvgOrderByAggregateInput = {
    maxSeats?: SortOrder
  }

  export type TrainingProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    trainer?: SortOrder
    location?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    mode?: SortOrder
    maxSeats?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingProgramMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    trainer?: SortOrder
    location?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    mode?: SortOrder
    maxSeats?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingProgramSumOrderByAggregateInput = {
    maxSeats?: SortOrder
  }

  export type EnumTrainingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingStatus | EnumTrainingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingStatus[]
    notIn?: $Enums.TrainingStatus[]
    not?: NestedEnumTrainingStatusWithAggregatesFilter<$PrismaModel> | $Enums.TrainingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrainingStatusFilter<$PrismaModel>
    _max?: NestedEnumTrainingStatusFilter<$PrismaModel>
  }

  export type TrainingProgramScalarRelationFilter = {
    is?: TrainingProgramWhereInput
    isNot?: TrainingProgramWhereInput
  }

  export type TrainingEnrollmentOrderByRelevanceInput = {
    fields: TrainingEnrollmentOrderByRelevanceFieldEnum | TrainingEnrollmentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TrainingEnrollmentTrainingIdUserIdCompoundUniqueInput = {
    trainingId: string
    userId: string
  }

  export type TrainingEnrollmentCountOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    userId?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrder
    certificateUrl?: SortOrder
  }

  export type TrainingEnrollmentMaxOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    userId?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrder
    certificateUrl?: SortOrder
  }

  export type TrainingEnrollmentMinOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    userId?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrder
    certificateUrl?: SortOrder
  }

  export type EnumEventSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.EventSource | EnumEventSourceFieldRefInput<$PrismaModel>
    in?: $Enums.EventSource[]
    notIn?: $Enums.EventSource[]
    not?: NestedEnumEventSourceFilter<$PrismaModel> | $Enums.EventSource
  }

  export type CalendarEventOrderByRelevanceInput = {
    fields: CalendarEventOrderByRelevanceFieldEnum | CalendarEventOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CalendarEventCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    organizerId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    source?: SortOrder
    googleMeetLink?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalendarEventMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    organizerId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    source?: SortOrder
    googleMeetLink?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalendarEventMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    organizerId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    source?: SortOrder
    googleMeetLink?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEventSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventSource | EnumEventSourceFieldRefInput<$PrismaModel>
    in?: $Enums.EventSource[]
    notIn?: $Enums.EventSource[]
    not?: NestedEnumEventSourceWithAggregatesFilter<$PrismaModel> | $Enums.EventSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventSourceFilter<$PrismaModel>
    _max?: NestedEnumEventSourceFilter<$PrismaModel>
  }

  export type CalendarEventScalarRelationFilter = {
    is?: CalendarEventWhereInput
    isNot?: CalendarEventWhereInput
  }

  export type CalendarAttendeeOrderByRelevanceInput = {
    fields: CalendarAttendeeOrderByRelevanceFieldEnum | CalendarAttendeeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CalendarAttendeeEventIdUserIdCompoundUniqueInput = {
    eventId: string
    userId: string
  }

  export type CalendarAttendeeCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    response?: SortOrder
  }

  export type CalendarAttendeeMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    response?: SortOrder
  }

  export type CalendarAttendeeMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    response?: SortOrder
  }

  export type UserPreferenceOrderByRelevanceInput = {
    fields: UserPreferenceOrderByRelevanceFieldEnum | UserPreferenceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserPreferenceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    theme?: SortOrder
    locale?: SortOrder
    notificationsEnabled?: SortOrder
  }

  export type UserPreferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    theme?: SortOrder
    locale?: SortOrder
    notificationsEnabled?: SortOrder
  }

  export type UserPreferenceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    theme?: SortOrder
    locale?: SortOrder
    notificationsEnabled?: SortOrder
  }

  export type AuditLogOrderByRelevanceInput = {
    fields: AuditLogOrderByRelevanceFieldEnum | AuditLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
  }

  export type DepartmentCreateNestedOneWithoutUsersInput = {
    create?: XOR<DepartmentCreateWithoutUsersInput, DepartmentUncheckedCreateWithoutUsersInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutUsersInput
    connect?: DepartmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReportsInput = {
    create?: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutManagerInput = {
    create?: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput> | UserCreateWithoutManagerInput[] | UserUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutManagerInput | UserCreateOrConnectWithoutManagerInput[]
    createMany?: UserCreateManyManagerInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TaskCreateWithoutCreatedByInput, TaskUncheckedCreateWithoutCreatedByInput> | TaskCreateWithoutCreatedByInput[] | TaskUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreatedByInput | TaskCreateOrConnectWithoutCreatedByInput[]
    createMany?: TaskCreateManyCreatedByInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskAssignmentCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskAssignmentCreateWithoutUserInput, TaskAssignmentUncheckedCreateWithoutUserInput> | TaskAssignmentCreateWithoutUserInput[] | TaskAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskAssignmentCreateOrConnectWithoutUserInput | TaskAssignmentCreateOrConnectWithoutUserInput[]
    createMany?: TaskAssignmentCreateManyUserInputEnvelope
    connect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
  }

  export type TaskCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskCommentCreateWithoutUserInput, TaskCommentUncheckedCreateWithoutUserInput> | TaskCommentCreateWithoutUserInput[] | TaskCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCommentCreateOrConnectWithoutUserInput | TaskCommentCreateOrConnectWithoutUserInput[]
    createMany?: TaskCommentCreateManyUserInputEnvelope
    connect?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
  }

  export type TaskTimeLogCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskTimeLogCreateWithoutUserInput, TaskTimeLogUncheckedCreateWithoutUserInput> | TaskTimeLogCreateWithoutUserInput[] | TaskTimeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskTimeLogCreateOrConnectWithoutUserInput | TaskTimeLogCreateOrConnectWithoutUserInput[]
    createMany?: TaskTimeLogCreateManyUserInputEnvelope
    connect?: TaskTimeLogWhereUniqueInput | TaskTimeLogWhereUniqueInput[]
  }

  export type AttendanceRecordCreateNestedManyWithoutUserInput = {
    create?: XOR<AttendanceRecordCreateWithoutUserInput, AttendanceRecordUncheckedCreateWithoutUserInput> | AttendanceRecordCreateWithoutUserInput[] | AttendanceRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutUserInput | AttendanceRecordCreateOrConnectWithoutUserInput[]
    createMany?: AttendanceRecordCreateManyUserInputEnvelope
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
  }

  export type LeaveCreateNestedManyWithoutUserInput = {
    create?: XOR<LeaveCreateWithoutUserInput, LeaveUncheckedCreateWithoutUserInput> | LeaveCreateWithoutUserInput[] | LeaveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutUserInput | LeaveCreateOrConnectWithoutUserInput[]
    createMany?: LeaveCreateManyUserInputEnvelope
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
  }

  export type LeaveCreateNestedManyWithoutApproverInput = {
    create?: XOR<LeaveCreateWithoutApproverInput, LeaveUncheckedCreateWithoutApproverInput> | LeaveCreateWithoutApproverInput[] | LeaveUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutApproverInput | LeaveCreateOrConnectWithoutApproverInput[]
    createMany?: LeaveCreateManyApproverInputEnvelope
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
  }

  export type ChatMessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type ChatMessageCreateNestedManyWithoutReceiverInput = {
    create?: XOR<ChatMessageCreateWithoutReceiverInput, ChatMessageUncheckedCreateWithoutReceiverInput> | ChatMessageCreateWithoutReceiverInput[] | ChatMessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutReceiverInput | ChatMessageCreateOrConnectWithoutReceiverInput[]
    createMany?: ChatMessageCreateManyReceiverInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type ChatGroupMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatGroupMemberCreateWithoutUserInput, ChatGroupMemberUncheckedCreateWithoutUserInput> | ChatGroupMemberCreateWithoutUserInput[] | ChatGroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatGroupMemberCreateOrConnectWithoutUserInput | ChatGroupMemberCreateOrConnectWithoutUserInput[]
    createMany?: ChatGroupMemberCreateManyUserInputEnvelope
    connect?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput> | DocumentCreateWithoutUserInput[] | DocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUserInput | DocumentCreateOrConnectWithoutUserInput[]
    createMany?: DocumentCreateManyUserInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type CompanyDocumentCreateNestedManyWithoutUploaderInput = {
    create?: XOR<CompanyDocumentCreateWithoutUploaderInput, CompanyDocumentUncheckedCreateWithoutUploaderInput> | CompanyDocumentCreateWithoutUploaderInput[] | CompanyDocumentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: CompanyDocumentCreateOrConnectWithoutUploaderInput | CompanyDocumentCreateOrConnectWithoutUploaderInput[]
    createMany?: CompanyDocumentCreateManyUploaderInputEnvelope
    connect?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
  }

  export type ExpenseCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ExpenseCreateWithoutOwnerInput, ExpenseUncheckedCreateWithoutOwnerInput> | ExpenseCreateWithoutOwnerInput[] | ExpenseUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutOwnerInput | ExpenseCreateOrConnectWithoutOwnerInput[]
    createMany?: ExpenseCreateManyOwnerInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type ExpenseCreateNestedManyWithoutApproverInput = {
    create?: XOR<ExpenseCreateWithoutApproverInput, ExpenseUncheckedCreateWithoutApproverInput> | ExpenseCreateWithoutApproverInput[] | ExpenseUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutApproverInput | ExpenseCreateOrConnectWithoutApproverInput[]
    createMany?: ExpenseCreateManyApproverInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type PayrollCreateNestedManyWithoutUserInput = {
    create?: XOR<PayrollCreateWithoutUserInput, PayrollUncheckedCreateWithoutUserInput> | PayrollCreateWithoutUserInput[] | PayrollUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutUserInput | PayrollCreateOrConnectWithoutUserInput[]
    createMany?: PayrollCreateManyUserInputEnvelope
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
  }

  export type PayrollCreateNestedManyWithoutGeneratedByInput = {
    create?: XOR<PayrollCreateWithoutGeneratedByInput, PayrollUncheckedCreateWithoutGeneratedByInput> | PayrollCreateWithoutGeneratedByInput[] | PayrollUncheckedCreateWithoutGeneratedByInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutGeneratedByInput | PayrollCreateOrConnectWithoutGeneratedByInput[]
    createMany?: PayrollCreateManyGeneratedByInputEnvelope
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
  }

  export type PerformanceReviewCreateNestedManyWithoutReviewerInput = {
    create?: XOR<PerformanceReviewCreateWithoutReviewerInput, PerformanceReviewUncheckedCreateWithoutReviewerInput> | PerformanceReviewCreateWithoutReviewerInput[] | PerformanceReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: PerformanceReviewCreateOrConnectWithoutReviewerInput | PerformanceReviewCreateOrConnectWithoutReviewerInput[]
    createMany?: PerformanceReviewCreateManyReviewerInputEnvelope
    connect?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
  }

  export type PerformanceReviewCreateNestedManyWithoutRevieweeInput = {
    create?: XOR<PerformanceReviewCreateWithoutRevieweeInput, PerformanceReviewUncheckedCreateWithoutRevieweeInput> | PerformanceReviewCreateWithoutRevieweeInput[] | PerformanceReviewUncheckedCreateWithoutRevieweeInput[]
    connectOrCreate?: PerformanceReviewCreateOrConnectWithoutRevieweeInput | PerformanceReviewCreateOrConnectWithoutRevieweeInput[]
    createMany?: PerformanceReviewCreateManyRevieweeInputEnvelope
    connect?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
  }

  export type AssetCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<AssetCreateWithoutAssignedToInput, AssetUncheckedCreateWithoutAssignedToInput> | AssetCreateWithoutAssignedToInput[] | AssetUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutAssignedToInput | AssetCreateOrConnectWithoutAssignedToInput[]
    createMany?: AssetCreateManyAssignedToInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type JobPostCreateNestedManyWithoutPostedByInput = {
    create?: XOR<JobPostCreateWithoutPostedByInput, JobPostUncheckedCreateWithoutPostedByInput> | JobPostCreateWithoutPostedByInput[] | JobPostUncheckedCreateWithoutPostedByInput[]
    connectOrCreate?: JobPostCreateOrConnectWithoutPostedByInput | JobPostCreateOrConnectWithoutPostedByInput[]
    createMany?: JobPostCreateManyPostedByInputEnvelope
    connect?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
  }

  export type ApplicationCreateNestedManyWithoutApplicantInput = {
    create?: XOR<ApplicationCreateWithoutApplicantInput, ApplicationUncheckedCreateWithoutApplicantInput> | ApplicationCreateWithoutApplicantInput[] | ApplicationUncheckedCreateWithoutApplicantInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutApplicantInput | ApplicationCreateOrConnectWithoutApplicantInput[]
    createMany?: ApplicationCreateManyApplicantInputEnvelope
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
  }

  export type CalendarEventCreateNestedManyWithoutOrganizerInput = {
    create?: XOR<CalendarEventCreateWithoutOrganizerInput, CalendarEventUncheckedCreateWithoutOrganizerInput> | CalendarEventCreateWithoutOrganizerInput[] | CalendarEventUncheckedCreateWithoutOrganizerInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutOrganizerInput | CalendarEventCreateOrConnectWithoutOrganizerInput[]
    createMany?: CalendarEventCreateManyOrganizerInputEnvelope
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
  }

  export type CalendarAttendeeCreateNestedManyWithoutUserInput = {
    create?: XOR<CalendarAttendeeCreateWithoutUserInput, CalendarAttendeeUncheckedCreateWithoutUserInput> | CalendarAttendeeCreateWithoutUserInput[] | CalendarAttendeeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CalendarAttendeeCreateOrConnectWithoutUserInput | CalendarAttendeeCreateOrConnectWithoutUserInput[]
    createMany?: CalendarAttendeeCreateManyUserInputEnvelope
    connect?: CalendarAttendeeWhereUniqueInput | CalendarAttendeeWhereUniqueInput[]
  }

  export type TrainingEnrollmentCreateNestedManyWithoutUserInput = {
    create?: XOR<TrainingEnrollmentCreateWithoutUserInput, TrainingEnrollmentUncheckedCreateWithoutUserInput> | TrainingEnrollmentCreateWithoutUserInput[] | TrainingEnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrainingEnrollmentCreateOrConnectWithoutUserInput | TrainingEnrollmentCreateOrConnectWithoutUserInput[]
    createMany?: TrainingEnrollmentCreateManyUserInputEnvelope
    connect?: TrainingEnrollmentWhereUniqueInput | TrainingEnrollmentWhereUniqueInput[]
  }

  export type AnnouncementCreateNestedManyWithoutAuthorInput = {
    create?: XOR<AnnouncementCreateWithoutAuthorInput, AnnouncementUncheckedCreateWithoutAuthorInput> | AnnouncementCreateWithoutAuthorInput[] | AnnouncementUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutAuthorInput | AnnouncementCreateOrConnectWithoutAuthorInput[]
    createMany?: AnnouncementCreateManyAuthorInputEnvelope
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
  }

  export type UserPreferenceCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPreferenceCreateWithoutUserInput, UserPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferenceCreateOrConnectWithoutUserInput
    connect?: UserPreferenceWhereUniqueInput
  }

  export type AuditLogCreateNestedManyWithoutActorInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type DepartmentCreateNestedManyWithoutHeadInput = {
    create?: XOR<DepartmentCreateWithoutHeadInput, DepartmentUncheckedCreateWithoutHeadInput> | DepartmentCreateWithoutHeadInput[] | DepartmentUncheckedCreateWithoutHeadInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutHeadInput | DepartmentCreateOrConnectWithoutHeadInput[]
    createMany?: DepartmentCreateManyHeadInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput> | UserCreateWithoutManagerInput[] | UserUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutManagerInput | UserCreateOrConnectWithoutManagerInput[]
    createMany?: UserCreateManyManagerInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TaskCreateWithoutCreatedByInput, TaskUncheckedCreateWithoutCreatedByInput> | TaskCreateWithoutCreatedByInput[] | TaskUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreatedByInput | TaskCreateOrConnectWithoutCreatedByInput[]
    createMany?: TaskCreateManyCreatedByInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskAssignmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskAssignmentCreateWithoutUserInput, TaskAssignmentUncheckedCreateWithoutUserInput> | TaskAssignmentCreateWithoutUserInput[] | TaskAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskAssignmentCreateOrConnectWithoutUserInput | TaskAssignmentCreateOrConnectWithoutUserInput[]
    createMany?: TaskAssignmentCreateManyUserInputEnvelope
    connect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
  }

  export type TaskCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskCommentCreateWithoutUserInput, TaskCommentUncheckedCreateWithoutUserInput> | TaskCommentCreateWithoutUserInput[] | TaskCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCommentCreateOrConnectWithoutUserInput | TaskCommentCreateOrConnectWithoutUserInput[]
    createMany?: TaskCommentCreateManyUserInputEnvelope
    connect?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
  }

  export type TaskTimeLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskTimeLogCreateWithoutUserInput, TaskTimeLogUncheckedCreateWithoutUserInput> | TaskTimeLogCreateWithoutUserInput[] | TaskTimeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskTimeLogCreateOrConnectWithoutUserInput | TaskTimeLogCreateOrConnectWithoutUserInput[]
    createMany?: TaskTimeLogCreateManyUserInputEnvelope
    connect?: TaskTimeLogWhereUniqueInput | TaskTimeLogWhereUniqueInput[]
  }

  export type AttendanceRecordUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AttendanceRecordCreateWithoutUserInput, AttendanceRecordUncheckedCreateWithoutUserInput> | AttendanceRecordCreateWithoutUserInput[] | AttendanceRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutUserInput | AttendanceRecordCreateOrConnectWithoutUserInput[]
    createMany?: AttendanceRecordCreateManyUserInputEnvelope
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
  }

  export type LeaveUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LeaveCreateWithoutUserInput, LeaveUncheckedCreateWithoutUserInput> | LeaveCreateWithoutUserInput[] | LeaveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutUserInput | LeaveCreateOrConnectWithoutUserInput[]
    createMany?: LeaveCreateManyUserInputEnvelope
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
  }

  export type LeaveUncheckedCreateNestedManyWithoutApproverInput = {
    create?: XOR<LeaveCreateWithoutApproverInput, LeaveUncheckedCreateWithoutApproverInput> | LeaveCreateWithoutApproverInput[] | LeaveUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutApproverInput | LeaveCreateOrConnectWithoutApproverInput[]
    createMany?: LeaveCreateManyApproverInputEnvelope
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<ChatMessageCreateWithoutReceiverInput, ChatMessageUncheckedCreateWithoutReceiverInput> | ChatMessageCreateWithoutReceiverInput[] | ChatMessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutReceiverInput | ChatMessageCreateOrConnectWithoutReceiverInput[]
    createMany?: ChatMessageCreateManyReceiverInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatGroupMemberCreateWithoutUserInput, ChatGroupMemberUncheckedCreateWithoutUserInput> | ChatGroupMemberCreateWithoutUserInput[] | ChatGroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatGroupMemberCreateOrConnectWithoutUserInput | ChatGroupMemberCreateOrConnectWithoutUserInput[]
    createMany?: ChatGroupMemberCreateManyUserInputEnvelope
    connect?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput> | DocumentCreateWithoutUserInput[] | DocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUserInput | DocumentCreateOrConnectWithoutUserInput[]
    createMany?: DocumentCreateManyUserInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput = {
    create?: XOR<CompanyDocumentCreateWithoutUploaderInput, CompanyDocumentUncheckedCreateWithoutUploaderInput> | CompanyDocumentCreateWithoutUploaderInput[] | CompanyDocumentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: CompanyDocumentCreateOrConnectWithoutUploaderInput | CompanyDocumentCreateOrConnectWithoutUploaderInput[]
    createMany?: CompanyDocumentCreateManyUploaderInputEnvelope
    connect?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ExpenseCreateWithoutOwnerInput, ExpenseUncheckedCreateWithoutOwnerInput> | ExpenseCreateWithoutOwnerInput[] | ExpenseUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutOwnerInput | ExpenseCreateOrConnectWithoutOwnerInput[]
    createMany?: ExpenseCreateManyOwnerInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutApproverInput = {
    create?: XOR<ExpenseCreateWithoutApproverInput, ExpenseUncheckedCreateWithoutApproverInput> | ExpenseCreateWithoutApproverInput[] | ExpenseUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutApproverInput | ExpenseCreateOrConnectWithoutApproverInput[]
    createMany?: ExpenseCreateManyApproverInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type PayrollUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PayrollCreateWithoutUserInput, PayrollUncheckedCreateWithoutUserInput> | PayrollCreateWithoutUserInput[] | PayrollUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutUserInput | PayrollCreateOrConnectWithoutUserInput[]
    createMany?: PayrollCreateManyUserInputEnvelope
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
  }

  export type PayrollUncheckedCreateNestedManyWithoutGeneratedByInput = {
    create?: XOR<PayrollCreateWithoutGeneratedByInput, PayrollUncheckedCreateWithoutGeneratedByInput> | PayrollCreateWithoutGeneratedByInput[] | PayrollUncheckedCreateWithoutGeneratedByInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutGeneratedByInput | PayrollCreateOrConnectWithoutGeneratedByInput[]
    createMany?: PayrollCreateManyGeneratedByInputEnvelope
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
  }

  export type PerformanceReviewUncheckedCreateNestedManyWithoutReviewerInput = {
    create?: XOR<PerformanceReviewCreateWithoutReviewerInput, PerformanceReviewUncheckedCreateWithoutReviewerInput> | PerformanceReviewCreateWithoutReviewerInput[] | PerformanceReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: PerformanceReviewCreateOrConnectWithoutReviewerInput | PerformanceReviewCreateOrConnectWithoutReviewerInput[]
    createMany?: PerformanceReviewCreateManyReviewerInputEnvelope
    connect?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
  }

  export type PerformanceReviewUncheckedCreateNestedManyWithoutRevieweeInput = {
    create?: XOR<PerformanceReviewCreateWithoutRevieweeInput, PerformanceReviewUncheckedCreateWithoutRevieweeInput> | PerformanceReviewCreateWithoutRevieweeInput[] | PerformanceReviewUncheckedCreateWithoutRevieweeInput[]
    connectOrCreate?: PerformanceReviewCreateOrConnectWithoutRevieweeInput | PerformanceReviewCreateOrConnectWithoutRevieweeInput[]
    createMany?: PerformanceReviewCreateManyRevieweeInputEnvelope
    connect?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
  }

  export type AssetUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<AssetCreateWithoutAssignedToInput, AssetUncheckedCreateWithoutAssignedToInput> | AssetCreateWithoutAssignedToInput[] | AssetUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutAssignedToInput | AssetCreateOrConnectWithoutAssignedToInput[]
    createMany?: AssetCreateManyAssignedToInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type JobPostUncheckedCreateNestedManyWithoutPostedByInput = {
    create?: XOR<JobPostCreateWithoutPostedByInput, JobPostUncheckedCreateWithoutPostedByInput> | JobPostCreateWithoutPostedByInput[] | JobPostUncheckedCreateWithoutPostedByInput[]
    connectOrCreate?: JobPostCreateOrConnectWithoutPostedByInput | JobPostCreateOrConnectWithoutPostedByInput[]
    createMany?: JobPostCreateManyPostedByInputEnvelope
    connect?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
  }

  export type ApplicationUncheckedCreateNestedManyWithoutApplicantInput = {
    create?: XOR<ApplicationCreateWithoutApplicantInput, ApplicationUncheckedCreateWithoutApplicantInput> | ApplicationCreateWithoutApplicantInput[] | ApplicationUncheckedCreateWithoutApplicantInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutApplicantInput | ApplicationCreateOrConnectWithoutApplicantInput[]
    createMany?: ApplicationCreateManyApplicantInputEnvelope
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
  }

  export type CalendarEventUncheckedCreateNestedManyWithoutOrganizerInput = {
    create?: XOR<CalendarEventCreateWithoutOrganizerInput, CalendarEventUncheckedCreateWithoutOrganizerInput> | CalendarEventCreateWithoutOrganizerInput[] | CalendarEventUncheckedCreateWithoutOrganizerInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutOrganizerInput | CalendarEventCreateOrConnectWithoutOrganizerInput[]
    createMany?: CalendarEventCreateManyOrganizerInputEnvelope
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
  }

  export type CalendarAttendeeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CalendarAttendeeCreateWithoutUserInput, CalendarAttendeeUncheckedCreateWithoutUserInput> | CalendarAttendeeCreateWithoutUserInput[] | CalendarAttendeeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CalendarAttendeeCreateOrConnectWithoutUserInput | CalendarAttendeeCreateOrConnectWithoutUserInput[]
    createMany?: CalendarAttendeeCreateManyUserInputEnvelope
    connect?: CalendarAttendeeWhereUniqueInput | CalendarAttendeeWhereUniqueInput[]
  }

  export type TrainingEnrollmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TrainingEnrollmentCreateWithoutUserInput, TrainingEnrollmentUncheckedCreateWithoutUserInput> | TrainingEnrollmentCreateWithoutUserInput[] | TrainingEnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrainingEnrollmentCreateOrConnectWithoutUserInput | TrainingEnrollmentCreateOrConnectWithoutUserInput[]
    createMany?: TrainingEnrollmentCreateManyUserInputEnvelope
    connect?: TrainingEnrollmentWhereUniqueInput | TrainingEnrollmentWhereUniqueInput[]
  }

  export type AnnouncementUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<AnnouncementCreateWithoutAuthorInput, AnnouncementUncheckedCreateWithoutAuthorInput> | AnnouncementCreateWithoutAuthorInput[] | AnnouncementUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutAuthorInput | AnnouncementCreateOrConnectWithoutAuthorInput[]
    createMany?: AnnouncementCreateManyAuthorInputEnvelope
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
  }

  export type UserPreferenceUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPreferenceCreateWithoutUserInput, UserPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferenceCreateOrConnectWithoutUserInput
    connect?: UserPreferenceWhereUniqueInput
  }

  export type AuditLogUncheckedCreateNestedManyWithoutActorInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type DepartmentUncheckedCreateNestedManyWithoutHeadInput = {
    create?: XOR<DepartmentCreateWithoutHeadInput, DepartmentUncheckedCreateWithoutHeadInput> | DepartmentCreateWithoutHeadInput[] | DepartmentUncheckedCreateWithoutHeadInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutHeadInput | DepartmentCreateOrConnectWithoutHeadInput[]
    createMany?: DepartmentCreateManyHeadInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type EnumEmploymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.EmploymentStatus
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type DepartmentUpdateOneWithoutUsersNestedInput = {
    create?: XOR<DepartmentCreateWithoutUsersInput, DepartmentUncheckedCreateWithoutUsersInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutUsersInput
    upsert?: DepartmentUpsertWithoutUsersInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutUsersInput, DepartmentUpdateWithoutUsersInput>, DepartmentUncheckedUpdateWithoutUsersInput>
  }

  export type UserUpdateOneWithoutReportsNestedInput = {
    create?: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsInput
    upsert?: UserUpsertWithoutReportsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportsInput, UserUpdateWithoutReportsInput>, UserUncheckedUpdateWithoutReportsInput>
  }

  export type UserUpdateManyWithoutManagerNestedInput = {
    create?: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput> | UserCreateWithoutManagerInput[] | UserUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutManagerInput | UserCreateOrConnectWithoutManagerInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutManagerInput | UserUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: UserCreateManyManagerInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutManagerInput | UserUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: UserUpdateManyWithWhereWithoutManagerInput | UserUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TaskCreateWithoutCreatedByInput, TaskUncheckedCreateWithoutCreatedByInput> | TaskCreateWithoutCreatedByInput[] | TaskUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreatedByInput | TaskCreateOrConnectWithoutCreatedByInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutCreatedByInput | TaskUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TaskCreateManyCreatedByInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutCreatedByInput | TaskUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutCreatedByInput | TaskUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskAssignmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskAssignmentCreateWithoutUserInput, TaskAssignmentUncheckedCreateWithoutUserInput> | TaskAssignmentCreateWithoutUserInput[] | TaskAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskAssignmentCreateOrConnectWithoutUserInput | TaskAssignmentCreateOrConnectWithoutUserInput[]
    upsert?: TaskAssignmentUpsertWithWhereUniqueWithoutUserInput | TaskAssignmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskAssignmentCreateManyUserInputEnvelope
    set?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    disconnect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    delete?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    connect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    update?: TaskAssignmentUpdateWithWhereUniqueWithoutUserInput | TaskAssignmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskAssignmentUpdateManyWithWhereWithoutUserInput | TaskAssignmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskAssignmentScalarWhereInput | TaskAssignmentScalarWhereInput[]
  }

  export type TaskCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskCommentCreateWithoutUserInput, TaskCommentUncheckedCreateWithoutUserInput> | TaskCommentCreateWithoutUserInput[] | TaskCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCommentCreateOrConnectWithoutUserInput | TaskCommentCreateOrConnectWithoutUserInput[]
    upsert?: TaskCommentUpsertWithWhereUniqueWithoutUserInput | TaskCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskCommentCreateManyUserInputEnvelope
    set?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    disconnect?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    delete?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    connect?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    update?: TaskCommentUpdateWithWhereUniqueWithoutUserInput | TaskCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskCommentUpdateManyWithWhereWithoutUserInput | TaskCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskCommentScalarWhereInput | TaskCommentScalarWhereInput[]
  }

  export type TaskTimeLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskTimeLogCreateWithoutUserInput, TaskTimeLogUncheckedCreateWithoutUserInput> | TaskTimeLogCreateWithoutUserInput[] | TaskTimeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskTimeLogCreateOrConnectWithoutUserInput | TaskTimeLogCreateOrConnectWithoutUserInput[]
    upsert?: TaskTimeLogUpsertWithWhereUniqueWithoutUserInput | TaskTimeLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskTimeLogCreateManyUserInputEnvelope
    set?: TaskTimeLogWhereUniqueInput | TaskTimeLogWhereUniqueInput[]
    disconnect?: TaskTimeLogWhereUniqueInput | TaskTimeLogWhereUniqueInput[]
    delete?: TaskTimeLogWhereUniqueInput | TaskTimeLogWhereUniqueInput[]
    connect?: TaskTimeLogWhereUniqueInput | TaskTimeLogWhereUniqueInput[]
    update?: TaskTimeLogUpdateWithWhereUniqueWithoutUserInput | TaskTimeLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskTimeLogUpdateManyWithWhereWithoutUserInput | TaskTimeLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskTimeLogScalarWhereInput | TaskTimeLogScalarWhereInput[]
  }

  export type AttendanceRecordUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttendanceRecordCreateWithoutUserInput, AttendanceRecordUncheckedCreateWithoutUserInput> | AttendanceRecordCreateWithoutUserInput[] | AttendanceRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutUserInput | AttendanceRecordCreateOrConnectWithoutUserInput[]
    upsert?: AttendanceRecordUpsertWithWhereUniqueWithoutUserInput | AttendanceRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttendanceRecordCreateManyUserInputEnvelope
    set?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    disconnect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    delete?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    update?: AttendanceRecordUpdateWithWhereUniqueWithoutUserInput | AttendanceRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttendanceRecordUpdateManyWithWhereWithoutUserInput | AttendanceRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
  }

  export type LeaveUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeaveCreateWithoutUserInput, LeaveUncheckedCreateWithoutUserInput> | LeaveCreateWithoutUserInput[] | LeaveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutUserInput | LeaveCreateOrConnectWithoutUserInput[]
    upsert?: LeaveUpsertWithWhereUniqueWithoutUserInput | LeaveUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LeaveCreateManyUserInputEnvelope
    set?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    disconnect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    delete?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    update?: LeaveUpdateWithWhereUniqueWithoutUserInput | LeaveUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeaveUpdateManyWithWhereWithoutUserInput | LeaveUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
  }

  export type LeaveUpdateManyWithoutApproverNestedInput = {
    create?: XOR<LeaveCreateWithoutApproverInput, LeaveUncheckedCreateWithoutApproverInput> | LeaveCreateWithoutApproverInput[] | LeaveUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutApproverInput | LeaveCreateOrConnectWithoutApproverInput[]
    upsert?: LeaveUpsertWithWhereUniqueWithoutApproverInput | LeaveUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: LeaveCreateManyApproverInputEnvelope
    set?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    disconnect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    delete?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    update?: LeaveUpdateWithWhereUniqueWithoutApproverInput | LeaveUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: LeaveUpdateManyWithWhereWithoutApproverInput | LeaveUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
  }

  export type ChatMessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutSenderInput | ChatMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutSenderInput | ChatMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutSenderInput | ChatMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatMessageUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<ChatMessageCreateWithoutReceiverInput, ChatMessageUncheckedCreateWithoutReceiverInput> | ChatMessageCreateWithoutReceiverInput[] | ChatMessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutReceiverInput | ChatMessageCreateOrConnectWithoutReceiverInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutReceiverInput | ChatMessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: ChatMessageCreateManyReceiverInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutReceiverInput | ChatMessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutReceiverInput | ChatMessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatGroupMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatGroupMemberCreateWithoutUserInput, ChatGroupMemberUncheckedCreateWithoutUserInput> | ChatGroupMemberCreateWithoutUserInput[] | ChatGroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatGroupMemberCreateOrConnectWithoutUserInput | ChatGroupMemberCreateOrConnectWithoutUserInput[]
    upsert?: ChatGroupMemberUpsertWithWhereUniqueWithoutUserInput | ChatGroupMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatGroupMemberCreateManyUserInputEnvelope
    set?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
    disconnect?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
    delete?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
    connect?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
    update?: ChatGroupMemberUpdateWithWhereUniqueWithoutUserInput | ChatGroupMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatGroupMemberUpdateManyWithWhereWithoutUserInput | ChatGroupMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatGroupMemberScalarWhereInput | ChatGroupMemberScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput> | DocumentCreateWithoutUserInput[] | DocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUserInput | DocumentCreateOrConnectWithoutUserInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutUserInput | DocumentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentCreateManyUserInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutUserInput | DocumentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutUserInput | DocumentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type CompanyDocumentUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<CompanyDocumentCreateWithoutUploaderInput, CompanyDocumentUncheckedCreateWithoutUploaderInput> | CompanyDocumentCreateWithoutUploaderInput[] | CompanyDocumentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: CompanyDocumentCreateOrConnectWithoutUploaderInput | CompanyDocumentCreateOrConnectWithoutUploaderInput[]
    upsert?: CompanyDocumentUpsertWithWhereUniqueWithoutUploaderInput | CompanyDocumentUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: CompanyDocumentCreateManyUploaderInputEnvelope
    set?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    disconnect?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    delete?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    connect?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    update?: CompanyDocumentUpdateWithWhereUniqueWithoutUploaderInput | CompanyDocumentUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: CompanyDocumentUpdateManyWithWhereWithoutUploaderInput | CompanyDocumentUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: CompanyDocumentScalarWhereInput | CompanyDocumentScalarWhereInput[]
  }

  export type ExpenseUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ExpenseCreateWithoutOwnerInput, ExpenseUncheckedCreateWithoutOwnerInput> | ExpenseCreateWithoutOwnerInput[] | ExpenseUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutOwnerInput | ExpenseCreateOrConnectWithoutOwnerInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutOwnerInput | ExpenseUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ExpenseCreateManyOwnerInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutOwnerInput | ExpenseUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutOwnerInput | ExpenseUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type ExpenseUpdateManyWithoutApproverNestedInput = {
    create?: XOR<ExpenseCreateWithoutApproverInput, ExpenseUncheckedCreateWithoutApproverInput> | ExpenseCreateWithoutApproverInput[] | ExpenseUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutApproverInput | ExpenseCreateOrConnectWithoutApproverInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutApproverInput | ExpenseUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: ExpenseCreateManyApproverInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutApproverInput | ExpenseUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutApproverInput | ExpenseUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type PayrollUpdateManyWithoutUserNestedInput = {
    create?: XOR<PayrollCreateWithoutUserInput, PayrollUncheckedCreateWithoutUserInput> | PayrollCreateWithoutUserInput[] | PayrollUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutUserInput | PayrollCreateOrConnectWithoutUserInput[]
    upsert?: PayrollUpsertWithWhereUniqueWithoutUserInput | PayrollUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PayrollCreateManyUserInputEnvelope
    set?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    disconnect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    delete?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    update?: PayrollUpdateWithWhereUniqueWithoutUserInput | PayrollUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PayrollUpdateManyWithWhereWithoutUserInput | PayrollUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
  }

  export type PayrollUpdateManyWithoutGeneratedByNestedInput = {
    create?: XOR<PayrollCreateWithoutGeneratedByInput, PayrollUncheckedCreateWithoutGeneratedByInput> | PayrollCreateWithoutGeneratedByInput[] | PayrollUncheckedCreateWithoutGeneratedByInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutGeneratedByInput | PayrollCreateOrConnectWithoutGeneratedByInput[]
    upsert?: PayrollUpsertWithWhereUniqueWithoutGeneratedByInput | PayrollUpsertWithWhereUniqueWithoutGeneratedByInput[]
    createMany?: PayrollCreateManyGeneratedByInputEnvelope
    set?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    disconnect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    delete?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    update?: PayrollUpdateWithWhereUniqueWithoutGeneratedByInput | PayrollUpdateWithWhereUniqueWithoutGeneratedByInput[]
    updateMany?: PayrollUpdateManyWithWhereWithoutGeneratedByInput | PayrollUpdateManyWithWhereWithoutGeneratedByInput[]
    deleteMany?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
  }

  export type PerformanceReviewUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<PerformanceReviewCreateWithoutReviewerInput, PerformanceReviewUncheckedCreateWithoutReviewerInput> | PerformanceReviewCreateWithoutReviewerInput[] | PerformanceReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: PerformanceReviewCreateOrConnectWithoutReviewerInput | PerformanceReviewCreateOrConnectWithoutReviewerInput[]
    upsert?: PerformanceReviewUpsertWithWhereUniqueWithoutReviewerInput | PerformanceReviewUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: PerformanceReviewCreateManyReviewerInputEnvelope
    set?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    disconnect?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    delete?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    connect?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    update?: PerformanceReviewUpdateWithWhereUniqueWithoutReviewerInput | PerformanceReviewUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: PerformanceReviewUpdateManyWithWhereWithoutReviewerInput | PerformanceReviewUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: PerformanceReviewScalarWhereInput | PerformanceReviewScalarWhereInput[]
  }

  export type PerformanceReviewUpdateManyWithoutRevieweeNestedInput = {
    create?: XOR<PerformanceReviewCreateWithoutRevieweeInput, PerformanceReviewUncheckedCreateWithoutRevieweeInput> | PerformanceReviewCreateWithoutRevieweeInput[] | PerformanceReviewUncheckedCreateWithoutRevieweeInput[]
    connectOrCreate?: PerformanceReviewCreateOrConnectWithoutRevieweeInput | PerformanceReviewCreateOrConnectWithoutRevieweeInput[]
    upsert?: PerformanceReviewUpsertWithWhereUniqueWithoutRevieweeInput | PerformanceReviewUpsertWithWhereUniqueWithoutRevieweeInput[]
    createMany?: PerformanceReviewCreateManyRevieweeInputEnvelope
    set?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    disconnect?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    delete?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    connect?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    update?: PerformanceReviewUpdateWithWhereUniqueWithoutRevieweeInput | PerformanceReviewUpdateWithWhereUniqueWithoutRevieweeInput[]
    updateMany?: PerformanceReviewUpdateManyWithWhereWithoutRevieweeInput | PerformanceReviewUpdateManyWithWhereWithoutRevieweeInput[]
    deleteMany?: PerformanceReviewScalarWhereInput | PerformanceReviewScalarWhereInput[]
  }

  export type AssetUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<AssetCreateWithoutAssignedToInput, AssetUncheckedCreateWithoutAssignedToInput> | AssetCreateWithoutAssignedToInput[] | AssetUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutAssignedToInput | AssetCreateOrConnectWithoutAssignedToInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutAssignedToInput | AssetUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: AssetCreateManyAssignedToInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutAssignedToInput | AssetUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutAssignedToInput | AssetUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type JobPostUpdateManyWithoutPostedByNestedInput = {
    create?: XOR<JobPostCreateWithoutPostedByInput, JobPostUncheckedCreateWithoutPostedByInput> | JobPostCreateWithoutPostedByInput[] | JobPostUncheckedCreateWithoutPostedByInput[]
    connectOrCreate?: JobPostCreateOrConnectWithoutPostedByInput | JobPostCreateOrConnectWithoutPostedByInput[]
    upsert?: JobPostUpsertWithWhereUniqueWithoutPostedByInput | JobPostUpsertWithWhereUniqueWithoutPostedByInput[]
    createMany?: JobPostCreateManyPostedByInputEnvelope
    set?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
    disconnect?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
    delete?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
    connect?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
    update?: JobPostUpdateWithWhereUniqueWithoutPostedByInput | JobPostUpdateWithWhereUniqueWithoutPostedByInput[]
    updateMany?: JobPostUpdateManyWithWhereWithoutPostedByInput | JobPostUpdateManyWithWhereWithoutPostedByInput[]
    deleteMany?: JobPostScalarWhereInput | JobPostScalarWhereInput[]
  }

  export type ApplicationUpdateManyWithoutApplicantNestedInput = {
    create?: XOR<ApplicationCreateWithoutApplicantInput, ApplicationUncheckedCreateWithoutApplicantInput> | ApplicationCreateWithoutApplicantInput[] | ApplicationUncheckedCreateWithoutApplicantInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutApplicantInput | ApplicationCreateOrConnectWithoutApplicantInput[]
    upsert?: ApplicationUpsertWithWhereUniqueWithoutApplicantInput | ApplicationUpsertWithWhereUniqueWithoutApplicantInput[]
    createMany?: ApplicationCreateManyApplicantInputEnvelope
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    update?: ApplicationUpdateWithWhereUniqueWithoutApplicantInput | ApplicationUpdateWithWhereUniqueWithoutApplicantInput[]
    updateMany?: ApplicationUpdateManyWithWhereWithoutApplicantInput | ApplicationUpdateManyWithWhereWithoutApplicantInput[]
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
  }

  export type CalendarEventUpdateManyWithoutOrganizerNestedInput = {
    create?: XOR<CalendarEventCreateWithoutOrganizerInput, CalendarEventUncheckedCreateWithoutOrganizerInput> | CalendarEventCreateWithoutOrganizerInput[] | CalendarEventUncheckedCreateWithoutOrganizerInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutOrganizerInput | CalendarEventCreateOrConnectWithoutOrganizerInput[]
    upsert?: CalendarEventUpsertWithWhereUniqueWithoutOrganizerInput | CalendarEventUpsertWithWhereUniqueWithoutOrganizerInput[]
    createMany?: CalendarEventCreateManyOrganizerInputEnvelope
    set?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    disconnect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    delete?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    update?: CalendarEventUpdateWithWhereUniqueWithoutOrganizerInput | CalendarEventUpdateWithWhereUniqueWithoutOrganizerInput[]
    updateMany?: CalendarEventUpdateManyWithWhereWithoutOrganizerInput | CalendarEventUpdateManyWithWhereWithoutOrganizerInput[]
    deleteMany?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
  }

  export type CalendarAttendeeUpdateManyWithoutUserNestedInput = {
    create?: XOR<CalendarAttendeeCreateWithoutUserInput, CalendarAttendeeUncheckedCreateWithoutUserInput> | CalendarAttendeeCreateWithoutUserInput[] | CalendarAttendeeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CalendarAttendeeCreateOrConnectWithoutUserInput | CalendarAttendeeCreateOrConnectWithoutUserInput[]
    upsert?: CalendarAttendeeUpsertWithWhereUniqueWithoutUserInput | CalendarAttendeeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CalendarAttendeeCreateManyUserInputEnvelope
    set?: CalendarAttendeeWhereUniqueInput | CalendarAttendeeWhereUniqueInput[]
    disconnect?: CalendarAttendeeWhereUniqueInput | CalendarAttendeeWhereUniqueInput[]
    delete?: CalendarAttendeeWhereUniqueInput | CalendarAttendeeWhereUniqueInput[]
    connect?: CalendarAttendeeWhereUniqueInput | CalendarAttendeeWhereUniqueInput[]
    update?: CalendarAttendeeUpdateWithWhereUniqueWithoutUserInput | CalendarAttendeeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CalendarAttendeeUpdateManyWithWhereWithoutUserInput | CalendarAttendeeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CalendarAttendeeScalarWhereInput | CalendarAttendeeScalarWhereInput[]
  }

  export type TrainingEnrollmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<TrainingEnrollmentCreateWithoutUserInput, TrainingEnrollmentUncheckedCreateWithoutUserInput> | TrainingEnrollmentCreateWithoutUserInput[] | TrainingEnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrainingEnrollmentCreateOrConnectWithoutUserInput | TrainingEnrollmentCreateOrConnectWithoutUserInput[]
    upsert?: TrainingEnrollmentUpsertWithWhereUniqueWithoutUserInput | TrainingEnrollmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TrainingEnrollmentCreateManyUserInputEnvelope
    set?: TrainingEnrollmentWhereUniqueInput | TrainingEnrollmentWhereUniqueInput[]
    disconnect?: TrainingEnrollmentWhereUniqueInput | TrainingEnrollmentWhereUniqueInput[]
    delete?: TrainingEnrollmentWhereUniqueInput | TrainingEnrollmentWhereUniqueInput[]
    connect?: TrainingEnrollmentWhereUniqueInput | TrainingEnrollmentWhereUniqueInput[]
    update?: TrainingEnrollmentUpdateWithWhereUniqueWithoutUserInput | TrainingEnrollmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TrainingEnrollmentUpdateManyWithWhereWithoutUserInput | TrainingEnrollmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TrainingEnrollmentScalarWhereInput | TrainingEnrollmentScalarWhereInput[]
  }

  export type AnnouncementUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<AnnouncementCreateWithoutAuthorInput, AnnouncementUncheckedCreateWithoutAuthorInput> | AnnouncementCreateWithoutAuthorInput[] | AnnouncementUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutAuthorInput | AnnouncementCreateOrConnectWithoutAuthorInput[]
    upsert?: AnnouncementUpsertWithWhereUniqueWithoutAuthorInput | AnnouncementUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: AnnouncementCreateManyAuthorInputEnvelope
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    update?: AnnouncementUpdateWithWhereUniqueWithoutAuthorInput | AnnouncementUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: AnnouncementUpdateManyWithWhereWithoutAuthorInput | AnnouncementUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
  }

  export type UserPreferenceUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPreferenceCreateWithoutUserInput, UserPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferenceCreateOrConnectWithoutUserInput
    upsert?: UserPreferenceUpsertWithoutUserInput
    disconnect?: UserPreferenceWhereInput | boolean
    delete?: UserPreferenceWhereInput | boolean
    connect?: UserPreferenceWhereUniqueInput
    update?: XOR<XOR<UserPreferenceUpdateToOneWithWhereWithoutUserInput, UserPreferenceUpdateWithoutUserInput>, UserPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithoutActorNestedInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutActorInput | AuditLogUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutActorInput | AuditLogUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutActorInput | AuditLogUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type DepartmentUpdateManyWithoutHeadNestedInput = {
    create?: XOR<DepartmentCreateWithoutHeadInput, DepartmentUncheckedCreateWithoutHeadInput> | DepartmentCreateWithoutHeadInput[] | DepartmentUncheckedCreateWithoutHeadInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutHeadInput | DepartmentCreateOrConnectWithoutHeadInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutHeadInput | DepartmentUpsertWithWhereUniqueWithoutHeadInput[]
    createMany?: DepartmentCreateManyHeadInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutHeadInput | DepartmentUpdateWithWhereUniqueWithoutHeadInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutHeadInput | DepartmentUpdateManyWithWhereWithoutHeadInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput> | UserCreateWithoutManagerInput[] | UserUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutManagerInput | UserCreateOrConnectWithoutManagerInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutManagerInput | UserUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: UserCreateManyManagerInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutManagerInput | UserUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: UserUpdateManyWithWhereWithoutManagerInput | UserUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TaskCreateWithoutCreatedByInput, TaskUncheckedCreateWithoutCreatedByInput> | TaskCreateWithoutCreatedByInput[] | TaskUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreatedByInput | TaskCreateOrConnectWithoutCreatedByInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutCreatedByInput | TaskUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TaskCreateManyCreatedByInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutCreatedByInput | TaskUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutCreatedByInput | TaskUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskAssignmentCreateWithoutUserInput, TaskAssignmentUncheckedCreateWithoutUserInput> | TaskAssignmentCreateWithoutUserInput[] | TaskAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskAssignmentCreateOrConnectWithoutUserInput | TaskAssignmentCreateOrConnectWithoutUserInput[]
    upsert?: TaskAssignmentUpsertWithWhereUniqueWithoutUserInput | TaskAssignmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskAssignmentCreateManyUserInputEnvelope
    set?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    disconnect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    delete?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    connect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    update?: TaskAssignmentUpdateWithWhereUniqueWithoutUserInput | TaskAssignmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskAssignmentUpdateManyWithWhereWithoutUserInput | TaskAssignmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskAssignmentScalarWhereInput | TaskAssignmentScalarWhereInput[]
  }

  export type TaskCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskCommentCreateWithoutUserInput, TaskCommentUncheckedCreateWithoutUserInput> | TaskCommentCreateWithoutUserInput[] | TaskCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCommentCreateOrConnectWithoutUserInput | TaskCommentCreateOrConnectWithoutUserInput[]
    upsert?: TaskCommentUpsertWithWhereUniqueWithoutUserInput | TaskCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskCommentCreateManyUserInputEnvelope
    set?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    disconnect?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    delete?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    connect?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    update?: TaskCommentUpdateWithWhereUniqueWithoutUserInput | TaskCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskCommentUpdateManyWithWhereWithoutUserInput | TaskCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskCommentScalarWhereInput | TaskCommentScalarWhereInput[]
  }

  export type TaskTimeLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskTimeLogCreateWithoutUserInput, TaskTimeLogUncheckedCreateWithoutUserInput> | TaskTimeLogCreateWithoutUserInput[] | TaskTimeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskTimeLogCreateOrConnectWithoutUserInput | TaskTimeLogCreateOrConnectWithoutUserInput[]
    upsert?: TaskTimeLogUpsertWithWhereUniqueWithoutUserInput | TaskTimeLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskTimeLogCreateManyUserInputEnvelope
    set?: TaskTimeLogWhereUniqueInput | TaskTimeLogWhereUniqueInput[]
    disconnect?: TaskTimeLogWhereUniqueInput | TaskTimeLogWhereUniqueInput[]
    delete?: TaskTimeLogWhereUniqueInput | TaskTimeLogWhereUniqueInput[]
    connect?: TaskTimeLogWhereUniqueInput | TaskTimeLogWhereUniqueInput[]
    update?: TaskTimeLogUpdateWithWhereUniqueWithoutUserInput | TaskTimeLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskTimeLogUpdateManyWithWhereWithoutUserInput | TaskTimeLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskTimeLogScalarWhereInput | TaskTimeLogScalarWhereInput[]
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttendanceRecordCreateWithoutUserInput, AttendanceRecordUncheckedCreateWithoutUserInput> | AttendanceRecordCreateWithoutUserInput[] | AttendanceRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutUserInput | AttendanceRecordCreateOrConnectWithoutUserInput[]
    upsert?: AttendanceRecordUpsertWithWhereUniqueWithoutUserInput | AttendanceRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttendanceRecordCreateManyUserInputEnvelope
    set?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    disconnect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    delete?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    update?: AttendanceRecordUpdateWithWhereUniqueWithoutUserInput | AttendanceRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttendanceRecordUpdateManyWithWhereWithoutUserInput | AttendanceRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
  }

  export type LeaveUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeaveCreateWithoutUserInput, LeaveUncheckedCreateWithoutUserInput> | LeaveCreateWithoutUserInput[] | LeaveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutUserInput | LeaveCreateOrConnectWithoutUserInput[]
    upsert?: LeaveUpsertWithWhereUniqueWithoutUserInput | LeaveUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LeaveCreateManyUserInputEnvelope
    set?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    disconnect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    delete?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    update?: LeaveUpdateWithWhereUniqueWithoutUserInput | LeaveUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeaveUpdateManyWithWhereWithoutUserInput | LeaveUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
  }

  export type LeaveUncheckedUpdateManyWithoutApproverNestedInput = {
    create?: XOR<LeaveCreateWithoutApproverInput, LeaveUncheckedCreateWithoutApproverInput> | LeaveCreateWithoutApproverInput[] | LeaveUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutApproverInput | LeaveCreateOrConnectWithoutApproverInput[]
    upsert?: LeaveUpsertWithWhereUniqueWithoutApproverInput | LeaveUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: LeaveCreateManyApproverInputEnvelope
    set?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    disconnect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    delete?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    update?: LeaveUpdateWithWhereUniqueWithoutApproverInput | LeaveUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: LeaveUpdateManyWithWhereWithoutApproverInput | LeaveUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
  }

  export type ChatMessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutSenderInput | ChatMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutSenderInput | ChatMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutSenderInput | ChatMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<ChatMessageCreateWithoutReceiverInput, ChatMessageUncheckedCreateWithoutReceiverInput> | ChatMessageCreateWithoutReceiverInput[] | ChatMessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutReceiverInput | ChatMessageCreateOrConnectWithoutReceiverInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutReceiverInput | ChatMessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: ChatMessageCreateManyReceiverInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutReceiverInput | ChatMessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutReceiverInput | ChatMessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatGroupMemberCreateWithoutUserInput, ChatGroupMemberUncheckedCreateWithoutUserInput> | ChatGroupMemberCreateWithoutUserInput[] | ChatGroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatGroupMemberCreateOrConnectWithoutUserInput | ChatGroupMemberCreateOrConnectWithoutUserInput[]
    upsert?: ChatGroupMemberUpsertWithWhereUniqueWithoutUserInput | ChatGroupMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatGroupMemberCreateManyUserInputEnvelope
    set?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
    disconnect?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
    delete?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
    connect?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
    update?: ChatGroupMemberUpdateWithWhereUniqueWithoutUserInput | ChatGroupMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatGroupMemberUpdateManyWithWhereWithoutUserInput | ChatGroupMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatGroupMemberScalarWhereInput | ChatGroupMemberScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput> | DocumentCreateWithoutUserInput[] | DocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUserInput | DocumentCreateOrConnectWithoutUserInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutUserInput | DocumentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentCreateManyUserInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutUserInput | DocumentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutUserInput | DocumentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<CompanyDocumentCreateWithoutUploaderInput, CompanyDocumentUncheckedCreateWithoutUploaderInput> | CompanyDocumentCreateWithoutUploaderInput[] | CompanyDocumentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: CompanyDocumentCreateOrConnectWithoutUploaderInput | CompanyDocumentCreateOrConnectWithoutUploaderInput[]
    upsert?: CompanyDocumentUpsertWithWhereUniqueWithoutUploaderInput | CompanyDocumentUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: CompanyDocumentCreateManyUploaderInputEnvelope
    set?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    disconnect?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    delete?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    connect?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    update?: CompanyDocumentUpdateWithWhereUniqueWithoutUploaderInput | CompanyDocumentUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: CompanyDocumentUpdateManyWithWhereWithoutUploaderInput | CompanyDocumentUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: CompanyDocumentScalarWhereInput | CompanyDocumentScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ExpenseCreateWithoutOwnerInput, ExpenseUncheckedCreateWithoutOwnerInput> | ExpenseCreateWithoutOwnerInput[] | ExpenseUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutOwnerInput | ExpenseCreateOrConnectWithoutOwnerInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutOwnerInput | ExpenseUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ExpenseCreateManyOwnerInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutOwnerInput | ExpenseUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutOwnerInput | ExpenseUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutApproverNestedInput = {
    create?: XOR<ExpenseCreateWithoutApproverInput, ExpenseUncheckedCreateWithoutApproverInput> | ExpenseCreateWithoutApproverInput[] | ExpenseUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutApproverInput | ExpenseCreateOrConnectWithoutApproverInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutApproverInput | ExpenseUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: ExpenseCreateManyApproverInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutApproverInput | ExpenseUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutApproverInput | ExpenseUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type PayrollUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PayrollCreateWithoutUserInput, PayrollUncheckedCreateWithoutUserInput> | PayrollCreateWithoutUserInput[] | PayrollUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutUserInput | PayrollCreateOrConnectWithoutUserInput[]
    upsert?: PayrollUpsertWithWhereUniqueWithoutUserInput | PayrollUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PayrollCreateManyUserInputEnvelope
    set?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    disconnect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    delete?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    update?: PayrollUpdateWithWhereUniqueWithoutUserInput | PayrollUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PayrollUpdateManyWithWhereWithoutUserInput | PayrollUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
  }

  export type PayrollUncheckedUpdateManyWithoutGeneratedByNestedInput = {
    create?: XOR<PayrollCreateWithoutGeneratedByInput, PayrollUncheckedCreateWithoutGeneratedByInput> | PayrollCreateWithoutGeneratedByInput[] | PayrollUncheckedCreateWithoutGeneratedByInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutGeneratedByInput | PayrollCreateOrConnectWithoutGeneratedByInput[]
    upsert?: PayrollUpsertWithWhereUniqueWithoutGeneratedByInput | PayrollUpsertWithWhereUniqueWithoutGeneratedByInput[]
    createMany?: PayrollCreateManyGeneratedByInputEnvelope
    set?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    disconnect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    delete?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    update?: PayrollUpdateWithWhereUniqueWithoutGeneratedByInput | PayrollUpdateWithWhereUniqueWithoutGeneratedByInput[]
    updateMany?: PayrollUpdateManyWithWhereWithoutGeneratedByInput | PayrollUpdateManyWithWhereWithoutGeneratedByInput[]
    deleteMany?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
  }

  export type PerformanceReviewUncheckedUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<PerformanceReviewCreateWithoutReviewerInput, PerformanceReviewUncheckedCreateWithoutReviewerInput> | PerformanceReviewCreateWithoutReviewerInput[] | PerformanceReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: PerformanceReviewCreateOrConnectWithoutReviewerInput | PerformanceReviewCreateOrConnectWithoutReviewerInput[]
    upsert?: PerformanceReviewUpsertWithWhereUniqueWithoutReviewerInput | PerformanceReviewUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: PerformanceReviewCreateManyReviewerInputEnvelope
    set?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    disconnect?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    delete?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    connect?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    update?: PerformanceReviewUpdateWithWhereUniqueWithoutReviewerInput | PerformanceReviewUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: PerformanceReviewUpdateManyWithWhereWithoutReviewerInput | PerformanceReviewUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: PerformanceReviewScalarWhereInput | PerformanceReviewScalarWhereInput[]
  }

  export type PerformanceReviewUncheckedUpdateManyWithoutRevieweeNestedInput = {
    create?: XOR<PerformanceReviewCreateWithoutRevieweeInput, PerformanceReviewUncheckedCreateWithoutRevieweeInput> | PerformanceReviewCreateWithoutRevieweeInput[] | PerformanceReviewUncheckedCreateWithoutRevieweeInput[]
    connectOrCreate?: PerformanceReviewCreateOrConnectWithoutRevieweeInput | PerformanceReviewCreateOrConnectWithoutRevieweeInput[]
    upsert?: PerformanceReviewUpsertWithWhereUniqueWithoutRevieweeInput | PerformanceReviewUpsertWithWhereUniqueWithoutRevieweeInput[]
    createMany?: PerformanceReviewCreateManyRevieweeInputEnvelope
    set?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    disconnect?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    delete?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    connect?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    update?: PerformanceReviewUpdateWithWhereUniqueWithoutRevieweeInput | PerformanceReviewUpdateWithWhereUniqueWithoutRevieweeInput[]
    updateMany?: PerformanceReviewUpdateManyWithWhereWithoutRevieweeInput | PerformanceReviewUpdateManyWithWhereWithoutRevieweeInput[]
    deleteMany?: PerformanceReviewScalarWhereInput | PerformanceReviewScalarWhereInput[]
  }

  export type AssetUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<AssetCreateWithoutAssignedToInput, AssetUncheckedCreateWithoutAssignedToInput> | AssetCreateWithoutAssignedToInput[] | AssetUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutAssignedToInput | AssetCreateOrConnectWithoutAssignedToInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutAssignedToInput | AssetUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: AssetCreateManyAssignedToInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutAssignedToInput | AssetUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutAssignedToInput | AssetUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type JobPostUncheckedUpdateManyWithoutPostedByNestedInput = {
    create?: XOR<JobPostCreateWithoutPostedByInput, JobPostUncheckedCreateWithoutPostedByInput> | JobPostCreateWithoutPostedByInput[] | JobPostUncheckedCreateWithoutPostedByInput[]
    connectOrCreate?: JobPostCreateOrConnectWithoutPostedByInput | JobPostCreateOrConnectWithoutPostedByInput[]
    upsert?: JobPostUpsertWithWhereUniqueWithoutPostedByInput | JobPostUpsertWithWhereUniqueWithoutPostedByInput[]
    createMany?: JobPostCreateManyPostedByInputEnvelope
    set?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
    disconnect?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
    delete?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
    connect?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
    update?: JobPostUpdateWithWhereUniqueWithoutPostedByInput | JobPostUpdateWithWhereUniqueWithoutPostedByInput[]
    updateMany?: JobPostUpdateManyWithWhereWithoutPostedByInput | JobPostUpdateManyWithWhereWithoutPostedByInput[]
    deleteMany?: JobPostScalarWhereInput | JobPostScalarWhereInput[]
  }

  export type ApplicationUncheckedUpdateManyWithoutApplicantNestedInput = {
    create?: XOR<ApplicationCreateWithoutApplicantInput, ApplicationUncheckedCreateWithoutApplicantInput> | ApplicationCreateWithoutApplicantInput[] | ApplicationUncheckedCreateWithoutApplicantInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutApplicantInput | ApplicationCreateOrConnectWithoutApplicantInput[]
    upsert?: ApplicationUpsertWithWhereUniqueWithoutApplicantInput | ApplicationUpsertWithWhereUniqueWithoutApplicantInput[]
    createMany?: ApplicationCreateManyApplicantInputEnvelope
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    update?: ApplicationUpdateWithWhereUniqueWithoutApplicantInput | ApplicationUpdateWithWhereUniqueWithoutApplicantInput[]
    updateMany?: ApplicationUpdateManyWithWhereWithoutApplicantInput | ApplicationUpdateManyWithWhereWithoutApplicantInput[]
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
  }

  export type CalendarEventUncheckedUpdateManyWithoutOrganizerNestedInput = {
    create?: XOR<CalendarEventCreateWithoutOrganizerInput, CalendarEventUncheckedCreateWithoutOrganizerInput> | CalendarEventCreateWithoutOrganizerInput[] | CalendarEventUncheckedCreateWithoutOrganizerInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutOrganizerInput | CalendarEventCreateOrConnectWithoutOrganizerInput[]
    upsert?: CalendarEventUpsertWithWhereUniqueWithoutOrganizerInput | CalendarEventUpsertWithWhereUniqueWithoutOrganizerInput[]
    createMany?: CalendarEventCreateManyOrganizerInputEnvelope
    set?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    disconnect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    delete?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    update?: CalendarEventUpdateWithWhereUniqueWithoutOrganizerInput | CalendarEventUpdateWithWhereUniqueWithoutOrganizerInput[]
    updateMany?: CalendarEventUpdateManyWithWhereWithoutOrganizerInput | CalendarEventUpdateManyWithWhereWithoutOrganizerInput[]
    deleteMany?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
  }

  export type CalendarAttendeeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CalendarAttendeeCreateWithoutUserInput, CalendarAttendeeUncheckedCreateWithoutUserInput> | CalendarAttendeeCreateWithoutUserInput[] | CalendarAttendeeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CalendarAttendeeCreateOrConnectWithoutUserInput | CalendarAttendeeCreateOrConnectWithoutUserInput[]
    upsert?: CalendarAttendeeUpsertWithWhereUniqueWithoutUserInput | CalendarAttendeeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CalendarAttendeeCreateManyUserInputEnvelope
    set?: CalendarAttendeeWhereUniqueInput | CalendarAttendeeWhereUniqueInput[]
    disconnect?: CalendarAttendeeWhereUniqueInput | CalendarAttendeeWhereUniqueInput[]
    delete?: CalendarAttendeeWhereUniqueInput | CalendarAttendeeWhereUniqueInput[]
    connect?: CalendarAttendeeWhereUniqueInput | CalendarAttendeeWhereUniqueInput[]
    update?: CalendarAttendeeUpdateWithWhereUniqueWithoutUserInput | CalendarAttendeeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CalendarAttendeeUpdateManyWithWhereWithoutUserInput | CalendarAttendeeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CalendarAttendeeScalarWhereInput | CalendarAttendeeScalarWhereInput[]
  }

  export type TrainingEnrollmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TrainingEnrollmentCreateWithoutUserInput, TrainingEnrollmentUncheckedCreateWithoutUserInput> | TrainingEnrollmentCreateWithoutUserInput[] | TrainingEnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrainingEnrollmentCreateOrConnectWithoutUserInput | TrainingEnrollmentCreateOrConnectWithoutUserInput[]
    upsert?: TrainingEnrollmentUpsertWithWhereUniqueWithoutUserInput | TrainingEnrollmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TrainingEnrollmentCreateManyUserInputEnvelope
    set?: TrainingEnrollmentWhereUniqueInput | TrainingEnrollmentWhereUniqueInput[]
    disconnect?: TrainingEnrollmentWhereUniqueInput | TrainingEnrollmentWhereUniqueInput[]
    delete?: TrainingEnrollmentWhereUniqueInput | TrainingEnrollmentWhereUniqueInput[]
    connect?: TrainingEnrollmentWhereUniqueInput | TrainingEnrollmentWhereUniqueInput[]
    update?: TrainingEnrollmentUpdateWithWhereUniqueWithoutUserInput | TrainingEnrollmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TrainingEnrollmentUpdateManyWithWhereWithoutUserInput | TrainingEnrollmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TrainingEnrollmentScalarWhereInput | TrainingEnrollmentScalarWhereInput[]
  }

  export type AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<AnnouncementCreateWithoutAuthorInput, AnnouncementUncheckedCreateWithoutAuthorInput> | AnnouncementCreateWithoutAuthorInput[] | AnnouncementUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutAuthorInput | AnnouncementCreateOrConnectWithoutAuthorInput[]
    upsert?: AnnouncementUpsertWithWhereUniqueWithoutAuthorInput | AnnouncementUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: AnnouncementCreateManyAuthorInputEnvelope
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    update?: AnnouncementUpdateWithWhereUniqueWithoutAuthorInput | AnnouncementUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: AnnouncementUpdateManyWithWhereWithoutAuthorInput | AnnouncementUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
  }

  export type UserPreferenceUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPreferenceCreateWithoutUserInput, UserPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferenceCreateOrConnectWithoutUserInput
    upsert?: UserPreferenceUpsertWithoutUserInput
    disconnect?: UserPreferenceWhereInput | boolean
    delete?: UserPreferenceWhereInput | boolean
    connect?: UserPreferenceWhereUniqueInput
    update?: XOR<XOR<UserPreferenceUpdateToOneWithWhereWithoutUserInput, UserPreferenceUpdateWithoutUserInput>, UserPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUncheckedUpdateManyWithoutActorNestedInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutActorInput | AuditLogUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutActorInput | AuditLogUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutActorInput | AuditLogUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type DepartmentUncheckedUpdateManyWithoutHeadNestedInput = {
    create?: XOR<DepartmentCreateWithoutHeadInput, DepartmentUncheckedCreateWithoutHeadInput> | DepartmentCreateWithoutHeadInput[] | DepartmentUncheckedCreateWithoutHeadInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutHeadInput | DepartmentCreateOrConnectWithoutHeadInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutHeadInput | DepartmentUpsertWithWhereUniqueWithoutHeadInput[]
    createMany?: DepartmentCreateManyHeadInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutHeadInput | DepartmentUpdateWithWhereUniqueWithoutHeadInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutHeadInput | DepartmentUpdateManyWithWhereWithoutHeadInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutHeadedDepartmentsInput = {
    create?: XOR<UserCreateWithoutHeadedDepartmentsInput, UserUncheckedCreateWithoutHeadedDepartmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHeadedDepartmentsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput> | UserCreateWithoutDepartmentInput[] | UserUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentInput | UserCreateOrConnectWithoutDepartmentInput[]
    createMany?: UserCreateManyDepartmentInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AnnouncementCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<AnnouncementCreateWithoutDepartmentInput, AnnouncementUncheckedCreateWithoutDepartmentInput> | AnnouncementCreateWithoutDepartmentInput[] | AnnouncementUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutDepartmentInput | AnnouncementCreateOrConnectWithoutDepartmentInput[]
    createMany?: AnnouncementCreateManyDepartmentInputEnvelope
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
  }

  export type JobPostCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<JobPostCreateWithoutDepartmentInput, JobPostUncheckedCreateWithoutDepartmentInput> | JobPostCreateWithoutDepartmentInput[] | JobPostUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: JobPostCreateOrConnectWithoutDepartmentInput | JobPostCreateOrConnectWithoutDepartmentInput[]
    createMany?: JobPostCreateManyDepartmentInputEnvelope
    connect?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput> | UserCreateWithoutDepartmentInput[] | UserUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentInput | UserCreateOrConnectWithoutDepartmentInput[]
    createMany?: UserCreateManyDepartmentInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AnnouncementUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<AnnouncementCreateWithoutDepartmentInput, AnnouncementUncheckedCreateWithoutDepartmentInput> | AnnouncementCreateWithoutDepartmentInput[] | AnnouncementUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutDepartmentInput | AnnouncementCreateOrConnectWithoutDepartmentInput[]
    createMany?: AnnouncementCreateManyDepartmentInputEnvelope
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
  }

  export type JobPostUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<JobPostCreateWithoutDepartmentInput, JobPostUncheckedCreateWithoutDepartmentInput> | JobPostCreateWithoutDepartmentInput[] | JobPostUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: JobPostCreateOrConnectWithoutDepartmentInput | JobPostCreateOrConnectWithoutDepartmentInput[]
    createMany?: JobPostCreateManyDepartmentInputEnvelope
    connect?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutHeadedDepartmentsNestedInput = {
    create?: XOR<UserCreateWithoutHeadedDepartmentsInput, UserUncheckedCreateWithoutHeadedDepartmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHeadedDepartmentsInput
    upsert?: UserUpsertWithoutHeadedDepartmentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHeadedDepartmentsInput, UserUpdateWithoutHeadedDepartmentsInput>, UserUncheckedUpdateWithoutHeadedDepartmentsInput>
  }

  export type UserUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput> | UserCreateWithoutDepartmentInput[] | UserUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentInput | UserCreateOrConnectWithoutDepartmentInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutDepartmentInput | UserUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: UserCreateManyDepartmentInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutDepartmentInput | UserUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: UserUpdateManyWithWhereWithoutDepartmentInput | UserUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AnnouncementUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<AnnouncementCreateWithoutDepartmentInput, AnnouncementUncheckedCreateWithoutDepartmentInput> | AnnouncementCreateWithoutDepartmentInput[] | AnnouncementUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutDepartmentInput | AnnouncementCreateOrConnectWithoutDepartmentInput[]
    upsert?: AnnouncementUpsertWithWhereUniqueWithoutDepartmentInput | AnnouncementUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: AnnouncementCreateManyDepartmentInputEnvelope
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    update?: AnnouncementUpdateWithWhereUniqueWithoutDepartmentInput | AnnouncementUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: AnnouncementUpdateManyWithWhereWithoutDepartmentInput | AnnouncementUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
  }

  export type JobPostUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<JobPostCreateWithoutDepartmentInput, JobPostUncheckedCreateWithoutDepartmentInput> | JobPostCreateWithoutDepartmentInput[] | JobPostUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: JobPostCreateOrConnectWithoutDepartmentInput | JobPostCreateOrConnectWithoutDepartmentInput[]
    upsert?: JobPostUpsertWithWhereUniqueWithoutDepartmentInput | JobPostUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: JobPostCreateManyDepartmentInputEnvelope
    set?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
    disconnect?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
    delete?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
    connect?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
    update?: JobPostUpdateWithWhereUniqueWithoutDepartmentInput | JobPostUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: JobPostUpdateManyWithWhereWithoutDepartmentInput | JobPostUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: JobPostScalarWhereInput | JobPostScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput> | UserCreateWithoutDepartmentInput[] | UserUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentInput | UserCreateOrConnectWithoutDepartmentInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutDepartmentInput | UserUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: UserCreateManyDepartmentInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutDepartmentInput | UserUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: UserUpdateManyWithWhereWithoutDepartmentInput | UserUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AnnouncementUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<AnnouncementCreateWithoutDepartmentInput, AnnouncementUncheckedCreateWithoutDepartmentInput> | AnnouncementCreateWithoutDepartmentInput[] | AnnouncementUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutDepartmentInput | AnnouncementCreateOrConnectWithoutDepartmentInput[]
    upsert?: AnnouncementUpsertWithWhereUniqueWithoutDepartmentInput | AnnouncementUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: AnnouncementCreateManyDepartmentInputEnvelope
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    update?: AnnouncementUpdateWithWhereUniqueWithoutDepartmentInput | AnnouncementUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: AnnouncementUpdateManyWithWhereWithoutDepartmentInput | AnnouncementUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
  }

  export type JobPostUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<JobPostCreateWithoutDepartmentInput, JobPostUncheckedCreateWithoutDepartmentInput> | JobPostCreateWithoutDepartmentInput[] | JobPostUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: JobPostCreateOrConnectWithoutDepartmentInput | JobPostCreateOrConnectWithoutDepartmentInput[]
    upsert?: JobPostUpsertWithWhereUniqueWithoutDepartmentInput | JobPostUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: JobPostCreateManyDepartmentInputEnvelope
    set?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
    disconnect?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
    delete?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
    connect?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
    update?: JobPostUpdateWithWhereUniqueWithoutDepartmentInput | JobPostUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: JobPostUpdateManyWithWhereWithoutDepartmentInput | JobPostUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: JobPostScalarWhereInput | JobPostScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTasksCreatedInput = {
    create?: XOR<UserCreateWithoutTasksCreatedInput, UserUncheckedCreateWithoutTasksCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type TaskAssignmentCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskAssignmentCreateWithoutTaskInput, TaskAssignmentUncheckedCreateWithoutTaskInput> | TaskAssignmentCreateWithoutTaskInput[] | TaskAssignmentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAssignmentCreateOrConnectWithoutTaskInput | TaskAssignmentCreateOrConnectWithoutTaskInput[]
    createMany?: TaskAssignmentCreateManyTaskInputEnvelope
    connect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
  }

  export type TaskCommentCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskCommentCreateWithoutTaskInput, TaskCommentUncheckedCreateWithoutTaskInput> | TaskCommentCreateWithoutTaskInput[] | TaskCommentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskCommentCreateOrConnectWithoutTaskInput | TaskCommentCreateOrConnectWithoutTaskInput[]
    createMany?: TaskCommentCreateManyTaskInputEnvelope
    connect?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
  }

  export type TaskTimeLogCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskTimeLogCreateWithoutTaskInput, TaskTimeLogUncheckedCreateWithoutTaskInput> | TaskTimeLogCreateWithoutTaskInput[] | TaskTimeLogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskTimeLogCreateOrConnectWithoutTaskInput | TaskTimeLogCreateOrConnectWithoutTaskInput[]
    createMany?: TaskTimeLogCreateManyTaskInputEnvelope
    connect?: TaskTimeLogWhereUniqueInput | TaskTimeLogWhereUniqueInput[]
  }

  export type TaskAssignmentUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskAssignmentCreateWithoutTaskInput, TaskAssignmentUncheckedCreateWithoutTaskInput> | TaskAssignmentCreateWithoutTaskInput[] | TaskAssignmentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAssignmentCreateOrConnectWithoutTaskInput | TaskAssignmentCreateOrConnectWithoutTaskInput[]
    createMany?: TaskAssignmentCreateManyTaskInputEnvelope
    connect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
  }

  export type TaskCommentUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskCommentCreateWithoutTaskInput, TaskCommentUncheckedCreateWithoutTaskInput> | TaskCommentCreateWithoutTaskInput[] | TaskCommentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskCommentCreateOrConnectWithoutTaskInput | TaskCommentCreateOrConnectWithoutTaskInput[]
    createMany?: TaskCommentCreateManyTaskInputEnvelope
    connect?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
  }

  export type TaskTimeLogUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskTimeLogCreateWithoutTaskInput, TaskTimeLogUncheckedCreateWithoutTaskInput> | TaskTimeLogCreateWithoutTaskInput[] | TaskTimeLogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskTimeLogCreateOrConnectWithoutTaskInput | TaskTimeLogCreateOrConnectWithoutTaskInput[]
    createMany?: TaskTimeLogCreateManyTaskInputEnvelope
    connect?: TaskTimeLogWhereUniqueInput | TaskTimeLogWhereUniqueInput[]
  }

  export type EnumTaskPriorityFieldUpdateOperationsInput = {
    set?: $Enums.TaskPriority
  }

  export type EnumTaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.TaskStatus
  }

  export type UserUpdateOneRequiredWithoutTasksCreatedNestedInput = {
    create?: XOR<UserCreateWithoutTasksCreatedInput, UserUncheckedCreateWithoutTasksCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksCreatedInput
    upsert?: UserUpsertWithoutTasksCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTasksCreatedInput, UserUpdateWithoutTasksCreatedInput>, UserUncheckedUpdateWithoutTasksCreatedInput>
  }

  export type TaskAssignmentUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskAssignmentCreateWithoutTaskInput, TaskAssignmentUncheckedCreateWithoutTaskInput> | TaskAssignmentCreateWithoutTaskInput[] | TaskAssignmentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAssignmentCreateOrConnectWithoutTaskInput | TaskAssignmentCreateOrConnectWithoutTaskInput[]
    upsert?: TaskAssignmentUpsertWithWhereUniqueWithoutTaskInput | TaskAssignmentUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskAssignmentCreateManyTaskInputEnvelope
    set?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    disconnect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    delete?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    connect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    update?: TaskAssignmentUpdateWithWhereUniqueWithoutTaskInput | TaskAssignmentUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskAssignmentUpdateManyWithWhereWithoutTaskInput | TaskAssignmentUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskAssignmentScalarWhereInput | TaskAssignmentScalarWhereInput[]
  }

  export type TaskCommentUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskCommentCreateWithoutTaskInput, TaskCommentUncheckedCreateWithoutTaskInput> | TaskCommentCreateWithoutTaskInput[] | TaskCommentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskCommentCreateOrConnectWithoutTaskInput | TaskCommentCreateOrConnectWithoutTaskInput[]
    upsert?: TaskCommentUpsertWithWhereUniqueWithoutTaskInput | TaskCommentUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskCommentCreateManyTaskInputEnvelope
    set?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    disconnect?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    delete?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    connect?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    update?: TaskCommentUpdateWithWhereUniqueWithoutTaskInput | TaskCommentUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskCommentUpdateManyWithWhereWithoutTaskInput | TaskCommentUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskCommentScalarWhereInput | TaskCommentScalarWhereInput[]
  }

  export type TaskTimeLogUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskTimeLogCreateWithoutTaskInput, TaskTimeLogUncheckedCreateWithoutTaskInput> | TaskTimeLogCreateWithoutTaskInput[] | TaskTimeLogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskTimeLogCreateOrConnectWithoutTaskInput | TaskTimeLogCreateOrConnectWithoutTaskInput[]
    upsert?: TaskTimeLogUpsertWithWhereUniqueWithoutTaskInput | TaskTimeLogUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskTimeLogCreateManyTaskInputEnvelope
    set?: TaskTimeLogWhereUniqueInput | TaskTimeLogWhereUniqueInput[]
    disconnect?: TaskTimeLogWhereUniqueInput | TaskTimeLogWhereUniqueInput[]
    delete?: TaskTimeLogWhereUniqueInput | TaskTimeLogWhereUniqueInput[]
    connect?: TaskTimeLogWhereUniqueInput | TaskTimeLogWhereUniqueInput[]
    update?: TaskTimeLogUpdateWithWhereUniqueWithoutTaskInput | TaskTimeLogUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskTimeLogUpdateManyWithWhereWithoutTaskInput | TaskTimeLogUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskTimeLogScalarWhereInput | TaskTimeLogScalarWhereInput[]
  }

  export type TaskAssignmentUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskAssignmentCreateWithoutTaskInput, TaskAssignmentUncheckedCreateWithoutTaskInput> | TaskAssignmentCreateWithoutTaskInput[] | TaskAssignmentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAssignmentCreateOrConnectWithoutTaskInput | TaskAssignmentCreateOrConnectWithoutTaskInput[]
    upsert?: TaskAssignmentUpsertWithWhereUniqueWithoutTaskInput | TaskAssignmentUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskAssignmentCreateManyTaskInputEnvelope
    set?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    disconnect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    delete?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    connect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    update?: TaskAssignmentUpdateWithWhereUniqueWithoutTaskInput | TaskAssignmentUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskAssignmentUpdateManyWithWhereWithoutTaskInput | TaskAssignmentUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskAssignmentScalarWhereInput | TaskAssignmentScalarWhereInput[]
  }

  export type TaskCommentUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskCommentCreateWithoutTaskInput, TaskCommentUncheckedCreateWithoutTaskInput> | TaskCommentCreateWithoutTaskInput[] | TaskCommentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskCommentCreateOrConnectWithoutTaskInput | TaskCommentCreateOrConnectWithoutTaskInput[]
    upsert?: TaskCommentUpsertWithWhereUniqueWithoutTaskInput | TaskCommentUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskCommentCreateManyTaskInputEnvelope
    set?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    disconnect?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    delete?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    connect?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    update?: TaskCommentUpdateWithWhereUniqueWithoutTaskInput | TaskCommentUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskCommentUpdateManyWithWhereWithoutTaskInput | TaskCommentUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskCommentScalarWhereInput | TaskCommentScalarWhereInput[]
  }

  export type TaskTimeLogUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskTimeLogCreateWithoutTaskInput, TaskTimeLogUncheckedCreateWithoutTaskInput> | TaskTimeLogCreateWithoutTaskInput[] | TaskTimeLogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskTimeLogCreateOrConnectWithoutTaskInput | TaskTimeLogCreateOrConnectWithoutTaskInput[]
    upsert?: TaskTimeLogUpsertWithWhereUniqueWithoutTaskInput | TaskTimeLogUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskTimeLogCreateManyTaskInputEnvelope
    set?: TaskTimeLogWhereUniqueInput | TaskTimeLogWhereUniqueInput[]
    disconnect?: TaskTimeLogWhereUniqueInput | TaskTimeLogWhereUniqueInput[]
    delete?: TaskTimeLogWhereUniqueInput | TaskTimeLogWhereUniqueInput[]
    connect?: TaskTimeLogWhereUniqueInput | TaskTimeLogWhereUniqueInput[]
    update?: TaskTimeLogUpdateWithWhereUniqueWithoutTaskInput | TaskTimeLogUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskTimeLogUpdateManyWithWhereWithoutTaskInput | TaskTimeLogUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskTimeLogScalarWhereInput | TaskTimeLogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTaskAssignmentsInput = {
    create?: XOR<UserCreateWithoutTaskAssignmentsInput, UserUncheckedCreateWithoutTaskAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaskAssignmentsInput
    connect?: UserWhereUniqueInput
  }

  export type TaskCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<TaskCreateWithoutAssignmentsInput, TaskUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutAssignmentsInput
    connect?: TaskWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTaskAssignmentsNestedInput = {
    create?: XOR<UserCreateWithoutTaskAssignmentsInput, UserUncheckedCreateWithoutTaskAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaskAssignmentsInput
    upsert?: UserUpsertWithoutTaskAssignmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTaskAssignmentsInput, UserUpdateWithoutTaskAssignmentsInput>, UserUncheckedUpdateWithoutTaskAssignmentsInput>
  }

  export type TaskUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<TaskCreateWithoutAssignmentsInput, TaskUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutAssignmentsInput
    upsert?: TaskUpsertWithoutAssignmentsInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutAssignmentsInput, TaskUpdateWithoutAssignmentsInput>, TaskUncheckedUpdateWithoutAssignmentsInput>
  }

  export type TaskCreateNestedOneWithoutCommentsInput = {
    create?: XOR<TaskCreateWithoutCommentsInput, TaskUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutCommentsInput
    connect?: TaskWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTaskCommentsInput = {
    create?: XOR<UserCreateWithoutTaskCommentsInput, UserUncheckedCreateWithoutTaskCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaskCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<TaskCreateWithoutCommentsInput, TaskUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutCommentsInput
    upsert?: TaskUpsertWithoutCommentsInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutCommentsInput, TaskUpdateWithoutCommentsInput>, TaskUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutTaskCommentsNestedInput = {
    create?: XOR<UserCreateWithoutTaskCommentsInput, UserUncheckedCreateWithoutTaskCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaskCommentsInput
    upsert?: UserUpsertWithoutTaskCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTaskCommentsInput, UserUpdateWithoutTaskCommentsInput>, UserUncheckedUpdateWithoutTaskCommentsInput>
  }

  export type TaskCreateNestedOneWithoutTimeLogsInput = {
    create?: XOR<TaskCreateWithoutTimeLogsInput, TaskUncheckedCreateWithoutTimeLogsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTimeLogsInput
    connect?: TaskWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTimeLogsInput = {
    create?: XOR<UserCreateWithoutTimeLogsInput, UserUncheckedCreateWithoutTimeLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTimeLogsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TaskUpdateOneRequiredWithoutTimeLogsNestedInput = {
    create?: XOR<TaskCreateWithoutTimeLogsInput, TaskUncheckedCreateWithoutTimeLogsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTimeLogsInput
    upsert?: TaskUpsertWithoutTimeLogsInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutTimeLogsInput, TaskUpdateWithoutTimeLogsInput>, TaskUncheckedUpdateWithoutTimeLogsInput>
  }

  export type UserUpdateOneRequiredWithoutTimeLogsNestedInput = {
    create?: XOR<UserCreateWithoutTimeLogsInput, UserUncheckedCreateWithoutTimeLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTimeLogsInput
    upsert?: UserUpsertWithoutTimeLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTimeLogsInput, UserUpdateWithoutTimeLogsInput>, UserUncheckedUpdateWithoutTimeLogsInput>
  }

  export type UserCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<UserCreateWithoutAttendanceInput, UserUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAttendanceStatusFieldUpdateOperationsInput = {
    set?: $Enums.AttendanceStatus
  }

  export type UserUpdateOneRequiredWithoutAttendanceNestedInput = {
    create?: XOR<UserCreateWithoutAttendanceInput, UserUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceInput
    upsert?: UserUpsertWithoutAttendanceInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAttendanceInput, UserUpdateWithoutAttendanceInput>, UserUncheckedUpdateWithoutAttendanceInput>
  }

  export type UserCreateNestedOneWithoutLeavesInput = {
    create?: XOR<UserCreateWithoutLeavesInput, UserUncheckedCreateWithoutLeavesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeavesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLeavesToApproveInput = {
    create?: XOR<UserCreateWithoutLeavesToApproveInput, UserUncheckedCreateWithoutLeavesToApproveInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeavesToApproveInput
    connect?: UserWhereUniqueInput
  }

  export type EnumLeaveStatusFieldUpdateOperationsInput = {
    set?: $Enums.LeaveStatus
  }

  export type UserUpdateOneRequiredWithoutLeavesNestedInput = {
    create?: XOR<UserCreateWithoutLeavesInput, UserUncheckedCreateWithoutLeavesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeavesInput
    upsert?: UserUpsertWithoutLeavesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLeavesInput, UserUpdateWithoutLeavesInput>, UserUncheckedUpdateWithoutLeavesInput>
  }

  export type UserUpdateOneWithoutLeavesToApproveNestedInput = {
    create?: XOR<UserCreateWithoutLeavesToApproveInput, UserUncheckedCreateWithoutLeavesToApproveInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeavesToApproveInput
    upsert?: UserUpsertWithoutLeavesToApproveInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLeavesToApproveInput, UserUpdateWithoutLeavesToApproveInput>, UserUncheckedUpdateWithoutLeavesToApproveInput>
  }

  export type UserCreateNestedOneWithoutMessagesSentInput = {
    create?: XOR<UserCreateWithoutMessagesSentInput, UserUncheckedCreateWithoutMessagesSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesSentInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessagesRecvInput = {
    create?: XOR<UserCreateWithoutMessagesRecvInput, UserUncheckedCreateWithoutMessagesRecvInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesRecvInput
    connect?: UserWhereUniqueInput
  }

  export type ChatGroupCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ChatGroupCreateWithoutMessagesInput, ChatGroupUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatGroupCreateOrConnectWithoutMessagesInput
    connect?: ChatGroupWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMessagesSentNestedInput = {
    create?: XOR<UserCreateWithoutMessagesSentInput, UserUncheckedCreateWithoutMessagesSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesSentInput
    upsert?: UserUpsertWithoutMessagesSentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessagesSentInput, UserUpdateWithoutMessagesSentInput>, UserUncheckedUpdateWithoutMessagesSentInput>
  }

  export type UserUpdateOneWithoutMessagesRecvNestedInput = {
    create?: XOR<UserCreateWithoutMessagesRecvInput, UserUncheckedCreateWithoutMessagesRecvInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesRecvInput
    upsert?: UserUpsertWithoutMessagesRecvInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessagesRecvInput, UserUpdateWithoutMessagesRecvInput>, UserUncheckedUpdateWithoutMessagesRecvInput>
  }

  export type ChatGroupUpdateOneWithoutMessagesNestedInput = {
    create?: XOR<ChatGroupCreateWithoutMessagesInput, ChatGroupUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatGroupCreateOrConnectWithoutMessagesInput
    upsert?: ChatGroupUpsertWithoutMessagesInput
    disconnect?: ChatGroupWhereInput | boolean
    delete?: ChatGroupWhereInput | boolean
    connect?: ChatGroupWhereUniqueInput
    update?: XOR<XOR<ChatGroupUpdateToOneWithWhereWithoutMessagesInput, ChatGroupUpdateWithoutMessagesInput>, ChatGroupUncheckedUpdateWithoutMessagesInput>
  }

  export type ChatMessageCreateNestedManyWithoutGroupInput = {
    create?: XOR<ChatMessageCreateWithoutGroupInput, ChatMessageUncheckedCreateWithoutGroupInput> | ChatMessageCreateWithoutGroupInput[] | ChatMessageUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutGroupInput | ChatMessageCreateOrConnectWithoutGroupInput[]
    createMany?: ChatMessageCreateManyGroupInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type ChatGroupMemberCreateNestedManyWithoutGroupInput = {
    create?: XOR<ChatGroupMemberCreateWithoutGroupInput, ChatGroupMemberUncheckedCreateWithoutGroupInput> | ChatGroupMemberCreateWithoutGroupInput[] | ChatGroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ChatGroupMemberCreateOrConnectWithoutGroupInput | ChatGroupMemberCreateOrConnectWithoutGroupInput[]
    createMany?: ChatGroupMemberCreateManyGroupInputEnvelope
    connect?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<ChatMessageCreateWithoutGroupInput, ChatMessageUncheckedCreateWithoutGroupInput> | ChatMessageCreateWithoutGroupInput[] | ChatMessageUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutGroupInput | ChatMessageCreateOrConnectWithoutGroupInput[]
    createMany?: ChatMessageCreateManyGroupInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type ChatGroupMemberUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<ChatGroupMemberCreateWithoutGroupInput, ChatGroupMemberUncheckedCreateWithoutGroupInput> | ChatGroupMemberCreateWithoutGroupInput[] | ChatGroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ChatGroupMemberCreateOrConnectWithoutGroupInput | ChatGroupMemberCreateOrConnectWithoutGroupInput[]
    createMany?: ChatGroupMemberCreateManyGroupInputEnvelope
    connect?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
  }

  export type ChatMessageUpdateManyWithoutGroupNestedInput = {
    create?: XOR<ChatMessageCreateWithoutGroupInput, ChatMessageUncheckedCreateWithoutGroupInput> | ChatMessageCreateWithoutGroupInput[] | ChatMessageUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutGroupInput | ChatMessageCreateOrConnectWithoutGroupInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutGroupInput | ChatMessageUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: ChatMessageCreateManyGroupInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutGroupInput | ChatMessageUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutGroupInput | ChatMessageUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatGroupMemberUpdateManyWithoutGroupNestedInput = {
    create?: XOR<ChatGroupMemberCreateWithoutGroupInput, ChatGroupMemberUncheckedCreateWithoutGroupInput> | ChatGroupMemberCreateWithoutGroupInput[] | ChatGroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ChatGroupMemberCreateOrConnectWithoutGroupInput | ChatGroupMemberCreateOrConnectWithoutGroupInput[]
    upsert?: ChatGroupMemberUpsertWithWhereUniqueWithoutGroupInput | ChatGroupMemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: ChatGroupMemberCreateManyGroupInputEnvelope
    set?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
    disconnect?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
    delete?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
    connect?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
    update?: ChatGroupMemberUpdateWithWhereUniqueWithoutGroupInput | ChatGroupMemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: ChatGroupMemberUpdateManyWithWhereWithoutGroupInput | ChatGroupMemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: ChatGroupMemberScalarWhereInput | ChatGroupMemberScalarWhereInput[]
  }

  export type ChatMessageUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<ChatMessageCreateWithoutGroupInput, ChatMessageUncheckedCreateWithoutGroupInput> | ChatMessageCreateWithoutGroupInput[] | ChatMessageUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutGroupInput | ChatMessageCreateOrConnectWithoutGroupInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutGroupInput | ChatMessageUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: ChatMessageCreateManyGroupInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutGroupInput | ChatMessageUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutGroupInput | ChatMessageUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatGroupMemberUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<ChatGroupMemberCreateWithoutGroupInput, ChatGroupMemberUncheckedCreateWithoutGroupInput> | ChatGroupMemberCreateWithoutGroupInput[] | ChatGroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ChatGroupMemberCreateOrConnectWithoutGroupInput | ChatGroupMemberCreateOrConnectWithoutGroupInput[]
    upsert?: ChatGroupMemberUpsertWithWhereUniqueWithoutGroupInput | ChatGroupMemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: ChatGroupMemberCreateManyGroupInputEnvelope
    set?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
    disconnect?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
    delete?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
    connect?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
    update?: ChatGroupMemberUpdateWithWhereUniqueWithoutGroupInput | ChatGroupMemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: ChatGroupMemberUpdateManyWithWhereWithoutGroupInput | ChatGroupMemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: ChatGroupMemberScalarWhereInput | ChatGroupMemberScalarWhereInput[]
  }

  export type ChatGroupCreateNestedOneWithoutMembersInput = {
    create?: XOR<ChatGroupCreateWithoutMembersInput, ChatGroupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ChatGroupCreateOrConnectWithoutMembersInput
    connect?: ChatGroupWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutChatGroupsInput = {
    create?: XOR<UserCreateWithoutChatGroupsInput, UserUncheckedCreateWithoutChatGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatGroupsInput
    connect?: UserWhereUniqueInput
  }

  export type ChatGroupUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<ChatGroupCreateWithoutMembersInput, ChatGroupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ChatGroupCreateOrConnectWithoutMembersInput
    upsert?: ChatGroupUpsertWithoutMembersInput
    connect?: ChatGroupWhereUniqueInput
    update?: XOR<XOR<ChatGroupUpdateToOneWithWhereWithoutMembersInput, ChatGroupUpdateWithoutMembersInput>, ChatGroupUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutChatGroupsNestedInput = {
    create?: XOR<UserCreateWithoutChatGroupsInput, UserUncheckedCreateWithoutChatGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatGroupsInput
    upsert?: UserUpsertWithoutChatGroupsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChatGroupsInput, UserUpdateWithoutChatGroupsInput>, UserUncheckedUpdateWithoutChatGroupsInput>
  }

  export type UserCreateNestedOneWithoutAnnouncementsMadeInput = {
    create?: XOR<UserCreateWithoutAnnouncementsMadeInput, UserUncheckedCreateWithoutAnnouncementsMadeInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnnouncementsMadeInput
    connect?: UserWhereUniqueInput
  }

  export type DepartmentCreateNestedOneWithoutAnnouncementInput = {
    create?: XOR<DepartmentCreateWithoutAnnouncementInput, DepartmentUncheckedCreateWithoutAnnouncementInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutAnnouncementInput
    connect?: DepartmentWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAnnouncementsMadeNestedInput = {
    create?: XOR<UserCreateWithoutAnnouncementsMadeInput, UserUncheckedCreateWithoutAnnouncementsMadeInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnnouncementsMadeInput
    upsert?: UserUpsertWithoutAnnouncementsMadeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAnnouncementsMadeInput, UserUpdateWithoutAnnouncementsMadeInput>, UserUncheckedUpdateWithoutAnnouncementsMadeInput>
  }

  export type DepartmentUpdateOneWithoutAnnouncementNestedInput = {
    create?: XOR<DepartmentCreateWithoutAnnouncementInput, DepartmentUncheckedCreateWithoutAnnouncementInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutAnnouncementInput
    upsert?: DepartmentUpsertWithoutAnnouncementInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutAnnouncementInput, DepartmentUpdateWithoutAnnouncementInput>, DepartmentUncheckedUpdateWithoutAnnouncementInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentsInput
    upsert?: UserUpsertWithoutDocumentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDocumentsInput, UserUpdateWithoutDocumentsInput>, UserUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserCreateNestedOneWithoutCompanyDocsInput = {
    create?: XOR<UserCreateWithoutCompanyDocsInput, UserUncheckedCreateWithoutCompanyDocsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCompanyDocsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCompanyDocsNestedInput = {
    create?: XOR<UserCreateWithoutCompanyDocsInput, UserUncheckedCreateWithoutCompanyDocsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCompanyDocsInput
    upsert?: UserUpsertWithoutCompanyDocsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCompanyDocsInput, UserUpdateWithoutCompanyDocsInput>, UserUncheckedUpdateWithoutCompanyDocsInput>
  }

  export type UserCreateNestedOneWithoutExpensesInput = {
    create?: XOR<UserCreateWithoutExpensesInput, UserUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: UserCreateOrConnectWithoutExpensesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutExpensesApprovedInput = {
    create?: XOR<UserCreateWithoutExpensesApprovedInput, UserUncheckedCreateWithoutExpensesApprovedInput>
    connectOrCreate?: UserCreateOrConnectWithoutExpensesApprovedInput
    connect?: UserWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumExpenseStatusFieldUpdateOperationsInput = {
    set?: $Enums.ExpenseStatus
  }

  export type UserUpdateOneRequiredWithoutExpensesNestedInput = {
    create?: XOR<UserCreateWithoutExpensesInput, UserUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: UserCreateOrConnectWithoutExpensesInput
    upsert?: UserUpsertWithoutExpensesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExpensesInput, UserUpdateWithoutExpensesInput>, UserUncheckedUpdateWithoutExpensesInput>
  }

  export type UserUpdateOneWithoutExpensesApprovedNestedInput = {
    create?: XOR<UserCreateWithoutExpensesApprovedInput, UserUncheckedCreateWithoutExpensesApprovedInput>
    connectOrCreate?: UserCreateOrConnectWithoutExpensesApprovedInput
    upsert?: UserUpsertWithoutExpensesApprovedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExpensesApprovedInput, UserUpdateWithoutExpensesApprovedInput>, UserUncheckedUpdateWithoutExpensesApprovedInput>
  }

  export type UserCreateNestedOneWithoutAssetsOwnedInput = {
    create?: XOR<UserCreateWithoutAssetsOwnedInput, UserUncheckedCreateWithoutAssetsOwnedInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssetsOwnedInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAssetStatusFieldUpdateOperationsInput = {
    set?: $Enums.AssetStatus
  }

  export type UserUpdateOneWithoutAssetsOwnedNestedInput = {
    create?: XOR<UserCreateWithoutAssetsOwnedInput, UserUncheckedCreateWithoutAssetsOwnedInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssetsOwnedInput
    upsert?: UserUpsertWithoutAssetsOwnedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssetsOwnedInput, UserUpdateWithoutAssetsOwnedInput>, UserUncheckedUpdateWithoutAssetsOwnedInput>
  }

  export type UserCreateNestedOneWithoutPayrollsInput = {
    create?: XOR<UserCreateWithoutPayrollsInput, UserUncheckedCreateWithoutPayrollsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPayrollsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGeneratedPaysInput = {
    create?: XOR<UserCreateWithoutGeneratedPaysInput, UserUncheckedCreateWithoutGeneratedPaysInput>
    connectOrCreate?: UserCreateOrConnectWithoutGeneratedPaysInput
    connect?: UserWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumPayrollStatusFieldUpdateOperationsInput = {
    set?: $Enums.PayrollStatus
  }

  export type UserUpdateOneRequiredWithoutPayrollsNestedInput = {
    create?: XOR<UserCreateWithoutPayrollsInput, UserUncheckedCreateWithoutPayrollsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPayrollsInput
    upsert?: UserUpsertWithoutPayrollsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPayrollsInput, UserUpdateWithoutPayrollsInput>, UserUncheckedUpdateWithoutPayrollsInput>
  }

  export type UserUpdateOneWithoutGeneratedPaysNestedInput = {
    create?: XOR<UserCreateWithoutGeneratedPaysInput, UserUncheckedCreateWithoutGeneratedPaysInput>
    connectOrCreate?: UserCreateOrConnectWithoutGeneratedPaysInput
    upsert?: UserUpsertWithoutGeneratedPaysInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGeneratedPaysInput, UserUpdateWithoutGeneratedPaysInput>, UserUncheckedUpdateWithoutGeneratedPaysInput>
  }

  export type UserCreateNestedOneWithoutPerformanceReviewsGotInput = {
    create?: XOR<UserCreateWithoutPerformanceReviewsGotInput, UserUncheckedCreateWithoutPerformanceReviewsGotInput>
    connectOrCreate?: UserCreateOrConnectWithoutPerformanceReviewsGotInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPerformanceReviewsGivenInput = {
    create?: XOR<UserCreateWithoutPerformanceReviewsGivenInput, UserUncheckedCreateWithoutPerformanceReviewsGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutPerformanceReviewsGivenInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPerformanceReviewsGotNestedInput = {
    create?: XOR<UserCreateWithoutPerformanceReviewsGotInput, UserUncheckedCreateWithoutPerformanceReviewsGotInput>
    connectOrCreate?: UserCreateOrConnectWithoutPerformanceReviewsGotInput
    upsert?: UserUpsertWithoutPerformanceReviewsGotInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPerformanceReviewsGotInput, UserUpdateWithoutPerformanceReviewsGotInput>, UserUncheckedUpdateWithoutPerformanceReviewsGotInput>
  }

  export type UserUpdateOneRequiredWithoutPerformanceReviewsGivenNestedInput = {
    create?: XOR<UserCreateWithoutPerformanceReviewsGivenInput, UserUncheckedCreateWithoutPerformanceReviewsGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutPerformanceReviewsGivenInput
    upsert?: UserUpsertWithoutPerformanceReviewsGivenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPerformanceReviewsGivenInput, UserUpdateWithoutPerformanceReviewsGivenInput>, UserUncheckedUpdateWithoutPerformanceReviewsGivenInput>
  }

  export type DepartmentCreateNestedOneWithoutJobPostInput = {
    create?: XOR<DepartmentCreateWithoutJobPostInput, DepartmentUncheckedCreateWithoutJobPostInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutJobPostInput
    connect?: DepartmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutJobPostsInput = {
    create?: XOR<UserCreateWithoutJobPostsInput, UserUncheckedCreateWithoutJobPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutJobPostsInput
    connect?: UserWhereUniqueInput
  }

  export type ApplicationCreateNestedManyWithoutJobPostInput = {
    create?: XOR<ApplicationCreateWithoutJobPostInput, ApplicationUncheckedCreateWithoutJobPostInput> | ApplicationCreateWithoutJobPostInput[] | ApplicationUncheckedCreateWithoutJobPostInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutJobPostInput | ApplicationCreateOrConnectWithoutJobPostInput[]
    createMany?: ApplicationCreateManyJobPostInputEnvelope
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
  }

  export type ApplicationUncheckedCreateNestedManyWithoutJobPostInput = {
    create?: XOR<ApplicationCreateWithoutJobPostInput, ApplicationUncheckedCreateWithoutJobPostInput> | ApplicationCreateWithoutJobPostInput[] | ApplicationUncheckedCreateWithoutJobPostInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutJobPostInput | ApplicationCreateOrConnectWithoutJobPostInput[]
    createMany?: ApplicationCreateManyJobPostInputEnvelope
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
  }

  export type EnumJobTypeFieldUpdateOperationsInput = {
    set?: $Enums.JobType
  }

  export type DepartmentUpdateOneWithoutJobPostNestedInput = {
    create?: XOR<DepartmentCreateWithoutJobPostInput, DepartmentUncheckedCreateWithoutJobPostInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutJobPostInput
    upsert?: DepartmentUpsertWithoutJobPostInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutJobPostInput, DepartmentUpdateWithoutJobPostInput>, DepartmentUncheckedUpdateWithoutJobPostInput>
  }

  export type UserUpdateOneRequiredWithoutJobPostsNestedInput = {
    create?: XOR<UserCreateWithoutJobPostsInput, UserUncheckedCreateWithoutJobPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutJobPostsInput
    upsert?: UserUpsertWithoutJobPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutJobPostsInput, UserUpdateWithoutJobPostsInput>, UserUncheckedUpdateWithoutJobPostsInput>
  }

  export type ApplicationUpdateManyWithoutJobPostNestedInput = {
    create?: XOR<ApplicationCreateWithoutJobPostInput, ApplicationUncheckedCreateWithoutJobPostInput> | ApplicationCreateWithoutJobPostInput[] | ApplicationUncheckedCreateWithoutJobPostInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutJobPostInput | ApplicationCreateOrConnectWithoutJobPostInput[]
    upsert?: ApplicationUpsertWithWhereUniqueWithoutJobPostInput | ApplicationUpsertWithWhereUniqueWithoutJobPostInput[]
    createMany?: ApplicationCreateManyJobPostInputEnvelope
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    update?: ApplicationUpdateWithWhereUniqueWithoutJobPostInput | ApplicationUpdateWithWhereUniqueWithoutJobPostInput[]
    updateMany?: ApplicationUpdateManyWithWhereWithoutJobPostInput | ApplicationUpdateManyWithWhereWithoutJobPostInput[]
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
  }

  export type ApplicationUncheckedUpdateManyWithoutJobPostNestedInput = {
    create?: XOR<ApplicationCreateWithoutJobPostInput, ApplicationUncheckedCreateWithoutJobPostInput> | ApplicationCreateWithoutJobPostInput[] | ApplicationUncheckedCreateWithoutJobPostInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutJobPostInput | ApplicationCreateOrConnectWithoutJobPostInput[]
    upsert?: ApplicationUpsertWithWhereUniqueWithoutJobPostInput | ApplicationUpsertWithWhereUniqueWithoutJobPostInput[]
    createMany?: ApplicationCreateManyJobPostInputEnvelope
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    update?: ApplicationUpdateWithWhereUniqueWithoutJobPostInput | ApplicationUpdateWithWhereUniqueWithoutJobPostInput[]
    updateMany?: ApplicationUpdateManyWithWhereWithoutJobPostInput | ApplicationUpdateManyWithWhereWithoutJobPostInput[]
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
  }

  export type JobPostCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<JobPostCreateWithoutApplicationsInput, JobPostUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: JobPostCreateOrConnectWithoutApplicationsInput
    connect?: JobPostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<UserCreateWithoutApplicationsInput, UserUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApplicationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumApplicationStatusFieldUpdateOperationsInput = {
    set?: $Enums.ApplicationStatus
  }

  export type JobPostUpdateOneRequiredWithoutApplicationsNestedInput = {
    create?: XOR<JobPostCreateWithoutApplicationsInput, JobPostUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: JobPostCreateOrConnectWithoutApplicationsInput
    upsert?: JobPostUpsertWithoutApplicationsInput
    connect?: JobPostWhereUniqueInput
    update?: XOR<XOR<JobPostUpdateToOneWithWhereWithoutApplicationsInput, JobPostUpdateWithoutApplicationsInput>, JobPostUncheckedUpdateWithoutApplicationsInput>
  }

  export type UserUpdateOneWithoutApplicationsNestedInput = {
    create?: XOR<UserCreateWithoutApplicationsInput, UserUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApplicationsInput
    upsert?: UserUpsertWithoutApplicationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApplicationsInput, UserUpdateWithoutApplicationsInput>, UserUncheckedUpdateWithoutApplicationsInput>
  }

  export type TrainingEnrollmentCreateNestedManyWithoutTrainingInput = {
    create?: XOR<TrainingEnrollmentCreateWithoutTrainingInput, TrainingEnrollmentUncheckedCreateWithoutTrainingInput> | TrainingEnrollmentCreateWithoutTrainingInput[] | TrainingEnrollmentUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingEnrollmentCreateOrConnectWithoutTrainingInput | TrainingEnrollmentCreateOrConnectWithoutTrainingInput[]
    createMany?: TrainingEnrollmentCreateManyTrainingInputEnvelope
    connect?: TrainingEnrollmentWhereUniqueInput | TrainingEnrollmentWhereUniqueInput[]
  }

  export type TrainingEnrollmentUncheckedCreateNestedManyWithoutTrainingInput = {
    create?: XOR<TrainingEnrollmentCreateWithoutTrainingInput, TrainingEnrollmentUncheckedCreateWithoutTrainingInput> | TrainingEnrollmentCreateWithoutTrainingInput[] | TrainingEnrollmentUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingEnrollmentCreateOrConnectWithoutTrainingInput | TrainingEnrollmentCreateOrConnectWithoutTrainingInput[]
    createMany?: TrainingEnrollmentCreateManyTrainingInputEnvelope
    connect?: TrainingEnrollmentWhereUniqueInput | TrainingEnrollmentWhereUniqueInput[]
  }

  export type EnumTrainingStatusFieldUpdateOperationsInput = {
    set?: $Enums.TrainingStatus
  }

  export type TrainingEnrollmentUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<TrainingEnrollmentCreateWithoutTrainingInput, TrainingEnrollmentUncheckedCreateWithoutTrainingInput> | TrainingEnrollmentCreateWithoutTrainingInput[] | TrainingEnrollmentUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingEnrollmentCreateOrConnectWithoutTrainingInput | TrainingEnrollmentCreateOrConnectWithoutTrainingInput[]
    upsert?: TrainingEnrollmentUpsertWithWhereUniqueWithoutTrainingInput | TrainingEnrollmentUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: TrainingEnrollmentCreateManyTrainingInputEnvelope
    set?: TrainingEnrollmentWhereUniqueInput | TrainingEnrollmentWhereUniqueInput[]
    disconnect?: TrainingEnrollmentWhereUniqueInput | TrainingEnrollmentWhereUniqueInput[]
    delete?: TrainingEnrollmentWhereUniqueInput | TrainingEnrollmentWhereUniqueInput[]
    connect?: TrainingEnrollmentWhereUniqueInput | TrainingEnrollmentWhereUniqueInput[]
    update?: TrainingEnrollmentUpdateWithWhereUniqueWithoutTrainingInput | TrainingEnrollmentUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: TrainingEnrollmentUpdateManyWithWhereWithoutTrainingInput | TrainingEnrollmentUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: TrainingEnrollmentScalarWhereInput | TrainingEnrollmentScalarWhereInput[]
  }

  export type TrainingEnrollmentUncheckedUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<TrainingEnrollmentCreateWithoutTrainingInput, TrainingEnrollmentUncheckedCreateWithoutTrainingInput> | TrainingEnrollmentCreateWithoutTrainingInput[] | TrainingEnrollmentUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingEnrollmentCreateOrConnectWithoutTrainingInput | TrainingEnrollmentCreateOrConnectWithoutTrainingInput[]
    upsert?: TrainingEnrollmentUpsertWithWhereUniqueWithoutTrainingInput | TrainingEnrollmentUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: TrainingEnrollmentCreateManyTrainingInputEnvelope
    set?: TrainingEnrollmentWhereUniqueInput | TrainingEnrollmentWhereUniqueInput[]
    disconnect?: TrainingEnrollmentWhereUniqueInput | TrainingEnrollmentWhereUniqueInput[]
    delete?: TrainingEnrollmentWhereUniqueInput | TrainingEnrollmentWhereUniqueInput[]
    connect?: TrainingEnrollmentWhereUniqueInput | TrainingEnrollmentWhereUniqueInput[]
    update?: TrainingEnrollmentUpdateWithWhereUniqueWithoutTrainingInput | TrainingEnrollmentUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: TrainingEnrollmentUpdateManyWithWhereWithoutTrainingInput | TrainingEnrollmentUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: TrainingEnrollmentScalarWhereInput | TrainingEnrollmentScalarWhereInput[]
  }

  export type TrainingProgramCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<TrainingProgramCreateWithoutEnrollmentsInput, TrainingProgramUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: TrainingProgramCreateOrConnectWithoutEnrollmentsInput
    connect?: TrainingProgramWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTrainingEnrollmentsInput = {
    create?: XOR<UserCreateWithoutTrainingEnrollmentsInput, UserUncheckedCreateWithoutTrainingEnrollmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrainingEnrollmentsInput
    connect?: UserWhereUniqueInput
  }

  export type TrainingProgramUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<TrainingProgramCreateWithoutEnrollmentsInput, TrainingProgramUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: TrainingProgramCreateOrConnectWithoutEnrollmentsInput
    upsert?: TrainingProgramUpsertWithoutEnrollmentsInput
    connect?: TrainingProgramWhereUniqueInput
    update?: XOR<XOR<TrainingProgramUpdateToOneWithWhereWithoutEnrollmentsInput, TrainingProgramUpdateWithoutEnrollmentsInput>, TrainingProgramUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type UserUpdateOneRequiredWithoutTrainingEnrollmentsNestedInput = {
    create?: XOR<UserCreateWithoutTrainingEnrollmentsInput, UserUncheckedCreateWithoutTrainingEnrollmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrainingEnrollmentsInput
    upsert?: UserUpsertWithoutTrainingEnrollmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTrainingEnrollmentsInput, UserUpdateWithoutTrainingEnrollmentsInput>, UserUncheckedUpdateWithoutTrainingEnrollmentsInput>
  }

  export type UserCreateNestedOneWithoutEventsOrganizedInput = {
    create?: XOR<UserCreateWithoutEventsOrganizedInput, UserUncheckedCreateWithoutEventsOrganizedInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventsOrganizedInput
    connect?: UserWhereUniqueInput
  }

  export type CalendarAttendeeCreateNestedManyWithoutEventInput = {
    create?: XOR<CalendarAttendeeCreateWithoutEventInput, CalendarAttendeeUncheckedCreateWithoutEventInput> | CalendarAttendeeCreateWithoutEventInput[] | CalendarAttendeeUncheckedCreateWithoutEventInput[]
    connectOrCreate?: CalendarAttendeeCreateOrConnectWithoutEventInput | CalendarAttendeeCreateOrConnectWithoutEventInput[]
    createMany?: CalendarAttendeeCreateManyEventInputEnvelope
    connect?: CalendarAttendeeWhereUniqueInput | CalendarAttendeeWhereUniqueInput[]
  }

  export type CalendarAttendeeUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<CalendarAttendeeCreateWithoutEventInput, CalendarAttendeeUncheckedCreateWithoutEventInput> | CalendarAttendeeCreateWithoutEventInput[] | CalendarAttendeeUncheckedCreateWithoutEventInput[]
    connectOrCreate?: CalendarAttendeeCreateOrConnectWithoutEventInput | CalendarAttendeeCreateOrConnectWithoutEventInput[]
    createMany?: CalendarAttendeeCreateManyEventInputEnvelope
    connect?: CalendarAttendeeWhereUniqueInput | CalendarAttendeeWhereUniqueInput[]
  }

  export type EnumEventSourceFieldUpdateOperationsInput = {
    set?: $Enums.EventSource
  }

  export type UserUpdateOneRequiredWithoutEventsOrganizedNestedInput = {
    create?: XOR<UserCreateWithoutEventsOrganizedInput, UserUncheckedCreateWithoutEventsOrganizedInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventsOrganizedInput
    upsert?: UserUpsertWithoutEventsOrganizedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEventsOrganizedInput, UserUpdateWithoutEventsOrganizedInput>, UserUncheckedUpdateWithoutEventsOrganizedInput>
  }

  export type CalendarAttendeeUpdateManyWithoutEventNestedInput = {
    create?: XOR<CalendarAttendeeCreateWithoutEventInput, CalendarAttendeeUncheckedCreateWithoutEventInput> | CalendarAttendeeCreateWithoutEventInput[] | CalendarAttendeeUncheckedCreateWithoutEventInput[]
    connectOrCreate?: CalendarAttendeeCreateOrConnectWithoutEventInput | CalendarAttendeeCreateOrConnectWithoutEventInput[]
    upsert?: CalendarAttendeeUpsertWithWhereUniqueWithoutEventInput | CalendarAttendeeUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: CalendarAttendeeCreateManyEventInputEnvelope
    set?: CalendarAttendeeWhereUniqueInput | CalendarAttendeeWhereUniqueInput[]
    disconnect?: CalendarAttendeeWhereUniqueInput | CalendarAttendeeWhereUniqueInput[]
    delete?: CalendarAttendeeWhereUniqueInput | CalendarAttendeeWhereUniqueInput[]
    connect?: CalendarAttendeeWhereUniqueInput | CalendarAttendeeWhereUniqueInput[]
    update?: CalendarAttendeeUpdateWithWhereUniqueWithoutEventInput | CalendarAttendeeUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: CalendarAttendeeUpdateManyWithWhereWithoutEventInput | CalendarAttendeeUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: CalendarAttendeeScalarWhereInput | CalendarAttendeeScalarWhereInput[]
  }

  export type CalendarAttendeeUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<CalendarAttendeeCreateWithoutEventInput, CalendarAttendeeUncheckedCreateWithoutEventInput> | CalendarAttendeeCreateWithoutEventInput[] | CalendarAttendeeUncheckedCreateWithoutEventInput[]
    connectOrCreate?: CalendarAttendeeCreateOrConnectWithoutEventInput | CalendarAttendeeCreateOrConnectWithoutEventInput[]
    upsert?: CalendarAttendeeUpsertWithWhereUniqueWithoutEventInput | CalendarAttendeeUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: CalendarAttendeeCreateManyEventInputEnvelope
    set?: CalendarAttendeeWhereUniqueInput | CalendarAttendeeWhereUniqueInput[]
    disconnect?: CalendarAttendeeWhereUniqueInput | CalendarAttendeeWhereUniqueInput[]
    delete?: CalendarAttendeeWhereUniqueInput | CalendarAttendeeWhereUniqueInput[]
    connect?: CalendarAttendeeWhereUniqueInput | CalendarAttendeeWhereUniqueInput[]
    update?: CalendarAttendeeUpdateWithWhereUniqueWithoutEventInput | CalendarAttendeeUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: CalendarAttendeeUpdateManyWithWhereWithoutEventInput | CalendarAttendeeUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: CalendarAttendeeScalarWhereInput | CalendarAttendeeScalarWhereInput[]
  }

  export type CalendarEventCreateNestedOneWithoutAttendeesInput = {
    create?: XOR<CalendarEventCreateWithoutAttendeesInput, CalendarEventUncheckedCreateWithoutAttendeesInput>
    connectOrCreate?: CalendarEventCreateOrConnectWithoutAttendeesInput
    connect?: CalendarEventWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEventAttendeesInput = {
    create?: XOR<UserCreateWithoutEventAttendeesInput, UserUncheckedCreateWithoutEventAttendeesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventAttendeesInput
    connect?: UserWhereUniqueInput
  }

  export type CalendarEventUpdateOneRequiredWithoutAttendeesNestedInput = {
    create?: XOR<CalendarEventCreateWithoutAttendeesInput, CalendarEventUncheckedCreateWithoutAttendeesInput>
    connectOrCreate?: CalendarEventCreateOrConnectWithoutAttendeesInput
    upsert?: CalendarEventUpsertWithoutAttendeesInput
    connect?: CalendarEventWhereUniqueInput
    update?: XOR<XOR<CalendarEventUpdateToOneWithWhereWithoutAttendeesInput, CalendarEventUpdateWithoutAttendeesInput>, CalendarEventUncheckedUpdateWithoutAttendeesInput>
  }

  export type UserUpdateOneRequiredWithoutEventAttendeesNestedInput = {
    create?: XOR<UserCreateWithoutEventAttendeesInput, UserUncheckedCreateWithoutEventAttendeesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventAttendeesInput
    upsert?: UserUpsertWithoutEventAttendeesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEventAttendeesInput, UserUpdateWithoutEventAttendeesInput>, UserUncheckedUpdateWithoutEventAttendeesInput>
  }

  export type UserCreateNestedOneWithoutPreferencesInput = {
    create?: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPreferencesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPreferencesNestedInput = {
    create?: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPreferencesInput
    upsert?: UserUpsertWithoutPreferencesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPreferencesInput, UserUpdateWithoutPreferencesInput>, UserUncheckedUpdateWithoutPreferencesInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumEmploymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EmploymentStatus | EnumEmploymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmploymentStatus[]
    notIn?: $Enums.EmploymentStatus[]
    not?: NestedEnumEmploymentStatusFilter<$PrismaModel> | $Enums.EmploymentStatus
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedEnumEmploymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmploymentStatus | EnumEmploymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmploymentStatus[]
    notIn?: $Enums.EmploymentStatus[]
    not?: NestedEnumEmploymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.EmploymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmploymentStatusFilter<$PrismaModel>
    _max?: NestedEnumEmploymentStatusFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumTaskPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskPriority | EnumTaskPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TaskPriority[]
    notIn?: $Enums.TaskPriority[]
    not?: NestedEnumTaskPriorityFilter<$PrismaModel> | $Enums.TaskPriority
  }

  export type NestedEnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[]
    notIn?: $Enums.TaskStatus[]
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type NestedEnumTaskPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskPriority | EnumTaskPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TaskPriority[]
    notIn?: $Enums.TaskPriority[]
    not?: NestedEnumTaskPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TaskPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskPriorityFilter<$PrismaModel>
    _max?: NestedEnumTaskPriorityFilter<$PrismaModel>
  }

  export type NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[]
    notIn?: $Enums.TaskStatus[]
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[]
    notIn?: $Enums.AttendanceStatus[]
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[]
    notIn?: $Enums.AttendanceStatus[]
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type NestedEnumLeaveStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[]
    notIn?: $Enums.LeaveStatus[]
    not?: NestedEnumLeaveStatusFilter<$PrismaModel> | $Enums.LeaveStatus
  }

  export type NestedEnumLeaveStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[]
    notIn?: $Enums.LeaveStatus[]
    not?: NestedEnumLeaveStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeaveStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveStatusFilter<$PrismaModel>
    _max?: NestedEnumLeaveStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[]
    notIn?: $Enums.NotificationType[]
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[]
    notIn?: $Enums.NotificationType[]
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumExpenseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseStatus | EnumExpenseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseStatus[]
    notIn?: $Enums.ExpenseStatus[]
    not?: NestedEnumExpenseStatusFilter<$PrismaModel> | $Enums.ExpenseStatus
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumExpenseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseStatus | EnumExpenseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseStatus[]
    notIn?: $Enums.ExpenseStatus[]
    not?: NestedEnumExpenseStatusWithAggregatesFilter<$PrismaModel> | $Enums.ExpenseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExpenseStatusFilter<$PrismaModel>
    _max?: NestedEnumExpenseStatusFilter<$PrismaModel>
  }

  export type NestedEnumAssetStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetStatus | EnumAssetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssetStatus[]
    notIn?: $Enums.AssetStatus[]
    not?: NestedEnumAssetStatusFilter<$PrismaModel> | $Enums.AssetStatus
  }

  export type NestedEnumAssetStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetStatus | EnumAssetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssetStatus[]
    notIn?: $Enums.AssetStatus[]
    not?: NestedEnumAssetStatusWithAggregatesFilter<$PrismaModel> | $Enums.AssetStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssetStatusFilter<$PrismaModel>
    _max?: NestedEnumAssetStatusFilter<$PrismaModel>
  }

  export type NestedEnumPayrollStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PayrollStatus | EnumPayrollStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayrollStatus[]
    notIn?: $Enums.PayrollStatus[]
    not?: NestedEnumPayrollStatusFilter<$PrismaModel> | $Enums.PayrollStatus
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumPayrollStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayrollStatus | EnumPayrollStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayrollStatus[]
    notIn?: $Enums.PayrollStatus[]
    not?: NestedEnumPayrollStatusWithAggregatesFilter<$PrismaModel> | $Enums.PayrollStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayrollStatusFilter<$PrismaModel>
    _max?: NestedEnumPayrollStatusFilter<$PrismaModel>
  }

  export type NestedEnumJobTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.JobType | EnumJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JobType[]
    notIn?: $Enums.JobType[]
    not?: NestedEnumJobTypeFilter<$PrismaModel> | $Enums.JobType
  }

  export type NestedEnumJobTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobType | EnumJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JobType[]
    notIn?: $Enums.JobType[]
    not?: NestedEnumJobTypeWithAggregatesFilter<$PrismaModel> | $Enums.JobType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobTypeFilter<$PrismaModel>
    _max?: NestedEnumJobTypeFilter<$PrismaModel>
  }

  export type NestedEnumApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[]
    notIn?: $Enums.ApplicationStatus[]
    not?: NestedEnumApplicationStatusFilter<$PrismaModel> | $Enums.ApplicationStatus
  }

  export type NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[]
    notIn?: $Enums.ApplicationStatus[]
    not?: NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumApplicationStatusFilter<$PrismaModel>
  }

  export type NestedEnumTrainingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingStatus | EnumTrainingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingStatus[]
    notIn?: $Enums.TrainingStatus[]
    not?: NestedEnumTrainingStatusFilter<$PrismaModel> | $Enums.TrainingStatus
  }

  export type NestedEnumTrainingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingStatus | EnumTrainingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingStatus[]
    notIn?: $Enums.TrainingStatus[]
    not?: NestedEnumTrainingStatusWithAggregatesFilter<$PrismaModel> | $Enums.TrainingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrainingStatusFilter<$PrismaModel>
    _max?: NestedEnumTrainingStatusFilter<$PrismaModel>
  }

  export type NestedEnumEventSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.EventSource | EnumEventSourceFieldRefInput<$PrismaModel>
    in?: $Enums.EventSource[]
    notIn?: $Enums.EventSource[]
    not?: NestedEnumEventSourceFilter<$PrismaModel> | $Enums.EventSource
  }

  export type NestedEnumEventSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventSource | EnumEventSourceFieldRefInput<$PrismaModel>
    in?: $Enums.EventSource[]
    notIn?: $Enums.EventSource[]
    not?: NestedEnumEventSourceWithAggregatesFilter<$PrismaModel> | $Enums.EventSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventSourceFilter<$PrismaModel>
    _max?: NestedEnumEventSourceFilter<$PrismaModel>
  }

  export type DepartmentCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    head?: UserCreateNestedOneWithoutHeadedDepartmentsInput
    Announcement?: AnnouncementCreateNestedManyWithoutDepartmentInput
    JobPost?: JobPostCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    headId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Announcement?: AnnouncementUncheckedCreateNestedManyWithoutDepartmentInput
    JobPost?: JobPostUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutUsersInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutUsersInput, DepartmentUncheckedCreateWithoutUsersInput>
  }

  export type UserCreateWithoutReportsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutReportsInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseCreateNestedManyWithoutApproverInput
    payrolls?: PayrollCreateNestedManyWithoutUserInput
    generatedPays?: PayrollCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostCreateNestedManyWithoutPostedByInput
    applications?: ApplicationCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
  }

  export type UserUncheckedCreateWithoutReportsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    departmentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveUncheckedCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseUncheckedCreateNestedManyWithoutApproverInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutUserInput
    generatedPays?: PayrollUncheckedCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewUncheckedCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetUncheckedCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostUncheckedCreateNestedManyWithoutPostedByInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventUncheckedCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeUncheckedCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentUncheckedCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
  }

  export type UserCreateOrConnectWithoutReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
  }

  export type UserCreateWithoutManagerInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    reports?: UserCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseCreateNestedManyWithoutApproverInput
    payrolls?: PayrollCreateNestedManyWithoutUserInput
    generatedPays?: PayrollCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostCreateNestedManyWithoutPostedByInput
    applications?: ApplicationCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
  }

  export type UserUncheckedCreateWithoutManagerInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: UserUncheckedCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveUncheckedCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseUncheckedCreateNestedManyWithoutApproverInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutUserInput
    generatedPays?: PayrollUncheckedCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewUncheckedCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetUncheckedCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostUncheckedCreateNestedManyWithoutPostedByInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventUncheckedCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeUncheckedCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentUncheckedCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
  }

  export type UserCreateOrConnectWithoutManagerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput>
  }

  export type UserCreateManyManagerInputEnvelope = {
    data: UserCreateManyManagerInput | UserCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.TaskPriority
    status?: $Enums.TaskStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: TaskAssignmentCreateNestedManyWithoutTaskInput
    comments?: TaskCommentCreateNestedManyWithoutTaskInput
    timeLogs?: TaskTimeLogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.TaskPriority
    status?: $Enums.TaskStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: TaskAssignmentUncheckedCreateNestedManyWithoutTaskInput
    comments?: TaskCommentUncheckedCreateNestedManyWithoutTaskInput
    timeLogs?: TaskTimeLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutCreatedByInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutCreatedByInput, TaskUncheckedCreateWithoutCreatedByInput>
  }

  export type TaskCreateManyCreatedByInputEnvelope = {
    data: TaskCreateManyCreatedByInput | TaskCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type TaskAssignmentCreateWithoutUserInput = {
    id?: string
    assignedAt?: Date | string
    task: TaskCreateNestedOneWithoutAssignmentsInput
  }

  export type TaskAssignmentUncheckedCreateWithoutUserInput = {
    id?: string
    taskId: string
    assignedAt?: Date | string
  }

  export type TaskAssignmentCreateOrConnectWithoutUserInput = {
    where: TaskAssignmentWhereUniqueInput
    create: XOR<TaskAssignmentCreateWithoutUserInput, TaskAssignmentUncheckedCreateWithoutUserInput>
  }

  export type TaskAssignmentCreateManyUserInputEnvelope = {
    data: TaskAssignmentCreateManyUserInput | TaskAssignmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TaskCommentCreateWithoutUserInput = {
    id?: string
    content: string
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutCommentsInput
  }

  export type TaskCommentUncheckedCreateWithoutUserInput = {
    id?: string
    taskId: string
    content: string
    createdAt?: Date | string
  }

  export type TaskCommentCreateOrConnectWithoutUserInput = {
    where: TaskCommentWhereUniqueInput
    create: XOR<TaskCommentCreateWithoutUserInput, TaskCommentUncheckedCreateWithoutUserInput>
  }

  export type TaskCommentCreateManyUserInputEnvelope = {
    data: TaskCommentCreateManyUserInput | TaskCommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TaskTimeLogCreateWithoutUserInput = {
    id?: string
    startedAt: Date | string
    endedAt?: Date | string | null
    durationSeconds?: number | null
    task: TaskCreateNestedOneWithoutTimeLogsInput
  }

  export type TaskTimeLogUncheckedCreateWithoutUserInput = {
    id?: string
    taskId: string
    startedAt: Date | string
    endedAt?: Date | string | null
    durationSeconds?: number | null
  }

  export type TaskTimeLogCreateOrConnectWithoutUserInput = {
    where: TaskTimeLogWhereUniqueInput
    create: XOR<TaskTimeLogCreateWithoutUserInput, TaskTimeLogUncheckedCreateWithoutUserInput>
  }

  export type TaskTimeLogCreateManyUserInputEnvelope = {
    data: TaskTimeLogCreateManyUserInput | TaskTimeLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceRecordCreateWithoutUserInput = {
    id?: string
    date: Date | string
    clockIn?: Date | string | null
    clockOut?: Date | string | null
    status?: $Enums.AttendanceStatus
    ipAddress?: string | null
    location?: string | null
  }

  export type AttendanceRecordUncheckedCreateWithoutUserInput = {
    id?: string
    date: Date | string
    clockIn?: Date | string | null
    clockOut?: Date | string | null
    status?: $Enums.AttendanceStatus
    ipAddress?: string | null
    location?: string | null
  }

  export type AttendanceRecordCreateOrConnectWithoutUserInput = {
    where: AttendanceRecordWhereUniqueInput
    create: XOR<AttendanceRecordCreateWithoutUserInput, AttendanceRecordUncheckedCreateWithoutUserInput>
  }

  export type AttendanceRecordCreateManyUserInputEnvelope = {
    data: AttendanceRecordCreateManyUserInput | AttendanceRecordCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LeaveCreateWithoutUserInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    reason?: string | null
    status?: $Enums.LeaveStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    approver?: UserCreateNestedOneWithoutLeavesToApproveInput
  }

  export type LeaveUncheckedCreateWithoutUserInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    reason?: string | null
    status?: $Enums.LeaveStatus
    approverId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveCreateOrConnectWithoutUserInput = {
    where: LeaveWhereUniqueInput
    create: XOR<LeaveCreateWithoutUserInput, LeaveUncheckedCreateWithoutUserInput>
  }

  export type LeaveCreateManyUserInputEnvelope = {
    data: LeaveCreateManyUserInput | LeaveCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LeaveCreateWithoutApproverInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    reason?: string | null
    status?: $Enums.LeaveStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLeavesInput
  }

  export type LeaveUncheckedCreateWithoutApproverInput = {
    id?: string
    userId: string
    startDate: Date | string
    endDate: Date | string
    reason?: string | null
    status?: $Enums.LeaveStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveCreateOrConnectWithoutApproverInput = {
    where: LeaveWhereUniqueInput
    create: XOR<LeaveCreateWithoutApproverInput, LeaveUncheckedCreateWithoutApproverInput>
  }

  export type LeaveCreateManyApproverInputEnvelope = {
    data: LeaveCreateManyApproverInput | LeaveCreateManyApproverInput[]
    skipDuplicates?: boolean
  }

  export type ChatMessageCreateWithoutSenderInput = {
    id?: string
    content: string
    timestamp?: Date | string
    receiver?: UserCreateNestedOneWithoutMessagesRecvInput
    group?: ChatGroupCreateNestedOneWithoutMessagesInput
  }

  export type ChatMessageUncheckedCreateWithoutSenderInput = {
    id?: string
    receiverId?: string | null
    groupId?: string | null
    content: string
    timestamp?: Date | string
  }

  export type ChatMessageCreateOrConnectWithoutSenderInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput>
  }

  export type ChatMessageCreateManySenderInputEnvelope = {
    data: ChatMessageCreateManySenderInput | ChatMessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type ChatMessageCreateWithoutReceiverInput = {
    id?: string
    content: string
    timestamp?: Date | string
    sender: UserCreateNestedOneWithoutMessagesSentInput
    group?: ChatGroupCreateNestedOneWithoutMessagesInput
  }

  export type ChatMessageUncheckedCreateWithoutReceiverInput = {
    id?: string
    senderId: string
    groupId?: string | null
    content: string
    timestamp?: Date | string
  }

  export type ChatMessageCreateOrConnectWithoutReceiverInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutReceiverInput, ChatMessageUncheckedCreateWithoutReceiverInput>
  }

  export type ChatMessageCreateManyReceiverInputEnvelope = {
    data: ChatMessageCreateManyReceiverInput | ChatMessageCreateManyReceiverInput[]
    skipDuplicates?: boolean
  }

  export type ChatGroupMemberCreateWithoutUserInput = {
    id?: string
    joinedAt?: Date | string
    group: ChatGroupCreateNestedOneWithoutMembersInput
  }

  export type ChatGroupMemberUncheckedCreateWithoutUserInput = {
    id?: string
    groupId: string
    joinedAt?: Date | string
  }

  export type ChatGroupMemberCreateOrConnectWithoutUserInput = {
    where: ChatGroupMemberWhereUniqueInput
    create: XOR<ChatGroupMemberCreateWithoutUserInput, ChatGroupMemberUncheckedCreateWithoutUserInput>
  }

  export type ChatGroupMemberCreateManyUserInputEnvelope = {
    data: ChatGroupMemberCreateManyUserInput | ChatGroupMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type?: $Enums.NotificationType
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type?: $Enums.NotificationType
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutUserInput = {
    id?: string
    title: string
    fileUrl: string
    createdAt?: Date | string
  }

  export type DocumentUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    fileUrl: string
    createdAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutUserInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput>
  }

  export type DocumentCreateManyUserInputEnvelope = {
    data: DocumentCreateManyUserInput | DocumentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CompanyDocumentCreateWithoutUploaderInput = {
    id?: string
    title: string
    description?: string | null
    fileUrl: string
    createdAt?: Date | string
  }

  export type CompanyDocumentUncheckedCreateWithoutUploaderInput = {
    id?: string
    title: string
    description?: string | null
    fileUrl: string
    createdAt?: Date | string
  }

  export type CompanyDocumentCreateOrConnectWithoutUploaderInput = {
    where: CompanyDocumentWhereUniqueInput
    create: XOR<CompanyDocumentCreateWithoutUploaderInput, CompanyDocumentUncheckedCreateWithoutUploaderInput>
  }

  export type CompanyDocumentCreateManyUploaderInputEnvelope = {
    data: CompanyDocumentCreateManyUploaderInput | CompanyDocumentCreateManyUploaderInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseCreateWithoutOwnerInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    date: Date | string
    status?: $Enums.ExpenseStatus
    receiptUrl?: string | null
    submittedAt?: Date | string
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approver?: UserCreateNestedOneWithoutExpensesApprovedInput
  }

  export type ExpenseUncheckedCreateWithoutOwnerInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    date: Date | string
    status?: $Enums.ExpenseStatus
    receiptUrl?: string | null
    submittedAt?: Date | string
    approvedAt?: Date | string | null
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateOrConnectWithoutOwnerInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutOwnerInput, ExpenseUncheckedCreateWithoutOwnerInput>
  }

  export type ExpenseCreateManyOwnerInputEnvelope = {
    data: ExpenseCreateManyOwnerInput | ExpenseCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseCreateWithoutApproverInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    date: Date | string
    status?: $Enums.ExpenseStatus
    receiptUrl?: string | null
    submittedAt?: Date | string
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateWithoutApproverInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    category?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    date: Date | string
    status?: $Enums.ExpenseStatus
    receiptUrl?: string | null
    submittedAt?: Date | string
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateOrConnectWithoutApproverInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutApproverInput, ExpenseUncheckedCreateWithoutApproverInput>
  }

  export type ExpenseCreateManyApproverInputEnvelope = {
    data: ExpenseCreateManyApproverInput | ExpenseCreateManyApproverInput[]
    skipDuplicates?: boolean
  }

  export type PayrollCreateWithoutUserInput = {
    id?: string
    month: number
    year: number
    baseSalary: Decimal | DecimalJsLike | number | string
    allowances?: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
    netPay: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PayrollStatus
    generatedAt?: Date | string | null
    paidAt?: Date | string | null
    slipUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    generatedBy?: UserCreateNestedOneWithoutGeneratedPaysInput
  }

  export type PayrollUncheckedCreateWithoutUserInput = {
    id?: string
    month: number
    year: number
    baseSalary: Decimal | DecimalJsLike | number | string
    allowances?: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
    netPay: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PayrollStatus
    generatedById?: string | null
    generatedAt?: Date | string | null
    paidAt?: Date | string | null
    slipUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollCreateOrConnectWithoutUserInput = {
    where: PayrollWhereUniqueInput
    create: XOR<PayrollCreateWithoutUserInput, PayrollUncheckedCreateWithoutUserInput>
  }

  export type PayrollCreateManyUserInputEnvelope = {
    data: PayrollCreateManyUserInput | PayrollCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PayrollCreateWithoutGeneratedByInput = {
    id?: string
    month: number
    year: number
    baseSalary: Decimal | DecimalJsLike | number | string
    allowances?: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
    netPay: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PayrollStatus
    generatedAt?: Date | string | null
    paidAt?: Date | string | null
    slipUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPayrollsInput
  }

  export type PayrollUncheckedCreateWithoutGeneratedByInput = {
    id?: string
    userId: string
    month: number
    year: number
    baseSalary: Decimal | DecimalJsLike | number | string
    allowances?: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
    netPay: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PayrollStatus
    generatedAt?: Date | string | null
    paidAt?: Date | string | null
    slipUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollCreateOrConnectWithoutGeneratedByInput = {
    where: PayrollWhereUniqueInput
    create: XOR<PayrollCreateWithoutGeneratedByInput, PayrollUncheckedCreateWithoutGeneratedByInput>
  }

  export type PayrollCreateManyGeneratedByInputEnvelope = {
    data: PayrollCreateManyGeneratedByInput | PayrollCreateManyGeneratedByInput[]
    skipDuplicates?: boolean
  }

  export type PerformanceReviewCreateWithoutReviewerInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    overallScore: number
    kpiScores?: NullableJsonNullValueInput | InputJsonValue
    feedback?: string | null
    createdAt?: Date | string
    reviewee: UserCreateNestedOneWithoutPerformanceReviewsGotInput
  }

  export type PerformanceReviewUncheckedCreateWithoutReviewerInput = {
    id?: string
    revieweeId: string
    periodStart: Date | string
    periodEnd: Date | string
    overallScore: number
    kpiScores?: NullableJsonNullValueInput | InputJsonValue
    feedback?: string | null
    createdAt?: Date | string
  }

  export type PerformanceReviewCreateOrConnectWithoutReviewerInput = {
    where: PerformanceReviewWhereUniqueInput
    create: XOR<PerformanceReviewCreateWithoutReviewerInput, PerformanceReviewUncheckedCreateWithoutReviewerInput>
  }

  export type PerformanceReviewCreateManyReviewerInputEnvelope = {
    data: PerformanceReviewCreateManyReviewerInput | PerformanceReviewCreateManyReviewerInput[]
    skipDuplicates?: boolean
  }

  export type PerformanceReviewCreateWithoutRevieweeInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    overallScore: number
    kpiScores?: NullableJsonNullValueInput | InputJsonValue
    feedback?: string | null
    createdAt?: Date | string
    reviewer: UserCreateNestedOneWithoutPerformanceReviewsGivenInput
  }

  export type PerformanceReviewUncheckedCreateWithoutRevieweeInput = {
    id?: string
    reviewerId: string
    periodStart: Date | string
    periodEnd: Date | string
    overallScore: number
    kpiScores?: NullableJsonNullValueInput | InputJsonValue
    feedback?: string | null
    createdAt?: Date | string
  }

  export type PerformanceReviewCreateOrConnectWithoutRevieweeInput = {
    where: PerformanceReviewWhereUniqueInput
    create: XOR<PerformanceReviewCreateWithoutRevieweeInput, PerformanceReviewUncheckedCreateWithoutRevieweeInput>
  }

  export type PerformanceReviewCreateManyRevieweeInputEnvelope = {
    data: PerformanceReviewCreateManyRevieweeInput | PerformanceReviewCreateManyRevieweeInput[]
    skipDuplicates?: boolean
  }

  export type AssetCreateWithoutAssignedToInput = {
    id?: string
    tag: string
    name: string
    type?: string | null
    serialNumber?: string | null
    purchaseDate?: Date | string | null
    status?: $Enums.AssetStatus
    assignedAt?: Date | string | null
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetUncheckedCreateWithoutAssignedToInput = {
    id?: string
    tag: string
    name: string
    type?: string | null
    serialNumber?: string | null
    purchaseDate?: Date | string | null
    status?: $Enums.AssetStatus
    assignedAt?: Date | string | null
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetCreateOrConnectWithoutAssignedToInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutAssignedToInput, AssetUncheckedCreateWithoutAssignedToInput>
  }

  export type AssetCreateManyAssignedToInputEnvelope = {
    data: AssetCreateManyAssignedToInput | AssetCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type JobPostCreateWithoutPostedByInput = {
    id?: string
    title: string
    type?: $Enums.JobType
    location?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutJobPostInput
    applications?: ApplicationCreateNestedManyWithoutJobPostInput
  }

  export type JobPostUncheckedCreateWithoutPostedByInput = {
    id?: string
    title: string
    departmentId?: string | null
    type?: $Enums.JobType
    location?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: ApplicationUncheckedCreateNestedManyWithoutJobPostInput
  }

  export type JobPostCreateOrConnectWithoutPostedByInput = {
    where: JobPostWhereUniqueInput
    create: XOR<JobPostCreateWithoutPostedByInput, JobPostUncheckedCreateWithoutPostedByInput>
  }

  export type JobPostCreateManyPostedByInputEnvelope = {
    data: JobPostCreateManyPostedByInput | JobPostCreateManyPostedByInput[]
    skipDuplicates?: boolean
  }

  export type ApplicationCreateWithoutApplicantInput = {
    id?: string
    applicantName: string
    applicantEmail: string
    resumeUrl?: string | null
    coverLetter?: string | null
    status?: $Enums.ApplicationStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobPost: JobPostCreateNestedOneWithoutApplicationsInput
  }

  export type ApplicationUncheckedCreateWithoutApplicantInput = {
    id?: string
    jobPostId: string
    applicantName: string
    applicantEmail: string
    resumeUrl?: string | null
    coverLetter?: string | null
    status?: $Enums.ApplicationStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApplicationCreateOrConnectWithoutApplicantInput = {
    where: ApplicationWhereUniqueInput
    create: XOR<ApplicationCreateWithoutApplicantInput, ApplicationUncheckedCreateWithoutApplicantInput>
  }

  export type ApplicationCreateManyApplicantInputEnvelope = {
    data: ApplicationCreateManyApplicantInput | ApplicationCreateManyApplicantInput[]
    skipDuplicates?: boolean
  }

  export type CalendarEventCreateWithoutOrganizerInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    source?: $Enums.EventSource
    googleMeetLink?: string | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendees?: CalendarAttendeeCreateNestedManyWithoutEventInput
  }

  export type CalendarEventUncheckedCreateWithoutOrganizerInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    source?: $Enums.EventSource
    googleMeetLink?: string | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendees?: CalendarAttendeeUncheckedCreateNestedManyWithoutEventInput
  }

  export type CalendarEventCreateOrConnectWithoutOrganizerInput = {
    where: CalendarEventWhereUniqueInput
    create: XOR<CalendarEventCreateWithoutOrganizerInput, CalendarEventUncheckedCreateWithoutOrganizerInput>
  }

  export type CalendarEventCreateManyOrganizerInputEnvelope = {
    data: CalendarEventCreateManyOrganizerInput | CalendarEventCreateManyOrganizerInput[]
    skipDuplicates?: boolean
  }

  export type CalendarAttendeeCreateWithoutUserInput = {
    id?: string
    response?: string | null
    event: CalendarEventCreateNestedOneWithoutAttendeesInput
  }

  export type CalendarAttendeeUncheckedCreateWithoutUserInput = {
    id?: string
    eventId: string
    response?: string | null
  }

  export type CalendarAttendeeCreateOrConnectWithoutUserInput = {
    where: CalendarAttendeeWhereUniqueInput
    create: XOR<CalendarAttendeeCreateWithoutUserInput, CalendarAttendeeUncheckedCreateWithoutUserInput>
  }

  export type CalendarAttendeeCreateManyUserInputEnvelope = {
    data: CalendarAttendeeCreateManyUserInput | CalendarAttendeeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TrainingEnrollmentCreateWithoutUserInput = {
    id?: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    certificateUrl?: string | null
    training: TrainingProgramCreateNestedOneWithoutEnrollmentsInput
  }

  export type TrainingEnrollmentUncheckedCreateWithoutUserInput = {
    id?: string
    trainingId: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    certificateUrl?: string | null
  }

  export type TrainingEnrollmentCreateOrConnectWithoutUserInput = {
    where: TrainingEnrollmentWhereUniqueInput
    create: XOR<TrainingEnrollmentCreateWithoutUserInput, TrainingEnrollmentUncheckedCreateWithoutUserInput>
  }

  export type TrainingEnrollmentCreateManyUserInputEnvelope = {
    data: TrainingEnrollmentCreateManyUserInput | TrainingEnrollmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AnnouncementCreateWithoutAuthorInput = {
    id?: string
    title: string
    content: string
    createdAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutAnnouncementInput
  }

  export type AnnouncementUncheckedCreateWithoutAuthorInput = {
    id?: string
    title: string
    content: string
    departmentId?: string | null
    createdAt?: Date | string
  }

  export type AnnouncementCreateOrConnectWithoutAuthorInput = {
    where: AnnouncementWhereUniqueInput
    create: XOR<AnnouncementCreateWithoutAuthorInput, AnnouncementUncheckedCreateWithoutAuthorInput>
  }

  export type AnnouncementCreateManyAuthorInputEnvelope = {
    data: AnnouncementCreateManyAuthorInput | AnnouncementCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type UserPreferenceCreateWithoutUserInput = {
    id?: string
    theme?: string | null
    locale?: string | null
    notificationsEnabled?: boolean
  }

  export type UserPreferenceUncheckedCreateWithoutUserInput = {
    id?: string
    theme?: string | null
    locale?: string | null
    notificationsEnabled?: boolean
  }

  export type UserPreferenceCreateOrConnectWithoutUserInput = {
    where: UserPreferenceWhereUniqueInput
    create: XOR<UserPreferenceCreateWithoutUserInput, UserPreferenceUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateWithoutActorInput = {
    id?: string
    entity: string
    entityId: string
    action: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutActorInput = {
    id?: string
    entity: string
    entityId: string
    action: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>
  }

  export type AuditLogCreateManyActorInputEnvelope = {
    data: AuditLogCreateManyActorInput | AuditLogCreateManyActorInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentCreateWithoutHeadInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutDepartmentInput
    Announcement?: AnnouncementCreateNestedManyWithoutDepartmentInput
    JobPost?: JobPostCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutHeadInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutDepartmentInput
    Announcement?: AnnouncementUncheckedCreateNestedManyWithoutDepartmentInput
    JobPost?: JobPostUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutHeadInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutHeadInput, DepartmentUncheckedCreateWithoutHeadInput>
  }

  export type DepartmentCreateManyHeadInputEnvelope = {
    data: DepartmentCreateManyHeadInput | DepartmentCreateManyHeadInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentUpsertWithoutUsersInput = {
    update: XOR<DepartmentUpdateWithoutUsersInput, DepartmentUncheckedUpdateWithoutUsersInput>
    create: XOR<DepartmentCreateWithoutUsersInput, DepartmentUncheckedCreateWithoutUsersInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutUsersInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutUsersInput, DepartmentUncheckedUpdateWithoutUsersInput>
  }

  export type DepartmentUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    head?: UserUpdateOneWithoutHeadedDepartmentsNestedInput
    Announcement?: AnnouncementUpdateManyWithoutDepartmentNestedInput
    JobPost?: JobPostUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    headId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Announcement?: AnnouncementUncheckedUpdateManyWithoutDepartmentNestedInput
    JobPost?: JobPostUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type UserUpsertWithoutReportsInput = {
    update: XOR<UserUpdateWithoutReportsInput, UserUncheckedUpdateWithoutReportsInput>
    create: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportsInput, UserUncheckedUpdateWithoutReportsInput>
  }

  export type UserUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutReportsNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
  }

  export type UserUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUncheckedUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUncheckedUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUncheckedUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUncheckedUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUncheckedUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUncheckedUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUncheckedUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutManagerInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutManagerInput, UserUncheckedUpdateWithoutManagerInput>
    create: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput>
  }

  export type UserUpdateWithWhereUniqueWithoutManagerInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutManagerInput, UserUncheckedUpdateWithoutManagerInput>
  }

  export type UserUpdateManyWithWhereWithoutManagerInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutManagerInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    employment?: EnumEmploymentStatusFilter<"User"> | $Enums.EmploymentStatus
    phone?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    joinDate?: DateTimeNullableFilter<"User"> | Date | string | null
    salary?: DecimalNullableFilter<"User"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"User"> | string | null
    departmentId?: StringNullableFilter<"User"> | string | null
    managerId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type TaskUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutCreatedByInput, TaskUncheckedUpdateWithoutCreatedByInput>
    create: XOR<TaskCreateWithoutCreatedByInput, TaskUncheckedCreateWithoutCreatedByInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutCreatedByInput, TaskUncheckedUpdateWithoutCreatedByInput>
  }

  export type TaskUpdateManyWithWhereWithoutCreatedByInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    priority?: EnumTaskPriorityFilter<"Task"> | $Enums.TaskPriority
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    createdById?: StringFilter<"Task"> | string
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
  }

  export type TaskAssignmentUpsertWithWhereUniqueWithoutUserInput = {
    where: TaskAssignmentWhereUniqueInput
    update: XOR<TaskAssignmentUpdateWithoutUserInput, TaskAssignmentUncheckedUpdateWithoutUserInput>
    create: XOR<TaskAssignmentCreateWithoutUserInput, TaskAssignmentUncheckedCreateWithoutUserInput>
  }

  export type TaskAssignmentUpdateWithWhereUniqueWithoutUserInput = {
    where: TaskAssignmentWhereUniqueInput
    data: XOR<TaskAssignmentUpdateWithoutUserInput, TaskAssignmentUncheckedUpdateWithoutUserInput>
  }

  export type TaskAssignmentUpdateManyWithWhereWithoutUserInput = {
    where: TaskAssignmentScalarWhereInput
    data: XOR<TaskAssignmentUpdateManyMutationInput, TaskAssignmentUncheckedUpdateManyWithoutUserInput>
  }

  export type TaskAssignmentScalarWhereInput = {
    AND?: TaskAssignmentScalarWhereInput | TaskAssignmentScalarWhereInput[]
    OR?: TaskAssignmentScalarWhereInput[]
    NOT?: TaskAssignmentScalarWhereInput | TaskAssignmentScalarWhereInput[]
    id?: StringFilter<"TaskAssignment"> | string
    userId?: StringFilter<"TaskAssignment"> | string
    taskId?: StringFilter<"TaskAssignment"> | string
    assignedAt?: DateTimeFilter<"TaskAssignment"> | Date | string
  }

  export type TaskCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: TaskCommentWhereUniqueInput
    update: XOR<TaskCommentUpdateWithoutUserInput, TaskCommentUncheckedUpdateWithoutUserInput>
    create: XOR<TaskCommentCreateWithoutUserInput, TaskCommentUncheckedCreateWithoutUserInput>
  }

  export type TaskCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: TaskCommentWhereUniqueInput
    data: XOR<TaskCommentUpdateWithoutUserInput, TaskCommentUncheckedUpdateWithoutUserInput>
  }

  export type TaskCommentUpdateManyWithWhereWithoutUserInput = {
    where: TaskCommentScalarWhereInput
    data: XOR<TaskCommentUpdateManyMutationInput, TaskCommentUncheckedUpdateManyWithoutUserInput>
  }

  export type TaskCommentScalarWhereInput = {
    AND?: TaskCommentScalarWhereInput | TaskCommentScalarWhereInput[]
    OR?: TaskCommentScalarWhereInput[]
    NOT?: TaskCommentScalarWhereInput | TaskCommentScalarWhereInput[]
    id?: StringFilter<"TaskComment"> | string
    taskId?: StringFilter<"TaskComment"> | string
    userId?: StringFilter<"TaskComment"> | string
    content?: StringFilter<"TaskComment"> | string
    createdAt?: DateTimeFilter<"TaskComment"> | Date | string
  }

  export type TaskTimeLogUpsertWithWhereUniqueWithoutUserInput = {
    where: TaskTimeLogWhereUniqueInput
    update: XOR<TaskTimeLogUpdateWithoutUserInput, TaskTimeLogUncheckedUpdateWithoutUserInput>
    create: XOR<TaskTimeLogCreateWithoutUserInput, TaskTimeLogUncheckedCreateWithoutUserInput>
  }

  export type TaskTimeLogUpdateWithWhereUniqueWithoutUserInput = {
    where: TaskTimeLogWhereUniqueInput
    data: XOR<TaskTimeLogUpdateWithoutUserInput, TaskTimeLogUncheckedUpdateWithoutUserInput>
  }

  export type TaskTimeLogUpdateManyWithWhereWithoutUserInput = {
    where: TaskTimeLogScalarWhereInput
    data: XOR<TaskTimeLogUpdateManyMutationInput, TaskTimeLogUncheckedUpdateManyWithoutUserInput>
  }

  export type TaskTimeLogScalarWhereInput = {
    AND?: TaskTimeLogScalarWhereInput | TaskTimeLogScalarWhereInput[]
    OR?: TaskTimeLogScalarWhereInput[]
    NOT?: TaskTimeLogScalarWhereInput | TaskTimeLogScalarWhereInput[]
    id?: StringFilter<"TaskTimeLog"> | string
    taskId?: StringFilter<"TaskTimeLog"> | string
    userId?: StringFilter<"TaskTimeLog"> | string
    startedAt?: DateTimeFilter<"TaskTimeLog"> | Date | string
    endedAt?: DateTimeNullableFilter<"TaskTimeLog"> | Date | string | null
    durationSeconds?: IntNullableFilter<"TaskTimeLog"> | number | null
  }

  export type AttendanceRecordUpsertWithWhereUniqueWithoutUserInput = {
    where: AttendanceRecordWhereUniqueInput
    update: XOR<AttendanceRecordUpdateWithoutUserInput, AttendanceRecordUncheckedUpdateWithoutUserInput>
    create: XOR<AttendanceRecordCreateWithoutUserInput, AttendanceRecordUncheckedCreateWithoutUserInput>
  }

  export type AttendanceRecordUpdateWithWhereUniqueWithoutUserInput = {
    where: AttendanceRecordWhereUniqueInput
    data: XOR<AttendanceRecordUpdateWithoutUserInput, AttendanceRecordUncheckedUpdateWithoutUserInput>
  }

  export type AttendanceRecordUpdateManyWithWhereWithoutUserInput = {
    where: AttendanceRecordScalarWhereInput
    data: XOR<AttendanceRecordUpdateManyMutationInput, AttendanceRecordUncheckedUpdateManyWithoutUserInput>
  }

  export type AttendanceRecordScalarWhereInput = {
    AND?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
    OR?: AttendanceRecordScalarWhereInput[]
    NOT?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
    id?: StringFilter<"AttendanceRecord"> | string
    userId?: StringFilter<"AttendanceRecord"> | string
    date?: DateTimeFilter<"AttendanceRecord"> | Date | string
    clockIn?: DateTimeNullableFilter<"AttendanceRecord"> | Date | string | null
    clockOut?: DateTimeNullableFilter<"AttendanceRecord"> | Date | string | null
    status?: EnumAttendanceStatusFilter<"AttendanceRecord"> | $Enums.AttendanceStatus
    ipAddress?: StringNullableFilter<"AttendanceRecord"> | string | null
    location?: StringNullableFilter<"AttendanceRecord"> | string | null
  }

  export type LeaveUpsertWithWhereUniqueWithoutUserInput = {
    where: LeaveWhereUniqueInput
    update: XOR<LeaveUpdateWithoutUserInput, LeaveUncheckedUpdateWithoutUserInput>
    create: XOR<LeaveCreateWithoutUserInput, LeaveUncheckedCreateWithoutUserInput>
  }

  export type LeaveUpdateWithWhereUniqueWithoutUserInput = {
    where: LeaveWhereUniqueInput
    data: XOR<LeaveUpdateWithoutUserInput, LeaveUncheckedUpdateWithoutUserInput>
  }

  export type LeaveUpdateManyWithWhereWithoutUserInput = {
    where: LeaveScalarWhereInput
    data: XOR<LeaveUpdateManyMutationInput, LeaveUncheckedUpdateManyWithoutUserInput>
  }

  export type LeaveScalarWhereInput = {
    AND?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
    OR?: LeaveScalarWhereInput[]
    NOT?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
    id?: StringFilter<"Leave"> | string
    userId?: StringFilter<"Leave"> | string
    startDate?: DateTimeFilter<"Leave"> | Date | string
    endDate?: DateTimeFilter<"Leave"> | Date | string
    reason?: StringNullableFilter<"Leave"> | string | null
    status?: EnumLeaveStatusFilter<"Leave"> | $Enums.LeaveStatus
    approverId?: StringNullableFilter<"Leave"> | string | null
    createdAt?: DateTimeFilter<"Leave"> | Date | string
    updatedAt?: DateTimeFilter<"Leave"> | Date | string
  }

  export type LeaveUpsertWithWhereUniqueWithoutApproverInput = {
    where: LeaveWhereUniqueInput
    update: XOR<LeaveUpdateWithoutApproverInput, LeaveUncheckedUpdateWithoutApproverInput>
    create: XOR<LeaveCreateWithoutApproverInput, LeaveUncheckedCreateWithoutApproverInput>
  }

  export type LeaveUpdateWithWhereUniqueWithoutApproverInput = {
    where: LeaveWhereUniqueInput
    data: XOR<LeaveUpdateWithoutApproverInput, LeaveUncheckedUpdateWithoutApproverInput>
  }

  export type LeaveUpdateManyWithWhereWithoutApproverInput = {
    where: LeaveScalarWhereInput
    data: XOR<LeaveUpdateManyMutationInput, LeaveUncheckedUpdateManyWithoutApproverInput>
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutSenderInput, ChatMessageUncheckedUpdateWithoutSenderInput>
    create: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutSenderInput, ChatMessageUncheckedUpdateWithoutSenderInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutSenderInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type ChatMessageScalarWhereInput = {
    AND?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    OR?: ChatMessageScalarWhereInput[]
    NOT?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    id?: StringFilter<"ChatMessage"> | string
    senderId?: StringFilter<"ChatMessage"> | string
    receiverId?: StringNullableFilter<"ChatMessage"> | string | null
    groupId?: StringNullableFilter<"ChatMessage"> | string | null
    content?: StringFilter<"ChatMessage"> | string
    timestamp?: DateTimeFilter<"ChatMessage"> | Date | string
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutReceiverInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutReceiverInput, ChatMessageUncheckedUpdateWithoutReceiverInput>
    create: XOR<ChatMessageCreateWithoutReceiverInput, ChatMessageUncheckedCreateWithoutReceiverInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutReceiverInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutReceiverInput, ChatMessageUncheckedUpdateWithoutReceiverInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutReceiverInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutReceiverInput>
  }

  export type ChatGroupMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: ChatGroupMemberWhereUniqueInput
    update: XOR<ChatGroupMemberUpdateWithoutUserInput, ChatGroupMemberUncheckedUpdateWithoutUserInput>
    create: XOR<ChatGroupMemberCreateWithoutUserInput, ChatGroupMemberUncheckedCreateWithoutUserInput>
  }

  export type ChatGroupMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: ChatGroupMemberWhereUniqueInput
    data: XOR<ChatGroupMemberUpdateWithoutUserInput, ChatGroupMemberUncheckedUpdateWithoutUserInput>
  }

  export type ChatGroupMemberUpdateManyWithWhereWithoutUserInput = {
    where: ChatGroupMemberScalarWhereInput
    data: XOR<ChatGroupMemberUpdateManyMutationInput, ChatGroupMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type ChatGroupMemberScalarWhereInput = {
    AND?: ChatGroupMemberScalarWhereInput | ChatGroupMemberScalarWhereInput[]
    OR?: ChatGroupMemberScalarWhereInput[]
    NOT?: ChatGroupMemberScalarWhereInput | ChatGroupMemberScalarWhereInput[]
    id?: StringFilter<"ChatGroupMember"> | string
    groupId?: StringFilter<"ChatGroupMember"> | string
    userId?: StringFilter<"ChatGroupMember"> | string
    joinedAt?: DateTimeFilter<"ChatGroupMember"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    data?: JsonNullableFilter<"Notification">
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type DocumentUpsertWithWhereUniqueWithoutUserInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutUserInput, DocumentUncheckedUpdateWithoutUserInput>
    create: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutUserInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutUserInput, DocumentUncheckedUpdateWithoutUserInput>
  }

  export type DocumentUpdateManyWithWhereWithoutUserInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutUserInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    userId?: StringFilter<"Document"> | string
    title?: StringFilter<"Document"> | string
    fileUrl?: StringFilter<"Document"> | string
    createdAt?: DateTimeFilter<"Document"> | Date | string
  }

  export type CompanyDocumentUpsertWithWhereUniqueWithoutUploaderInput = {
    where: CompanyDocumentWhereUniqueInput
    update: XOR<CompanyDocumentUpdateWithoutUploaderInput, CompanyDocumentUncheckedUpdateWithoutUploaderInput>
    create: XOR<CompanyDocumentCreateWithoutUploaderInput, CompanyDocumentUncheckedCreateWithoutUploaderInput>
  }

  export type CompanyDocumentUpdateWithWhereUniqueWithoutUploaderInput = {
    where: CompanyDocumentWhereUniqueInput
    data: XOR<CompanyDocumentUpdateWithoutUploaderInput, CompanyDocumentUncheckedUpdateWithoutUploaderInput>
  }

  export type CompanyDocumentUpdateManyWithWhereWithoutUploaderInput = {
    where: CompanyDocumentScalarWhereInput
    data: XOR<CompanyDocumentUpdateManyMutationInput, CompanyDocumentUncheckedUpdateManyWithoutUploaderInput>
  }

  export type CompanyDocumentScalarWhereInput = {
    AND?: CompanyDocumentScalarWhereInput | CompanyDocumentScalarWhereInput[]
    OR?: CompanyDocumentScalarWhereInput[]
    NOT?: CompanyDocumentScalarWhereInput | CompanyDocumentScalarWhereInput[]
    id?: StringFilter<"CompanyDocument"> | string
    title?: StringFilter<"CompanyDocument"> | string
    description?: StringNullableFilter<"CompanyDocument"> | string | null
    fileUrl?: StringFilter<"CompanyDocument"> | string
    uploadedBy?: StringFilter<"CompanyDocument"> | string
    createdAt?: DateTimeFilter<"CompanyDocument"> | Date | string
  }

  export type ExpenseUpsertWithWhereUniqueWithoutOwnerInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutOwnerInput, ExpenseUncheckedUpdateWithoutOwnerInput>
    create: XOR<ExpenseCreateWithoutOwnerInput, ExpenseUncheckedCreateWithoutOwnerInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutOwnerInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutOwnerInput, ExpenseUncheckedUpdateWithoutOwnerInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutOwnerInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutOwnerInput>
  }

  export type ExpenseScalarWhereInput = {
    AND?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    OR?: ExpenseScalarWhereInput[]
    NOT?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    id?: StringFilter<"Expense"> | string
    userId?: StringFilter<"Expense"> | string
    title?: StringFilter<"Expense"> | string
    description?: StringNullableFilter<"Expense"> | string | null
    category?: StringNullableFilter<"Expense"> | string | null
    amount?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Expense"> | string
    date?: DateTimeFilter<"Expense"> | Date | string
    status?: EnumExpenseStatusFilter<"Expense"> | $Enums.ExpenseStatus
    receiptUrl?: StringNullableFilter<"Expense"> | string | null
    submittedAt?: DateTimeFilter<"Expense"> | Date | string
    approvedAt?: DateTimeNullableFilter<"Expense"> | Date | string | null
    approvedById?: StringNullableFilter<"Expense"> | string | null
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
  }

  export type ExpenseUpsertWithWhereUniqueWithoutApproverInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutApproverInput, ExpenseUncheckedUpdateWithoutApproverInput>
    create: XOR<ExpenseCreateWithoutApproverInput, ExpenseUncheckedCreateWithoutApproverInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutApproverInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutApproverInput, ExpenseUncheckedUpdateWithoutApproverInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutApproverInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutApproverInput>
  }

  export type PayrollUpsertWithWhereUniqueWithoutUserInput = {
    where: PayrollWhereUniqueInput
    update: XOR<PayrollUpdateWithoutUserInput, PayrollUncheckedUpdateWithoutUserInput>
    create: XOR<PayrollCreateWithoutUserInput, PayrollUncheckedCreateWithoutUserInput>
  }

  export type PayrollUpdateWithWhereUniqueWithoutUserInput = {
    where: PayrollWhereUniqueInput
    data: XOR<PayrollUpdateWithoutUserInput, PayrollUncheckedUpdateWithoutUserInput>
  }

  export type PayrollUpdateManyWithWhereWithoutUserInput = {
    where: PayrollScalarWhereInput
    data: XOR<PayrollUpdateManyMutationInput, PayrollUncheckedUpdateManyWithoutUserInput>
  }

  export type PayrollScalarWhereInput = {
    AND?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
    OR?: PayrollScalarWhereInput[]
    NOT?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
    id?: StringFilter<"Payroll"> | string
    userId?: StringFilter<"Payroll"> | string
    month?: IntFilter<"Payroll"> | number
    year?: IntFilter<"Payroll"> | number
    baseSalary?: DecimalFilter<"Payroll"> | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFilter<"Payroll"> | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFilter<"Payroll"> | Decimal | DecimalJsLike | number | string
    netPay?: DecimalFilter<"Payroll"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payroll"> | string
    status?: EnumPayrollStatusFilter<"Payroll"> | $Enums.PayrollStatus
    generatedById?: StringNullableFilter<"Payroll"> | string | null
    generatedAt?: DateTimeNullableFilter<"Payroll"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"Payroll"> | Date | string | null
    slipUrl?: StringNullableFilter<"Payroll"> | string | null
    createdAt?: DateTimeFilter<"Payroll"> | Date | string
    updatedAt?: DateTimeFilter<"Payroll"> | Date | string
  }

  export type PayrollUpsertWithWhereUniqueWithoutGeneratedByInput = {
    where: PayrollWhereUniqueInput
    update: XOR<PayrollUpdateWithoutGeneratedByInput, PayrollUncheckedUpdateWithoutGeneratedByInput>
    create: XOR<PayrollCreateWithoutGeneratedByInput, PayrollUncheckedCreateWithoutGeneratedByInput>
  }

  export type PayrollUpdateWithWhereUniqueWithoutGeneratedByInput = {
    where: PayrollWhereUniqueInput
    data: XOR<PayrollUpdateWithoutGeneratedByInput, PayrollUncheckedUpdateWithoutGeneratedByInput>
  }

  export type PayrollUpdateManyWithWhereWithoutGeneratedByInput = {
    where: PayrollScalarWhereInput
    data: XOR<PayrollUpdateManyMutationInput, PayrollUncheckedUpdateManyWithoutGeneratedByInput>
  }

  export type PerformanceReviewUpsertWithWhereUniqueWithoutReviewerInput = {
    where: PerformanceReviewWhereUniqueInput
    update: XOR<PerformanceReviewUpdateWithoutReviewerInput, PerformanceReviewUncheckedUpdateWithoutReviewerInput>
    create: XOR<PerformanceReviewCreateWithoutReviewerInput, PerformanceReviewUncheckedCreateWithoutReviewerInput>
  }

  export type PerformanceReviewUpdateWithWhereUniqueWithoutReviewerInput = {
    where: PerformanceReviewWhereUniqueInput
    data: XOR<PerformanceReviewUpdateWithoutReviewerInput, PerformanceReviewUncheckedUpdateWithoutReviewerInput>
  }

  export type PerformanceReviewUpdateManyWithWhereWithoutReviewerInput = {
    where: PerformanceReviewScalarWhereInput
    data: XOR<PerformanceReviewUpdateManyMutationInput, PerformanceReviewUncheckedUpdateManyWithoutReviewerInput>
  }

  export type PerformanceReviewScalarWhereInput = {
    AND?: PerformanceReviewScalarWhereInput | PerformanceReviewScalarWhereInput[]
    OR?: PerformanceReviewScalarWhereInput[]
    NOT?: PerformanceReviewScalarWhereInput | PerformanceReviewScalarWhereInput[]
    id?: StringFilter<"PerformanceReview"> | string
    revieweeId?: StringFilter<"PerformanceReview"> | string
    reviewerId?: StringFilter<"PerformanceReview"> | string
    periodStart?: DateTimeFilter<"PerformanceReview"> | Date | string
    periodEnd?: DateTimeFilter<"PerformanceReview"> | Date | string
    overallScore?: IntFilter<"PerformanceReview"> | number
    kpiScores?: JsonNullableFilter<"PerformanceReview">
    feedback?: StringNullableFilter<"PerformanceReview"> | string | null
    createdAt?: DateTimeFilter<"PerformanceReview"> | Date | string
  }

  export type PerformanceReviewUpsertWithWhereUniqueWithoutRevieweeInput = {
    where: PerformanceReviewWhereUniqueInput
    update: XOR<PerformanceReviewUpdateWithoutRevieweeInput, PerformanceReviewUncheckedUpdateWithoutRevieweeInput>
    create: XOR<PerformanceReviewCreateWithoutRevieweeInput, PerformanceReviewUncheckedCreateWithoutRevieweeInput>
  }

  export type PerformanceReviewUpdateWithWhereUniqueWithoutRevieweeInput = {
    where: PerformanceReviewWhereUniqueInput
    data: XOR<PerformanceReviewUpdateWithoutRevieweeInput, PerformanceReviewUncheckedUpdateWithoutRevieweeInput>
  }

  export type PerformanceReviewUpdateManyWithWhereWithoutRevieweeInput = {
    where: PerformanceReviewScalarWhereInput
    data: XOR<PerformanceReviewUpdateManyMutationInput, PerformanceReviewUncheckedUpdateManyWithoutRevieweeInput>
  }

  export type AssetUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: AssetWhereUniqueInput
    update: XOR<AssetUpdateWithoutAssignedToInput, AssetUncheckedUpdateWithoutAssignedToInput>
    create: XOR<AssetCreateWithoutAssignedToInput, AssetUncheckedCreateWithoutAssignedToInput>
  }

  export type AssetUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: AssetWhereUniqueInput
    data: XOR<AssetUpdateWithoutAssignedToInput, AssetUncheckedUpdateWithoutAssignedToInput>
  }

  export type AssetUpdateManyWithWhereWithoutAssignedToInput = {
    where: AssetScalarWhereInput
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type AssetScalarWhereInput = {
    AND?: AssetScalarWhereInput | AssetScalarWhereInput[]
    OR?: AssetScalarWhereInput[]
    NOT?: AssetScalarWhereInput | AssetScalarWhereInput[]
    id?: StringFilter<"Asset"> | string
    tag?: StringFilter<"Asset"> | string
    name?: StringFilter<"Asset"> | string
    type?: StringNullableFilter<"Asset"> | string | null
    serialNumber?: StringNullableFilter<"Asset"> | string | null
    purchaseDate?: DateTimeNullableFilter<"Asset"> | Date | string | null
    status?: EnumAssetStatusFilter<"Asset"> | $Enums.AssetStatus
    assignedToId?: StringNullableFilter<"Asset"> | string | null
    assignedAt?: DateTimeNullableFilter<"Asset"> | Date | string | null
    location?: StringNullableFilter<"Asset"> | string | null
    notes?: StringNullableFilter<"Asset"> | string | null
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    updatedAt?: DateTimeFilter<"Asset"> | Date | string
  }

  export type JobPostUpsertWithWhereUniqueWithoutPostedByInput = {
    where: JobPostWhereUniqueInput
    update: XOR<JobPostUpdateWithoutPostedByInput, JobPostUncheckedUpdateWithoutPostedByInput>
    create: XOR<JobPostCreateWithoutPostedByInput, JobPostUncheckedCreateWithoutPostedByInput>
  }

  export type JobPostUpdateWithWhereUniqueWithoutPostedByInput = {
    where: JobPostWhereUniqueInput
    data: XOR<JobPostUpdateWithoutPostedByInput, JobPostUncheckedUpdateWithoutPostedByInput>
  }

  export type JobPostUpdateManyWithWhereWithoutPostedByInput = {
    where: JobPostScalarWhereInput
    data: XOR<JobPostUpdateManyMutationInput, JobPostUncheckedUpdateManyWithoutPostedByInput>
  }

  export type JobPostScalarWhereInput = {
    AND?: JobPostScalarWhereInput | JobPostScalarWhereInput[]
    OR?: JobPostScalarWhereInput[]
    NOT?: JobPostScalarWhereInput | JobPostScalarWhereInput[]
    id?: StringFilter<"JobPost"> | string
    title?: StringFilter<"JobPost"> | string
    departmentId?: StringNullableFilter<"JobPost"> | string | null
    type?: EnumJobTypeFilter<"JobPost"> | $Enums.JobType
    location?: StringNullableFilter<"JobPost"> | string | null
    description?: StringNullableFilter<"JobPost"> | string | null
    postedById?: StringFilter<"JobPost"> | string
    isActive?: BoolFilter<"JobPost"> | boolean
    createdAt?: DateTimeFilter<"JobPost"> | Date | string
    updatedAt?: DateTimeFilter<"JobPost"> | Date | string
  }

  export type ApplicationUpsertWithWhereUniqueWithoutApplicantInput = {
    where: ApplicationWhereUniqueInput
    update: XOR<ApplicationUpdateWithoutApplicantInput, ApplicationUncheckedUpdateWithoutApplicantInput>
    create: XOR<ApplicationCreateWithoutApplicantInput, ApplicationUncheckedCreateWithoutApplicantInput>
  }

  export type ApplicationUpdateWithWhereUniqueWithoutApplicantInput = {
    where: ApplicationWhereUniqueInput
    data: XOR<ApplicationUpdateWithoutApplicantInput, ApplicationUncheckedUpdateWithoutApplicantInput>
  }

  export type ApplicationUpdateManyWithWhereWithoutApplicantInput = {
    where: ApplicationScalarWhereInput
    data: XOR<ApplicationUpdateManyMutationInput, ApplicationUncheckedUpdateManyWithoutApplicantInput>
  }

  export type ApplicationScalarWhereInput = {
    AND?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
    OR?: ApplicationScalarWhereInput[]
    NOT?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
    id?: StringFilter<"Application"> | string
    jobPostId?: StringFilter<"Application"> | string
    applicantUserId?: StringNullableFilter<"Application"> | string | null
    applicantName?: StringFilter<"Application"> | string
    applicantEmail?: StringFilter<"Application"> | string
    resumeUrl?: StringNullableFilter<"Application"> | string | null
    coverLetter?: StringNullableFilter<"Application"> | string | null
    status?: EnumApplicationStatusFilter<"Application"> | $Enums.ApplicationStatus
    notes?: StringNullableFilter<"Application"> | string | null
    createdAt?: DateTimeFilter<"Application"> | Date | string
    updatedAt?: DateTimeFilter<"Application"> | Date | string
  }

  export type CalendarEventUpsertWithWhereUniqueWithoutOrganizerInput = {
    where: CalendarEventWhereUniqueInput
    update: XOR<CalendarEventUpdateWithoutOrganizerInput, CalendarEventUncheckedUpdateWithoutOrganizerInput>
    create: XOR<CalendarEventCreateWithoutOrganizerInput, CalendarEventUncheckedCreateWithoutOrganizerInput>
  }

  export type CalendarEventUpdateWithWhereUniqueWithoutOrganizerInput = {
    where: CalendarEventWhereUniqueInput
    data: XOR<CalendarEventUpdateWithoutOrganizerInput, CalendarEventUncheckedUpdateWithoutOrganizerInput>
  }

  export type CalendarEventUpdateManyWithWhereWithoutOrganizerInput = {
    where: CalendarEventScalarWhereInput
    data: XOR<CalendarEventUpdateManyMutationInput, CalendarEventUncheckedUpdateManyWithoutOrganizerInput>
  }

  export type CalendarEventScalarWhereInput = {
    AND?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
    OR?: CalendarEventScalarWhereInput[]
    NOT?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
    id?: StringFilter<"CalendarEvent"> | string
    title?: StringFilter<"CalendarEvent"> | string
    description?: StringNullableFilter<"CalendarEvent"> | string | null
    organizerId?: StringFilter<"CalendarEvent"> | string
    startTime?: DateTimeFilter<"CalendarEvent"> | Date | string
    endTime?: DateTimeFilter<"CalendarEvent"> | Date | string
    source?: EnumEventSourceFilter<"CalendarEvent"> | $Enums.EventSource
    googleMeetLink?: StringNullableFilter<"CalendarEvent"> | string | null
    location?: StringNullableFilter<"CalendarEvent"> | string | null
    createdAt?: DateTimeFilter<"CalendarEvent"> | Date | string
    updatedAt?: DateTimeFilter<"CalendarEvent"> | Date | string
  }

  export type CalendarAttendeeUpsertWithWhereUniqueWithoutUserInput = {
    where: CalendarAttendeeWhereUniqueInput
    update: XOR<CalendarAttendeeUpdateWithoutUserInput, CalendarAttendeeUncheckedUpdateWithoutUserInput>
    create: XOR<CalendarAttendeeCreateWithoutUserInput, CalendarAttendeeUncheckedCreateWithoutUserInput>
  }

  export type CalendarAttendeeUpdateWithWhereUniqueWithoutUserInput = {
    where: CalendarAttendeeWhereUniqueInput
    data: XOR<CalendarAttendeeUpdateWithoutUserInput, CalendarAttendeeUncheckedUpdateWithoutUserInput>
  }

  export type CalendarAttendeeUpdateManyWithWhereWithoutUserInput = {
    where: CalendarAttendeeScalarWhereInput
    data: XOR<CalendarAttendeeUpdateManyMutationInput, CalendarAttendeeUncheckedUpdateManyWithoutUserInput>
  }

  export type CalendarAttendeeScalarWhereInput = {
    AND?: CalendarAttendeeScalarWhereInput | CalendarAttendeeScalarWhereInput[]
    OR?: CalendarAttendeeScalarWhereInput[]
    NOT?: CalendarAttendeeScalarWhereInput | CalendarAttendeeScalarWhereInput[]
    id?: StringFilter<"CalendarAttendee"> | string
    eventId?: StringFilter<"CalendarAttendee"> | string
    userId?: StringFilter<"CalendarAttendee"> | string
    response?: StringNullableFilter<"CalendarAttendee"> | string | null
  }

  export type TrainingEnrollmentUpsertWithWhereUniqueWithoutUserInput = {
    where: TrainingEnrollmentWhereUniqueInput
    update: XOR<TrainingEnrollmentUpdateWithoutUserInput, TrainingEnrollmentUncheckedUpdateWithoutUserInput>
    create: XOR<TrainingEnrollmentCreateWithoutUserInput, TrainingEnrollmentUncheckedCreateWithoutUserInput>
  }

  export type TrainingEnrollmentUpdateWithWhereUniqueWithoutUserInput = {
    where: TrainingEnrollmentWhereUniqueInput
    data: XOR<TrainingEnrollmentUpdateWithoutUserInput, TrainingEnrollmentUncheckedUpdateWithoutUserInput>
  }

  export type TrainingEnrollmentUpdateManyWithWhereWithoutUserInput = {
    where: TrainingEnrollmentScalarWhereInput
    data: XOR<TrainingEnrollmentUpdateManyMutationInput, TrainingEnrollmentUncheckedUpdateManyWithoutUserInput>
  }

  export type TrainingEnrollmentScalarWhereInput = {
    AND?: TrainingEnrollmentScalarWhereInput | TrainingEnrollmentScalarWhereInput[]
    OR?: TrainingEnrollmentScalarWhereInput[]
    NOT?: TrainingEnrollmentScalarWhereInput | TrainingEnrollmentScalarWhereInput[]
    id?: StringFilter<"TrainingEnrollment"> | string
    trainingId?: StringFilter<"TrainingEnrollment"> | string
    userId?: StringFilter<"TrainingEnrollment"> | string
    enrolledAt?: DateTimeFilter<"TrainingEnrollment"> | Date | string
    completedAt?: DateTimeNullableFilter<"TrainingEnrollment"> | Date | string | null
    certificateUrl?: StringNullableFilter<"TrainingEnrollment"> | string | null
  }

  export type AnnouncementUpsertWithWhereUniqueWithoutAuthorInput = {
    where: AnnouncementWhereUniqueInput
    update: XOR<AnnouncementUpdateWithoutAuthorInput, AnnouncementUncheckedUpdateWithoutAuthorInput>
    create: XOR<AnnouncementCreateWithoutAuthorInput, AnnouncementUncheckedCreateWithoutAuthorInput>
  }

  export type AnnouncementUpdateWithWhereUniqueWithoutAuthorInput = {
    where: AnnouncementWhereUniqueInput
    data: XOR<AnnouncementUpdateWithoutAuthorInput, AnnouncementUncheckedUpdateWithoutAuthorInput>
  }

  export type AnnouncementUpdateManyWithWhereWithoutAuthorInput = {
    where: AnnouncementScalarWhereInput
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyWithoutAuthorInput>
  }

  export type AnnouncementScalarWhereInput = {
    AND?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
    OR?: AnnouncementScalarWhereInput[]
    NOT?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
    id?: StringFilter<"Announcement"> | string
    title?: StringFilter<"Announcement"> | string
    content?: StringFilter<"Announcement"> | string
    authorId?: StringFilter<"Announcement"> | string
    departmentId?: StringNullableFilter<"Announcement"> | string | null
    createdAt?: DateTimeFilter<"Announcement"> | Date | string
  }

  export type UserPreferenceUpsertWithoutUserInput = {
    update: XOR<UserPreferenceUpdateWithoutUserInput, UserPreferenceUncheckedUpdateWithoutUserInput>
    create: XOR<UserPreferenceCreateWithoutUserInput, UserPreferenceUncheckedCreateWithoutUserInput>
    where?: UserPreferenceWhereInput
  }

  export type UserPreferenceUpdateToOneWithWhereWithoutUserInput = {
    where?: UserPreferenceWhereInput
    data: XOR<UserPreferenceUpdateWithoutUserInput, UserPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type UserPreferenceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserPreferenceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AuditLogUpsertWithWhereUniqueWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutActorInput, AuditLogUncheckedUpdateWithoutActorInput>
    create: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutActorInput, AuditLogUncheckedUpdateWithoutActorInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutActorInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutActorInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    actorId?: StringNullableFilter<"AuditLog"> | string | null
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type DepartmentUpsertWithWhereUniqueWithoutHeadInput = {
    where: DepartmentWhereUniqueInput
    update: XOR<DepartmentUpdateWithoutHeadInput, DepartmentUncheckedUpdateWithoutHeadInput>
    create: XOR<DepartmentCreateWithoutHeadInput, DepartmentUncheckedCreateWithoutHeadInput>
  }

  export type DepartmentUpdateWithWhereUniqueWithoutHeadInput = {
    where: DepartmentWhereUniqueInput
    data: XOR<DepartmentUpdateWithoutHeadInput, DepartmentUncheckedUpdateWithoutHeadInput>
  }

  export type DepartmentUpdateManyWithWhereWithoutHeadInput = {
    where: DepartmentScalarWhereInput
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyWithoutHeadInput>
  }

  export type DepartmentScalarWhereInput = {
    AND?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    OR?: DepartmentScalarWhereInput[]
    NOT?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    id?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    description?: StringNullableFilter<"Department"> | string | null
    headId?: StringNullableFilter<"Department"> | string | null
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
  }

  export type UserCreateWithoutHeadedDepartmentsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutReportsInput
    reports?: UserCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseCreateNestedManyWithoutApproverInput
    payrolls?: PayrollCreateNestedManyWithoutUserInput
    generatedPays?: PayrollCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostCreateNestedManyWithoutPostedByInput
    applications?: ApplicationCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutHeadedDepartmentsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    departmentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: UserUncheckedCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveUncheckedCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseUncheckedCreateNestedManyWithoutApproverInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutUserInput
    generatedPays?: PayrollUncheckedCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewUncheckedCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetUncheckedCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostUncheckedCreateNestedManyWithoutPostedByInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventUncheckedCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeUncheckedCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentUncheckedCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutHeadedDepartmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHeadedDepartmentsInput, UserUncheckedCreateWithoutHeadedDepartmentsInput>
  }

  export type UserCreateWithoutDepartmentInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    manager?: UserCreateNestedOneWithoutReportsInput
    reports?: UserCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseCreateNestedManyWithoutApproverInput
    payrolls?: PayrollCreateNestedManyWithoutUserInput
    generatedPays?: PayrollCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostCreateNestedManyWithoutPostedByInput
    applications?: ApplicationCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
  }

  export type UserUncheckedCreateWithoutDepartmentInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: UserUncheckedCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveUncheckedCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseUncheckedCreateNestedManyWithoutApproverInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutUserInput
    generatedPays?: PayrollUncheckedCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewUncheckedCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetUncheckedCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostUncheckedCreateNestedManyWithoutPostedByInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventUncheckedCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeUncheckedCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentUncheckedCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
  }

  export type UserCreateOrConnectWithoutDepartmentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput>
  }

  export type UserCreateManyDepartmentInputEnvelope = {
    data: UserCreateManyDepartmentInput | UserCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type AnnouncementCreateWithoutDepartmentInput = {
    id?: string
    title: string
    content: string
    createdAt?: Date | string
    author: UserCreateNestedOneWithoutAnnouncementsMadeInput
  }

  export type AnnouncementUncheckedCreateWithoutDepartmentInput = {
    id?: string
    title: string
    content: string
    authorId: string
    createdAt?: Date | string
  }

  export type AnnouncementCreateOrConnectWithoutDepartmentInput = {
    where: AnnouncementWhereUniqueInput
    create: XOR<AnnouncementCreateWithoutDepartmentInput, AnnouncementUncheckedCreateWithoutDepartmentInput>
  }

  export type AnnouncementCreateManyDepartmentInputEnvelope = {
    data: AnnouncementCreateManyDepartmentInput | AnnouncementCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type JobPostCreateWithoutDepartmentInput = {
    id?: string
    title: string
    type?: $Enums.JobType
    location?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    postedBy: UserCreateNestedOneWithoutJobPostsInput
    applications?: ApplicationCreateNestedManyWithoutJobPostInput
  }

  export type JobPostUncheckedCreateWithoutDepartmentInput = {
    id?: string
    title: string
    type?: $Enums.JobType
    location?: string | null
    description?: string | null
    postedById: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: ApplicationUncheckedCreateNestedManyWithoutJobPostInput
  }

  export type JobPostCreateOrConnectWithoutDepartmentInput = {
    where: JobPostWhereUniqueInput
    create: XOR<JobPostCreateWithoutDepartmentInput, JobPostUncheckedCreateWithoutDepartmentInput>
  }

  export type JobPostCreateManyDepartmentInputEnvelope = {
    data: JobPostCreateManyDepartmentInput | JobPostCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutHeadedDepartmentsInput = {
    update: XOR<UserUpdateWithoutHeadedDepartmentsInput, UserUncheckedUpdateWithoutHeadedDepartmentsInput>
    create: XOR<UserCreateWithoutHeadedDepartmentsInput, UserUncheckedCreateWithoutHeadedDepartmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHeadedDepartmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHeadedDepartmentsInput, UserUncheckedUpdateWithoutHeadedDepartmentsInput>
  }

  export type UserUpdateWithoutHeadedDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutReportsNestedInput
    reports?: UserUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutHeadedDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUncheckedUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUncheckedUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUncheckedUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUncheckedUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUncheckedUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUncheckedUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUncheckedUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutDepartmentInput, UserUncheckedUpdateWithoutDepartmentInput>
    create: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput>
  }

  export type UserUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutDepartmentInput, UserUncheckedUpdateWithoutDepartmentInput>
  }

  export type UserUpdateManyWithWhereWithoutDepartmentInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type AnnouncementUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: AnnouncementWhereUniqueInput
    update: XOR<AnnouncementUpdateWithoutDepartmentInput, AnnouncementUncheckedUpdateWithoutDepartmentInput>
    create: XOR<AnnouncementCreateWithoutDepartmentInput, AnnouncementUncheckedCreateWithoutDepartmentInput>
  }

  export type AnnouncementUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: AnnouncementWhereUniqueInput
    data: XOR<AnnouncementUpdateWithoutDepartmentInput, AnnouncementUncheckedUpdateWithoutDepartmentInput>
  }

  export type AnnouncementUpdateManyWithWhereWithoutDepartmentInput = {
    where: AnnouncementScalarWhereInput
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type JobPostUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: JobPostWhereUniqueInput
    update: XOR<JobPostUpdateWithoutDepartmentInput, JobPostUncheckedUpdateWithoutDepartmentInput>
    create: XOR<JobPostCreateWithoutDepartmentInput, JobPostUncheckedCreateWithoutDepartmentInput>
  }

  export type JobPostUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: JobPostWhereUniqueInput
    data: XOR<JobPostUpdateWithoutDepartmentInput, JobPostUncheckedUpdateWithoutDepartmentInput>
  }

  export type JobPostUpdateManyWithWhereWithoutDepartmentInput = {
    where: JobPostScalarWhereInput
    data: XOR<JobPostUpdateManyMutationInput, JobPostUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type UserCreateWithoutTasksCreatedInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutReportsInput
    reports?: UserCreateNestedManyWithoutManagerInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseCreateNestedManyWithoutApproverInput
    payrolls?: PayrollCreateNestedManyWithoutUserInput
    generatedPays?: PayrollCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostCreateNestedManyWithoutPostedByInput
    applications?: ApplicationCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
  }

  export type UserUncheckedCreateWithoutTasksCreatedInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    departmentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: UserUncheckedCreateNestedManyWithoutManagerInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveUncheckedCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseUncheckedCreateNestedManyWithoutApproverInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutUserInput
    generatedPays?: PayrollUncheckedCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewUncheckedCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetUncheckedCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostUncheckedCreateNestedManyWithoutPostedByInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventUncheckedCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeUncheckedCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentUncheckedCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
  }

  export type UserCreateOrConnectWithoutTasksCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTasksCreatedInput, UserUncheckedCreateWithoutTasksCreatedInput>
  }

  export type TaskAssignmentCreateWithoutTaskInput = {
    id?: string
    assignedAt?: Date | string
    user: UserCreateNestedOneWithoutTaskAssignmentsInput
  }

  export type TaskAssignmentUncheckedCreateWithoutTaskInput = {
    id?: string
    userId: string
    assignedAt?: Date | string
  }

  export type TaskAssignmentCreateOrConnectWithoutTaskInput = {
    where: TaskAssignmentWhereUniqueInput
    create: XOR<TaskAssignmentCreateWithoutTaskInput, TaskAssignmentUncheckedCreateWithoutTaskInput>
  }

  export type TaskAssignmentCreateManyTaskInputEnvelope = {
    data: TaskAssignmentCreateManyTaskInput | TaskAssignmentCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type TaskCommentCreateWithoutTaskInput = {
    id?: string
    content: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTaskCommentsInput
  }

  export type TaskCommentUncheckedCreateWithoutTaskInput = {
    id?: string
    userId: string
    content: string
    createdAt?: Date | string
  }

  export type TaskCommentCreateOrConnectWithoutTaskInput = {
    where: TaskCommentWhereUniqueInput
    create: XOR<TaskCommentCreateWithoutTaskInput, TaskCommentUncheckedCreateWithoutTaskInput>
  }

  export type TaskCommentCreateManyTaskInputEnvelope = {
    data: TaskCommentCreateManyTaskInput | TaskCommentCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type TaskTimeLogCreateWithoutTaskInput = {
    id?: string
    startedAt: Date | string
    endedAt?: Date | string | null
    durationSeconds?: number | null
    user: UserCreateNestedOneWithoutTimeLogsInput
  }

  export type TaskTimeLogUncheckedCreateWithoutTaskInput = {
    id?: string
    userId: string
    startedAt: Date | string
    endedAt?: Date | string | null
    durationSeconds?: number | null
  }

  export type TaskTimeLogCreateOrConnectWithoutTaskInput = {
    where: TaskTimeLogWhereUniqueInput
    create: XOR<TaskTimeLogCreateWithoutTaskInput, TaskTimeLogUncheckedCreateWithoutTaskInput>
  }

  export type TaskTimeLogCreateManyTaskInputEnvelope = {
    data: TaskTimeLogCreateManyTaskInput | TaskTimeLogCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutTasksCreatedInput = {
    update: XOR<UserUpdateWithoutTasksCreatedInput, UserUncheckedUpdateWithoutTasksCreatedInput>
    create: XOR<UserCreateWithoutTasksCreatedInput, UserUncheckedCreateWithoutTasksCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTasksCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTasksCreatedInput, UserUncheckedUpdateWithoutTasksCreatedInput>
  }

  export type UserUpdateWithoutTasksCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutReportsNestedInput
    reports?: UserUpdateManyWithoutManagerNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
  }

  export type UserUncheckedUpdateWithoutTasksCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUncheckedUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUncheckedUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUncheckedUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUncheckedUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUncheckedUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUncheckedUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUncheckedUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
  }

  export type TaskAssignmentUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskAssignmentWhereUniqueInput
    update: XOR<TaskAssignmentUpdateWithoutTaskInput, TaskAssignmentUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskAssignmentCreateWithoutTaskInput, TaskAssignmentUncheckedCreateWithoutTaskInput>
  }

  export type TaskAssignmentUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskAssignmentWhereUniqueInput
    data: XOR<TaskAssignmentUpdateWithoutTaskInput, TaskAssignmentUncheckedUpdateWithoutTaskInput>
  }

  export type TaskAssignmentUpdateManyWithWhereWithoutTaskInput = {
    where: TaskAssignmentScalarWhereInput
    data: XOR<TaskAssignmentUpdateManyMutationInput, TaskAssignmentUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskCommentUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskCommentWhereUniqueInput
    update: XOR<TaskCommentUpdateWithoutTaskInput, TaskCommentUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskCommentCreateWithoutTaskInput, TaskCommentUncheckedCreateWithoutTaskInput>
  }

  export type TaskCommentUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskCommentWhereUniqueInput
    data: XOR<TaskCommentUpdateWithoutTaskInput, TaskCommentUncheckedUpdateWithoutTaskInput>
  }

  export type TaskCommentUpdateManyWithWhereWithoutTaskInput = {
    where: TaskCommentScalarWhereInput
    data: XOR<TaskCommentUpdateManyMutationInput, TaskCommentUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskTimeLogUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskTimeLogWhereUniqueInput
    update: XOR<TaskTimeLogUpdateWithoutTaskInput, TaskTimeLogUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskTimeLogCreateWithoutTaskInput, TaskTimeLogUncheckedCreateWithoutTaskInput>
  }

  export type TaskTimeLogUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskTimeLogWhereUniqueInput
    data: XOR<TaskTimeLogUpdateWithoutTaskInput, TaskTimeLogUncheckedUpdateWithoutTaskInput>
  }

  export type TaskTimeLogUpdateManyWithWhereWithoutTaskInput = {
    where: TaskTimeLogScalarWhereInput
    data: XOR<TaskTimeLogUpdateManyMutationInput, TaskTimeLogUncheckedUpdateManyWithoutTaskInput>
  }

  export type UserCreateWithoutTaskAssignmentsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutReportsInput
    reports?: UserCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseCreateNestedManyWithoutApproverInput
    payrolls?: PayrollCreateNestedManyWithoutUserInput
    generatedPays?: PayrollCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostCreateNestedManyWithoutPostedByInput
    applications?: ApplicationCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
  }

  export type UserUncheckedCreateWithoutTaskAssignmentsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    departmentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: UserUncheckedCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveUncheckedCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseUncheckedCreateNestedManyWithoutApproverInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutUserInput
    generatedPays?: PayrollUncheckedCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewUncheckedCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetUncheckedCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostUncheckedCreateNestedManyWithoutPostedByInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventUncheckedCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeUncheckedCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentUncheckedCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
  }

  export type UserCreateOrConnectWithoutTaskAssignmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTaskAssignmentsInput, UserUncheckedCreateWithoutTaskAssignmentsInput>
  }

  export type TaskCreateWithoutAssignmentsInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.TaskPriority
    status?: $Enums.TaskStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutTasksCreatedInput
    comments?: TaskCommentCreateNestedManyWithoutTaskInput
    timeLogs?: TaskTimeLogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutAssignmentsInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.TaskPriority
    status?: $Enums.TaskStatus
    dueDate?: Date | string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: TaskCommentUncheckedCreateNestedManyWithoutTaskInput
    timeLogs?: TaskTimeLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutAssignmentsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutAssignmentsInput, TaskUncheckedCreateWithoutAssignmentsInput>
  }

  export type UserUpsertWithoutTaskAssignmentsInput = {
    update: XOR<UserUpdateWithoutTaskAssignmentsInput, UserUncheckedUpdateWithoutTaskAssignmentsInput>
    create: XOR<UserCreateWithoutTaskAssignmentsInput, UserUncheckedCreateWithoutTaskAssignmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTaskAssignmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTaskAssignmentsInput, UserUncheckedUpdateWithoutTaskAssignmentsInput>
  }

  export type UserUpdateWithoutTaskAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutReportsNestedInput
    reports?: UserUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
  }

  export type UserUncheckedUpdateWithoutTaskAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUncheckedUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUncheckedUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUncheckedUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUncheckedUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUncheckedUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUncheckedUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUncheckedUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
  }

  export type TaskUpsertWithoutAssignmentsInput = {
    update: XOR<TaskUpdateWithoutAssignmentsInput, TaskUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<TaskCreateWithoutAssignmentsInput, TaskUncheckedCreateWithoutAssignmentsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutAssignmentsInput, TaskUncheckedUpdateWithoutAssignmentsInput>
  }

  export type TaskUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    comments?: TaskCommentUpdateManyWithoutTaskNestedInput
    timeLogs?: TaskTimeLogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: TaskCommentUncheckedUpdateManyWithoutTaskNestedInput
    timeLogs?: TaskTimeLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskCreateWithoutCommentsInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.TaskPriority
    status?: $Enums.TaskStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutTasksCreatedInput
    assignments?: TaskAssignmentCreateNestedManyWithoutTaskInput
    timeLogs?: TaskTimeLogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutCommentsInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.TaskPriority
    status?: $Enums.TaskStatus
    dueDate?: Date | string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: TaskAssignmentUncheckedCreateNestedManyWithoutTaskInput
    timeLogs?: TaskTimeLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutCommentsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutCommentsInput, TaskUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutTaskCommentsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutReportsInput
    reports?: UserCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseCreateNestedManyWithoutApproverInput
    payrolls?: PayrollCreateNestedManyWithoutUserInput
    generatedPays?: PayrollCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostCreateNestedManyWithoutPostedByInput
    applications?: ApplicationCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
  }

  export type UserUncheckedCreateWithoutTaskCommentsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    departmentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: UserUncheckedCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveUncheckedCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseUncheckedCreateNestedManyWithoutApproverInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutUserInput
    generatedPays?: PayrollUncheckedCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewUncheckedCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetUncheckedCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostUncheckedCreateNestedManyWithoutPostedByInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventUncheckedCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeUncheckedCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentUncheckedCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
  }

  export type UserCreateOrConnectWithoutTaskCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTaskCommentsInput, UserUncheckedCreateWithoutTaskCommentsInput>
  }

  export type TaskUpsertWithoutCommentsInput = {
    update: XOR<TaskUpdateWithoutCommentsInput, TaskUncheckedUpdateWithoutCommentsInput>
    create: XOR<TaskCreateWithoutCommentsInput, TaskUncheckedCreateWithoutCommentsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutCommentsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutCommentsInput, TaskUncheckedUpdateWithoutCommentsInput>
  }

  export type TaskUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    assignments?: TaskAssignmentUpdateManyWithoutTaskNestedInput
    timeLogs?: TaskTimeLogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: TaskAssignmentUncheckedUpdateManyWithoutTaskNestedInput
    timeLogs?: TaskTimeLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type UserUpsertWithoutTaskCommentsInput = {
    update: XOR<UserUpdateWithoutTaskCommentsInput, UserUncheckedUpdateWithoutTaskCommentsInput>
    create: XOR<UserCreateWithoutTaskCommentsInput, UserUncheckedCreateWithoutTaskCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTaskCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTaskCommentsInput, UserUncheckedUpdateWithoutTaskCommentsInput>
  }

  export type UserUpdateWithoutTaskCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutReportsNestedInput
    reports?: UserUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
  }

  export type UserUncheckedUpdateWithoutTaskCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUncheckedUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUncheckedUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUncheckedUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUncheckedUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUncheckedUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUncheckedUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUncheckedUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
  }

  export type TaskCreateWithoutTimeLogsInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.TaskPriority
    status?: $Enums.TaskStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutTasksCreatedInput
    assignments?: TaskAssignmentCreateNestedManyWithoutTaskInput
    comments?: TaskCommentCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutTimeLogsInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.TaskPriority
    status?: $Enums.TaskStatus
    dueDate?: Date | string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: TaskAssignmentUncheckedCreateNestedManyWithoutTaskInput
    comments?: TaskCommentUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutTimeLogsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutTimeLogsInput, TaskUncheckedCreateWithoutTimeLogsInput>
  }

  export type UserCreateWithoutTimeLogsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutReportsInput
    reports?: UserCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseCreateNestedManyWithoutApproverInput
    payrolls?: PayrollCreateNestedManyWithoutUserInput
    generatedPays?: PayrollCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostCreateNestedManyWithoutPostedByInput
    applications?: ApplicationCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
  }

  export type UserUncheckedCreateWithoutTimeLogsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    departmentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: UserUncheckedCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveUncheckedCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseUncheckedCreateNestedManyWithoutApproverInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutUserInput
    generatedPays?: PayrollUncheckedCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewUncheckedCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetUncheckedCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostUncheckedCreateNestedManyWithoutPostedByInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventUncheckedCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeUncheckedCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentUncheckedCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
  }

  export type UserCreateOrConnectWithoutTimeLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTimeLogsInput, UserUncheckedCreateWithoutTimeLogsInput>
  }

  export type TaskUpsertWithoutTimeLogsInput = {
    update: XOR<TaskUpdateWithoutTimeLogsInput, TaskUncheckedUpdateWithoutTimeLogsInput>
    create: XOR<TaskCreateWithoutTimeLogsInput, TaskUncheckedCreateWithoutTimeLogsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutTimeLogsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutTimeLogsInput, TaskUncheckedUpdateWithoutTimeLogsInput>
  }

  export type TaskUpdateWithoutTimeLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    assignments?: TaskAssignmentUpdateManyWithoutTaskNestedInput
    comments?: TaskCommentUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutTimeLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: TaskAssignmentUncheckedUpdateManyWithoutTaskNestedInput
    comments?: TaskCommentUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type UserUpsertWithoutTimeLogsInput = {
    update: XOR<UserUpdateWithoutTimeLogsInput, UserUncheckedUpdateWithoutTimeLogsInput>
    create: XOR<UserCreateWithoutTimeLogsInput, UserUncheckedCreateWithoutTimeLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTimeLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTimeLogsInput, UserUncheckedUpdateWithoutTimeLogsInput>
  }

  export type UserUpdateWithoutTimeLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutReportsNestedInput
    reports?: UserUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
  }

  export type UserUncheckedUpdateWithoutTimeLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUncheckedUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUncheckedUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUncheckedUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUncheckedUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUncheckedUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUncheckedUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUncheckedUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
  }

  export type UserCreateWithoutAttendanceInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutReportsInput
    reports?: UserCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseCreateNestedManyWithoutApproverInput
    payrolls?: PayrollCreateNestedManyWithoutUserInput
    generatedPays?: PayrollCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostCreateNestedManyWithoutPostedByInput
    applications?: ApplicationCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
  }

  export type UserUncheckedCreateWithoutAttendanceInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    departmentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: UserUncheckedCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveUncheckedCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseUncheckedCreateNestedManyWithoutApproverInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutUserInput
    generatedPays?: PayrollUncheckedCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewUncheckedCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetUncheckedCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostUncheckedCreateNestedManyWithoutPostedByInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventUncheckedCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeUncheckedCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentUncheckedCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
  }

  export type UserCreateOrConnectWithoutAttendanceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAttendanceInput, UserUncheckedCreateWithoutAttendanceInput>
  }

  export type UserUpsertWithoutAttendanceInput = {
    update: XOR<UserUpdateWithoutAttendanceInput, UserUncheckedUpdateWithoutAttendanceInput>
    create: XOR<UserCreateWithoutAttendanceInput, UserUncheckedCreateWithoutAttendanceInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAttendanceInput, UserUncheckedUpdateWithoutAttendanceInput>
  }

  export type UserUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutReportsNestedInput
    reports?: UserUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
  }

  export type UserUncheckedUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUncheckedUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUncheckedUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUncheckedUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUncheckedUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUncheckedUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUncheckedUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUncheckedUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
  }

  export type UserCreateWithoutLeavesInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutReportsInput
    reports?: UserCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseCreateNestedManyWithoutApproverInput
    payrolls?: PayrollCreateNestedManyWithoutUserInput
    generatedPays?: PayrollCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostCreateNestedManyWithoutPostedByInput
    applications?: ApplicationCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
  }

  export type UserUncheckedCreateWithoutLeavesInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    departmentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: UserUncheckedCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveUncheckedCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseUncheckedCreateNestedManyWithoutApproverInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutUserInput
    generatedPays?: PayrollUncheckedCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewUncheckedCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetUncheckedCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostUncheckedCreateNestedManyWithoutPostedByInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventUncheckedCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeUncheckedCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentUncheckedCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
  }

  export type UserCreateOrConnectWithoutLeavesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLeavesInput, UserUncheckedCreateWithoutLeavesInput>
  }

  export type UserCreateWithoutLeavesToApproveInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutReportsInput
    reports?: UserCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseCreateNestedManyWithoutApproverInput
    payrolls?: PayrollCreateNestedManyWithoutUserInput
    generatedPays?: PayrollCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostCreateNestedManyWithoutPostedByInput
    applications?: ApplicationCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
  }

  export type UserUncheckedCreateWithoutLeavesToApproveInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    departmentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: UserUncheckedCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseUncheckedCreateNestedManyWithoutApproverInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutUserInput
    generatedPays?: PayrollUncheckedCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewUncheckedCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetUncheckedCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostUncheckedCreateNestedManyWithoutPostedByInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventUncheckedCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeUncheckedCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentUncheckedCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
  }

  export type UserCreateOrConnectWithoutLeavesToApproveInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLeavesToApproveInput, UserUncheckedCreateWithoutLeavesToApproveInput>
  }

  export type UserUpsertWithoutLeavesInput = {
    update: XOR<UserUpdateWithoutLeavesInput, UserUncheckedUpdateWithoutLeavesInput>
    create: XOR<UserCreateWithoutLeavesInput, UserUncheckedCreateWithoutLeavesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLeavesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLeavesInput, UserUncheckedUpdateWithoutLeavesInput>
  }

  export type UserUpdateWithoutLeavesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutReportsNestedInput
    reports?: UserUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
  }

  export type UserUncheckedUpdateWithoutLeavesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUncheckedUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUncheckedUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUncheckedUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUncheckedUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUncheckedUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUncheckedUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUncheckedUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
  }

  export type UserUpsertWithoutLeavesToApproveInput = {
    update: XOR<UserUpdateWithoutLeavesToApproveInput, UserUncheckedUpdateWithoutLeavesToApproveInput>
    create: XOR<UserCreateWithoutLeavesToApproveInput, UserUncheckedCreateWithoutLeavesToApproveInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLeavesToApproveInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLeavesToApproveInput, UserUncheckedUpdateWithoutLeavesToApproveInput>
  }

  export type UserUpdateWithoutLeavesToApproveInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutReportsNestedInput
    reports?: UserUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
  }

  export type UserUncheckedUpdateWithoutLeavesToApproveInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUncheckedUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUncheckedUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUncheckedUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUncheckedUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUncheckedUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUncheckedUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
  }

  export type UserCreateWithoutMessagesSentInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutReportsInput
    reports?: UserCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveCreateNestedManyWithoutApproverInput
    messagesRecv?: ChatMessageCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseCreateNestedManyWithoutApproverInput
    payrolls?: PayrollCreateNestedManyWithoutUserInput
    generatedPays?: PayrollCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostCreateNestedManyWithoutPostedByInput
    applications?: ApplicationCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
  }

  export type UserUncheckedCreateWithoutMessagesSentInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    departmentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: UserUncheckedCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveUncheckedCreateNestedManyWithoutApproverInput
    messagesRecv?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseUncheckedCreateNestedManyWithoutApproverInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutUserInput
    generatedPays?: PayrollUncheckedCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewUncheckedCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetUncheckedCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostUncheckedCreateNestedManyWithoutPostedByInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventUncheckedCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeUncheckedCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentUncheckedCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
  }

  export type UserCreateOrConnectWithoutMessagesSentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesSentInput, UserUncheckedCreateWithoutMessagesSentInput>
  }

  export type UserCreateWithoutMessagesRecvInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutReportsInput
    reports?: UserCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    chatGroups?: ChatGroupMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseCreateNestedManyWithoutApproverInput
    payrolls?: PayrollCreateNestedManyWithoutUserInput
    generatedPays?: PayrollCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostCreateNestedManyWithoutPostedByInput
    applications?: ApplicationCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
  }

  export type UserUncheckedCreateWithoutMessagesRecvInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    departmentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: UserUncheckedCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveUncheckedCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    chatGroups?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseUncheckedCreateNestedManyWithoutApproverInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutUserInput
    generatedPays?: PayrollUncheckedCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewUncheckedCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetUncheckedCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostUncheckedCreateNestedManyWithoutPostedByInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventUncheckedCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeUncheckedCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentUncheckedCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
  }

  export type UserCreateOrConnectWithoutMessagesRecvInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesRecvInput, UserUncheckedCreateWithoutMessagesRecvInput>
  }

  export type ChatGroupCreateWithoutMessagesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    members?: ChatGroupMemberCreateNestedManyWithoutGroupInput
  }

  export type ChatGroupUncheckedCreateWithoutMessagesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    members?: ChatGroupMemberUncheckedCreateNestedManyWithoutGroupInput
  }

  export type ChatGroupCreateOrConnectWithoutMessagesInput = {
    where: ChatGroupWhereUniqueInput
    create: XOR<ChatGroupCreateWithoutMessagesInput, ChatGroupUncheckedCreateWithoutMessagesInput>
  }

  export type UserUpsertWithoutMessagesSentInput = {
    update: XOR<UserUpdateWithoutMessagesSentInput, UserUncheckedUpdateWithoutMessagesSentInput>
    create: XOR<UserCreateWithoutMessagesSentInput, UserUncheckedCreateWithoutMessagesSentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessagesSentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessagesSentInput, UserUncheckedUpdateWithoutMessagesSentInput>
  }

  export type UserUpdateWithoutMessagesSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutReportsNestedInput
    reports?: UserUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUpdateManyWithoutApproverNestedInput
    messagesRecv?: ChatMessageUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUncheckedUpdateManyWithoutApproverNestedInput
    messagesRecv?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUncheckedUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUncheckedUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUncheckedUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUncheckedUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUncheckedUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUncheckedUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
  }

  export type UserUpsertWithoutMessagesRecvInput = {
    update: XOR<UserUpdateWithoutMessagesRecvInput, UserUncheckedUpdateWithoutMessagesRecvInput>
    create: XOR<UserCreateWithoutMessagesRecvInput, UserUncheckedCreateWithoutMessagesRecvInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessagesRecvInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessagesRecvInput, UserUncheckedUpdateWithoutMessagesRecvInput>
  }

  export type UserUpdateWithoutMessagesRecvInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutReportsNestedInput
    reports?: UserUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    chatGroups?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesRecvInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUncheckedUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    chatGroups?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUncheckedUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUncheckedUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUncheckedUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUncheckedUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUncheckedUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUncheckedUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
  }

  export type ChatGroupUpsertWithoutMessagesInput = {
    update: XOR<ChatGroupUpdateWithoutMessagesInput, ChatGroupUncheckedUpdateWithoutMessagesInput>
    create: XOR<ChatGroupCreateWithoutMessagesInput, ChatGroupUncheckedCreateWithoutMessagesInput>
    where?: ChatGroupWhereInput
  }

  export type ChatGroupUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ChatGroupWhereInput
    data: XOR<ChatGroupUpdateWithoutMessagesInput, ChatGroupUncheckedUpdateWithoutMessagesInput>
  }

  export type ChatGroupUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ChatGroupMemberUpdateManyWithoutGroupNestedInput
  }

  export type ChatGroupUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ChatGroupMemberUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type ChatMessageCreateWithoutGroupInput = {
    id?: string
    content: string
    timestamp?: Date | string
    sender: UserCreateNestedOneWithoutMessagesSentInput
    receiver?: UserCreateNestedOneWithoutMessagesRecvInput
  }

  export type ChatMessageUncheckedCreateWithoutGroupInput = {
    id?: string
    senderId: string
    receiverId?: string | null
    content: string
    timestamp?: Date | string
  }

  export type ChatMessageCreateOrConnectWithoutGroupInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutGroupInput, ChatMessageUncheckedCreateWithoutGroupInput>
  }

  export type ChatMessageCreateManyGroupInputEnvelope = {
    data: ChatMessageCreateManyGroupInput | ChatMessageCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type ChatGroupMemberCreateWithoutGroupInput = {
    id?: string
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutChatGroupsInput
  }

  export type ChatGroupMemberUncheckedCreateWithoutGroupInput = {
    id?: string
    userId: string
    joinedAt?: Date | string
  }

  export type ChatGroupMemberCreateOrConnectWithoutGroupInput = {
    where: ChatGroupMemberWhereUniqueInput
    create: XOR<ChatGroupMemberCreateWithoutGroupInput, ChatGroupMemberUncheckedCreateWithoutGroupInput>
  }

  export type ChatGroupMemberCreateManyGroupInputEnvelope = {
    data: ChatGroupMemberCreateManyGroupInput | ChatGroupMemberCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutGroupInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutGroupInput, ChatMessageUncheckedUpdateWithoutGroupInput>
    create: XOR<ChatMessageCreateWithoutGroupInput, ChatMessageUncheckedCreateWithoutGroupInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutGroupInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutGroupInput, ChatMessageUncheckedUpdateWithoutGroupInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutGroupInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutGroupInput>
  }

  export type ChatGroupMemberUpsertWithWhereUniqueWithoutGroupInput = {
    where: ChatGroupMemberWhereUniqueInput
    update: XOR<ChatGroupMemberUpdateWithoutGroupInput, ChatGroupMemberUncheckedUpdateWithoutGroupInput>
    create: XOR<ChatGroupMemberCreateWithoutGroupInput, ChatGroupMemberUncheckedCreateWithoutGroupInput>
  }

  export type ChatGroupMemberUpdateWithWhereUniqueWithoutGroupInput = {
    where: ChatGroupMemberWhereUniqueInput
    data: XOR<ChatGroupMemberUpdateWithoutGroupInput, ChatGroupMemberUncheckedUpdateWithoutGroupInput>
  }

  export type ChatGroupMemberUpdateManyWithWhereWithoutGroupInput = {
    where: ChatGroupMemberScalarWhereInput
    data: XOR<ChatGroupMemberUpdateManyMutationInput, ChatGroupMemberUncheckedUpdateManyWithoutGroupInput>
  }

  export type ChatGroupCreateWithoutMembersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    messages?: ChatMessageCreateNestedManyWithoutGroupInput
  }

  export type ChatGroupUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    messages?: ChatMessageUncheckedCreateNestedManyWithoutGroupInput
  }

  export type ChatGroupCreateOrConnectWithoutMembersInput = {
    where: ChatGroupWhereUniqueInput
    create: XOR<ChatGroupCreateWithoutMembersInput, ChatGroupUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutChatGroupsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutReportsInput
    reports?: UserCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageCreateNestedManyWithoutReceiverInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseCreateNestedManyWithoutApproverInput
    payrolls?: PayrollCreateNestedManyWithoutUserInput
    generatedPays?: PayrollCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostCreateNestedManyWithoutPostedByInput
    applications?: ApplicationCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
  }

  export type UserUncheckedCreateWithoutChatGroupsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    departmentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: UserUncheckedCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveUncheckedCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseUncheckedCreateNestedManyWithoutApproverInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutUserInput
    generatedPays?: PayrollUncheckedCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewUncheckedCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetUncheckedCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostUncheckedCreateNestedManyWithoutPostedByInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventUncheckedCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeUncheckedCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentUncheckedCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
  }

  export type UserCreateOrConnectWithoutChatGroupsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChatGroupsInput, UserUncheckedCreateWithoutChatGroupsInput>
  }

  export type ChatGroupUpsertWithoutMembersInput = {
    update: XOR<ChatGroupUpdateWithoutMembersInput, ChatGroupUncheckedUpdateWithoutMembersInput>
    create: XOR<ChatGroupCreateWithoutMembersInput, ChatGroupUncheckedCreateWithoutMembersInput>
    where?: ChatGroupWhereInput
  }

  export type ChatGroupUpdateToOneWithWhereWithoutMembersInput = {
    where?: ChatGroupWhereInput
    data: XOR<ChatGroupUpdateWithoutMembersInput, ChatGroupUncheckedUpdateWithoutMembersInput>
  }

  export type ChatGroupUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ChatMessageUpdateManyWithoutGroupNestedInput
  }

  export type ChatGroupUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ChatMessageUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type UserUpsertWithoutChatGroupsInput = {
    update: XOR<UserUpdateWithoutChatGroupsInput, UserUncheckedUpdateWithoutChatGroupsInput>
    create: XOR<UserCreateWithoutChatGroupsInput, UserUncheckedCreateWithoutChatGroupsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChatGroupsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChatGroupsInput, UserUncheckedUpdateWithoutChatGroupsInput>
  }

  export type UserUpdateWithoutChatGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutReportsNestedInput
    reports?: UserUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUpdateManyWithoutReceiverNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
  }

  export type UserUncheckedUpdateWithoutChatGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUncheckedUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUncheckedUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUncheckedUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUncheckedUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUncheckedUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUncheckedUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUncheckedUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
  }

  export type UserCreateWithoutAnnouncementsMadeInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutReportsInput
    reports?: UserCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseCreateNestedManyWithoutApproverInput
    payrolls?: PayrollCreateNestedManyWithoutUserInput
    generatedPays?: PayrollCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostCreateNestedManyWithoutPostedByInput
    applications?: ApplicationCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
  }

  export type UserUncheckedCreateWithoutAnnouncementsMadeInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    departmentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: UserUncheckedCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveUncheckedCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseUncheckedCreateNestedManyWithoutApproverInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutUserInput
    generatedPays?: PayrollUncheckedCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewUncheckedCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetUncheckedCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostUncheckedCreateNestedManyWithoutPostedByInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventUncheckedCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeUncheckedCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
  }

  export type UserCreateOrConnectWithoutAnnouncementsMadeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAnnouncementsMadeInput, UserUncheckedCreateWithoutAnnouncementsMadeInput>
  }

  export type DepartmentCreateWithoutAnnouncementInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    head?: UserCreateNestedOneWithoutHeadedDepartmentsInput
    users?: UserCreateNestedManyWithoutDepartmentInput
    JobPost?: JobPostCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutAnnouncementInput = {
    id?: string
    name: string
    description?: string | null
    headId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutDepartmentInput
    JobPost?: JobPostUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutAnnouncementInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutAnnouncementInput, DepartmentUncheckedCreateWithoutAnnouncementInput>
  }

  export type UserUpsertWithoutAnnouncementsMadeInput = {
    update: XOR<UserUpdateWithoutAnnouncementsMadeInput, UserUncheckedUpdateWithoutAnnouncementsMadeInput>
    create: XOR<UserCreateWithoutAnnouncementsMadeInput, UserUncheckedCreateWithoutAnnouncementsMadeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAnnouncementsMadeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAnnouncementsMadeInput, UserUncheckedUpdateWithoutAnnouncementsMadeInput>
  }

  export type UserUpdateWithoutAnnouncementsMadeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutReportsNestedInput
    reports?: UserUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
  }

  export type UserUncheckedUpdateWithoutAnnouncementsMadeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUncheckedUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUncheckedUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUncheckedUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUncheckedUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUncheckedUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUncheckedUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUncheckedUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
  }

  export type DepartmentUpsertWithoutAnnouncementInput = {
    update: XOR<DepartmentUpdateWithoutAnnouncementInput, DepartmentUncheckedUpdateWithoutAnnouncementInput>
    create: XOR<DepartmentCreateWithoutAnnouncementInput, DepartmentUncheckedCreateWithoutAnnouncementInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutAnnouncementInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutAnnouncementInput, DepartmentUncheckedUpdateWithoutAnnouncementInput>
  }

  export type DepartmentUpdateWithoutAnnouncementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    head?: UserUpdateOneWithoutHeadedDepartmentsNestedInput
    users?: UserUpdateManyWithoutDepartmentNestedInput
    JobPost?: JobPostUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutAnnouncementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    headId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutDepartmentNestedInput
    JobPost?: JobPostUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutReportsInput
    reports?: UserCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseCreateNestedManyWithoutApproverInput
    payrolls?: PayrollCreateNestedManyWithoutUserInput
    generatedPays?: PayrollCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostCreateNestedManyWithoutPostedByInput
    applications?: ApplicationCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    departmentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: UserUncheckedCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveUncheckedCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseUncheckedCreateNestedManyWithoutApproverInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutUserInput
    generatedPays?: PayrollUncheckedCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewUncheckedCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetUncheckedCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostUncheckedCreateNestedManyWithoutPostedByInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventUncheckedCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeUncheckedCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentUncheckedCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutReportsNestedInput
    reports?: UserUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUncheckedUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUncheckedUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUncheckedUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUncheckedUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUncheckedUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUncheckedUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUncheckedUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
  }

  export type UserCreateWithoutDocumentsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutReportsInput
    reports?: UserCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseCreateNestedManyWithoutApproverInput
    payrolls?: PayrollCreateNestedManyWithoutUserInput
    generatedPays?: PayrollCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostCreateNestedManyWithoutPostedByInput
    applications?: ApplicationCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
  }

  export type UserUncheckedCreateWithoutDocumentsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    departmentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: UserUncheckedCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveUncheckedCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseUncheckedCreateNestedManyWithoutApproverInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutUserInput
    generatedPays?: PayrollUncheckedCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewUncheckedCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetUncheckedCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostUncheckedCreateNestedManyWithoutPostedByInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventUncheckedCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeUncheckedCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentUncheckedCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
  }

  export type UserCreateOrConnectWithoutDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
  }

  export type UserUpsertWithoutDocumentsInput = {
    update: XOR<UserUpdateWithoutDocumentsInput, UserUncheckedUpdateWithoutDocumentsInput>
    create: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDocumentsInput, UserUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutReportsNestedInput
    reports?: UserUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
  }

  export type UserUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUncheckedUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUncheckedUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUncheckedUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUncheckedUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUncheckedUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUncheckedUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUncheckedUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
  }

  export type UserCreateWithoutCompanyDocsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutReportsInput
    reports?: UserCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    expenses?: ExpenseCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseCreateNestedManyWithoutApproverInput
    payrolls?: PayrollCreateNestedManyWithoutUserInput
    generatedPays?: PayrollCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostCreateNestedManyWithoutPostedByInput
    applications?: ApplicationCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
  }

  export type UserUncheckedCreateWithoutCompanyDocsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    departmentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: UserUncheckedCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveUncheckedCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseUncheckedCreateNestedManyWithoutApproverInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutUserInput
    generatedPays?: PayrollUncheckedCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewUncheckedCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetUncheckedCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostUncheckedCreateNestedManyWithoutPostedByInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventUncheckedCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeUncheckedCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentUncheckedCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
  }

  export type UserCreateOrConnectWithoutCompanyDocsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompanyDocsInput, UserUncheckedCreateWithoutCompanyDocsInput>
  }

  export type UserUpsertWithoutCompanyDocsInput = {
    update: XOR<UserUpdateWithoutCompanyDocsInput, UserUncheckedUpdateWithoutCompanyDocsInput>
    create: XOR<UserCreateWithoutCompanyDocsInput, UserUncheckedCreateWithoutCompanyDocsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCompanyDocsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCompanyDocsInput, UserUncheckedUpdateWithoutCompanyDocsInput>
  }

  export type UserUpdateWithoutCompanyDocsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutReportsNestedInput
    reports?: UserUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    expenses?: ExpenseUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
  }

  export type UserUncheckedUpdateWithoutCompanyDocsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUncheckedUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUncheckedUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUncheckedUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUncheckedUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUncheckedUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUncheckedUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUncheckedUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
  }

  export type UserCreateWithoutExpensesInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutReportsInput
    reports?: UserCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    expensesApproved?: ExpenseCreateNestedManyWithoutApproverInput
    payrolls?: PayrollCreateNestedManyWithoutUserInput
    generatedPays?: PayrollCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostCreateNestedManyWithoutPostedByInput
    applications?: ApplicationCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
  }

  export type UserUncheckedCreateWithoutExpensesInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    departmentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: UserUncheckedCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveUncheckedCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    expensesApproved?: ExpenseUncheckedCreateNestedManyWithoutApproverInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutUserInput
    generatedPays?: PayrollUncheckedCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewUncheckedCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetUncheckedCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostUncheckedCreateNestedManyWithoutPostedByInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventUncheckedCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeUncheckedCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentUncheckedCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
  }

  export type UserCreateOrConnectWithoutExpensesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExpensesInput, UserUncheckedCreateWithoutExpensesInput>
  }

  export type UserCreateWithoutExpensesApprovedInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutReportsInput
    reports?: UserCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseCreateNestedManyWithoutOwnerInput
    payrolls?: PayrollCreateNestedManyWithoutUserInput
    generatedPays?: PayrollCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostCreateNestedManyWithoutPostedByInput
    applications?: ApplicationCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
  }

  export type UserUncheckedCreateWithoutExpensesApprovedInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    departmentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: UserUncheckedCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveUncheckedCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutOwnerInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutUserInput
    generatedPays?: PayrollUncheckedCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewUncheckedCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetUncheckedCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostUncheckedCreateNestedManyWithoutPostedByInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventUncheckedCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeUncheckedCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentUncheckedCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
  }

  export type UserCreateOrConnectWithoutExpensesApprovedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExpensesApprovedInput, UserUncheckedCreateWithoutExpensesApprovedInput>
  }

  export type UserUpsertWithoutExpensesInput = {
    update: XOR<UserUpdateWithoutExpensesInput, UserUncheckedUpdateWithoutExpensesInput>
    create: XOR<UserCreateWithoutExpensesInput, UserUncheckedCreateWithoutExpensesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExpensesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExpensesInput, UserUncheckedUpdateWithoutExpensesInput>
  }

  export type UserUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutReportsNestedInput
    reports?: UserUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    expensesApproved?: ExpenseUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
  }

  export type UserUncheckedUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUncheckedUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    expensesApproved?: ExpenseUncheckedUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUncheckedUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUncheckedUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUncheckedUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUncheckedUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUncheckedUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
  }

  export type UserUpsertWithoutExpensesApprovedInput = {
    update: XOR<UserUpdateWithoutExpensesApprovedInput, UserUncheckedUpdateWithoutExpensesApprovedInput>
    create: XOR<UserCreateWithoutExpensesApprovedInput, UserUncheckedCreateWithoutExpensesApprovedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExpensesApprovedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExpensesApprovedInput, UserUncheckedUpdateWithoutExpensesApprovedInput>
  }

  export type UserUpdateWithoutExpensesApprovedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutReportsNestedInput
    reports?: UserUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUpdateManyWithoutOwnerNestedInput
    payrolls?: PayrollUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
  }

  export type UserUncheckedUpdateWithoutExpensesApprovedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUncheckedUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutOwnerNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUncheckedUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUncheckedUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUncheckedUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUncheckedUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUncheckedUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
  }

  export type UserCreateWithoutAssetsOwnedInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutReportsInput
    reports?: UserCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseCreateNestedManyWithoutApproverInput
    payrolls?: PayrollCreateNestedManyWithoutUserInput
    generatedPays?: PayrollCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewCreateNestedManyWithoutRevieweeInput
    jobPosts?: JobPostCreateNestedManyWithoutPostedByInput
    applications?: ApplicationCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
  }

  export type UserUncheckedCreateWithoutAssetsOwnedInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    departmentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: UserUncheckedCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveUncheckedCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseUncheckedCreateNestedManyWithoutApproverInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutUserInput
    generatedPays?: PayrollUncheckedCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewUncheckedCreateNestedManyWithoutRevieweeInput
    jobPosts?: JobPostUncheckedCreateNestedManyWithoutPostedByInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventUncheckedCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeUncheckedCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentUncheckedCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
  }

  export type UserCreateOrConnectWithoutAssetsOwnedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssetsOwnedInput, UserUncheckedCreateWithoutAssetsOwnedInput>
  }

  export type UserUpsertWithoutAssetsOwnedInput = {
    update: XOR<UserUpdateWithoutAssetsOwnedInput, UserUncheckedUpdateWithoutAssetsOwnedInput>
    create: XOR<UserCreateWithoutAssetsOwnedInput, UserUncheckedCreateWithoutAssetsOwnedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssetsOwnedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssetsOwnedInput, UserUncheckedUpdateWithoutAssetsOwnedInput>
  }

  export type UserUpdateWithoutAssetsOwnedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutReportsNestedInput
    reports?: UserUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUpdateManyWithoutRevieweeNestedInput
    jobPosts?: JobPostUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
  }

  export type UserUncheckedUpdateWithoutAssetsOwnedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUncheckedUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUncheckedUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUncheckedUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    jobPosts?: JobPostUncheckedUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUncheckedUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUncheckedUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
  }

  export type UserCreateWithoutPayrollsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutReportsInput
    reports?: UserCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseCreateNestedManyWithoutApproverInput
    generatedPays?: PayrollCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostCreateNestedManyWithoutPostedByInput
    applications?: ApplicationCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
  }

  export type UserUncheckedCreateWithoutPayrollsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    departmentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: UserUncheckedCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveUncheckedCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseUncheckedCreateNestedManyWithoutApproverInput
    generatedPays?: PayrollUncheckedCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewUncheckedCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetUncheckedCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostUncheckedCreateNestedManyWithoutPostedByInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventUncheckedCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeUncheckedCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentUncheckedCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
  }

  export type UserCreateOrConnectWithoutPayrollsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPayrollsInput, UserUncheckedCreateWithoutPayrollsInput>
  }

  export type UserCreateWithoutGeneratedPaysInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutReportsInput
    reports?: UserCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseCreateNestedManyWithoutApproverInput
    payrolls?: PayrollCreateNestedManyWithoutUserInput
    performanceReviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostCreateNestedManyWithoutPostedByInput
    applications?: ApplicationCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
  }

  export type UserUncheckedCreateWithoutGeneratedPaysInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    departmentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: UserUncheckedCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveUncheckedCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseUncheckedCreateNestedManyWithoutApproverInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutUserInput
    performanceReviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewUncheckedCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetUncheckedCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostUncheckedCreateNestedManyWithoutPostedByInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventUncheckedCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeUncheckedCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentUncheckedCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
  }

  export type UserCreateOrConnectWithoutGeneratedPaysInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGeneratedPaysInput, UserUncheckedCreateWithoutGeneratedPaysInput>
  }

  export type UserUpsertWithoutPayrollsInput = {
    update: XOR<UserUpdateWithoutPayrollsInput, UserUncheckedUpdateWithoutPayrollsInput>
    create: XOR<UserCreateWithoutPayrollsInput, UserUncheckedCreateWithoutPayrollsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPayrollsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPayrollsInput, UserUncheckedUpdateWithoutPayrollsInput>
  }

  export type UserUpdateWithoutPayrollsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutReportsNestedInput
    reports?: UserUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUpdateManyWithoutApproverNestedInput
    generatedPays?: PayrollUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
  }

  export type UserUncheckedUpdateWithoutPayrollsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUncheckedUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUncheckedUpdateManyWithoutApproverNestedInput
    generatedPays?: PayrollUncheckedUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUncheckedUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUncheckedUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUncheckedUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUncheckedUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
  }

  export type UserUpsertWithoutGeneratedPaysInput = {
    update: XOR<UserUpdateWithoutGeneratedPaysInput, UserUncheckedUpdateWithoutGeneratedPaysInput>
    create: XOR<UserCreateWithoutGeneratedPaysInput, UserUncheckedCreateWithoutGeneratedPaysInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGeneratedPaysInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGeneratedPaysInput, UserUncheckedUpdateWithoutGeneratedPaysInput>
  }

  export type UserUpdateWithoutGeneratedPaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutReportsNestedInput
    reports?: UserUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUpdateManyWithoutUserNestedInput
    performanceReviewsGiven?: PerformanceReviewUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
  }

  export type UserUncheckedUpdateWithoutGeneratedPaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUncheckedUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUncheckedUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    performanceReviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUncheckedUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUncheckedUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUncheckedUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUncheckedUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
  }

  export type UserCreateWithoutPerformanceReviewsGotInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutReportsInput
    reports?: UserCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseCreateNestedManyWithoutApproverInput
    payrolls?: PayrollCreateNestedManyWithoutUserInput
    generatedPays?: PayrollCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewerInput
    assetsOwned?: AssetCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostCreateNestedManyWithoutPostedByInput
    applications?: ApplicationCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
  }

  export type UserUncheckedCreateWithoutPerformanceReviewsGotInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    departmentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: UserUncheckedCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveUncheckedCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseUncheckedCreateNestedManyWithoutApproverInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutUserInput
    generatedPays?: PayrollUncheckedCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewerInput
    assetsOwned?: AssetUncheckedCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostUncheckedCreateNestedManyWithoutPostedByInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventUncheckedCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeUncheckedCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentUncheckedCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
  }

  export type UserCreateOrConnectWithoutPerformanceReviewsGotInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPerformanceReviewsGotInput, UserUncheckedCreateWithoutPerformanceReviewsGotInput>
  }

  export type UserCreateWithoutPerformanceReviewsGivenInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutReportsInput
    reports?: UserCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseCreateNestedManyWithoutApproverInput
    payrolls?: PayrollCreateNestedManyWithoutUserInput
    generatedPays?: PayrollCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGot?: PerformanceReviewCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostCreateNestedManyWithoutPostedByInput
    applications?: ApplicationCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
  }

  export type UserUncheckedCreateWithoutPerformanceReviewsGivenInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    departmentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: UserUncheckedCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveUncheckedCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseUncheckedCreateNestedManyWithoutApproverInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutUserInput
    generatedPays?: PayrollUncheckedCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGot?: PerformanceReviewUncheckedCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetUncheckedCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostUncheckedCreateNestedManyWithoutPostedByInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventUncheckedCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeUncheckedCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentUncheckedCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
  }

  export type UserCreateOrConnectWithoutPerformanceReviewsGivenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPerformanceReviewsGivenInput, UserUncheckedCreateWithoutPerformanceReviewsGivenInput>
  }

  export type UserUpsertWithoutPerformanceReviewsGotInput = {
    update: XOR<UserUpdateWithoutPerformanceReviewsGotInput, UserUncheckedUpdateWithoutPerformanceReviewsGotInput>
    create: XOR<UserCreateWithoutPerformanceReviewsGotInput, UserUncheckedCreateWithoutPerformanceReviewsGotInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPerformanceReviewsGotInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPerformanceReviewsGotInput, UserUncheckedUpdateWithoutPerformanceReviewsGotInput>
  }

  export type UserUpdateWithoutPerformanceReviewsGotInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutReportsNestedInput
    reports?: UserUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUpdateManyWithoutReviewerNestedInput
    assetsOwned?: AssetUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
  }

  export type UserUncheckedUpdateWithoutPerformanceReviewsGotInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUncheckedUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUncheckedUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUncheckedUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewerNestedInput
    assetsOwned?: AssetUncheckedUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUncheckedUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUncheckedUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUncheckedUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
  }

  export type UserUpsertWithoutPerformanceReviewsGivenInput = {
    update: XOR<UserUpdateWithoutPerformanceReviewsGivenInput, UserUncheckedUpdateWithoutPerformanceReviewsGivenInput>
    create: XOR<UserCreateWithoutPerformanceReviewsGivenInput, UserUncheckedCreateWithoutPerformanceReviewsGivenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPerformanceReviewsGivenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPerformanceReviewsGivenInput, UserUncheckedUpdateWithoutPerformanceReviewsGivenInput>
  }

  export type UserUpdateWithoutPerformanceReviewsGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutReportsNestedInput
    reports?: UserUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGot?: PerformanceReviewUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
  }

  export type UserUncheckedUpdateWithoutPerformanceReviewsGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUncheckedUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUncheckedUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUncheckedUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGot?: PerformanceReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUncheckedUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUncheckedUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUncheckedUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUncheckedUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
  }

  export type DepartmentCreateWithoutJobPostInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    head?: UserCreateNestedOneWithoutHeadedDepartmentsInput
    users?: UserCreateNestedManyWithoutDepartmentInput
    Announcement?: AnnouncementCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutJobPostInput = {
    id?: string
    name: string
    description?: string | null
    headId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutDepartmentInput
    Announcement?: AnnouncementUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutJobPostInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutJobPostInput, DepartmentUncheckedCreateWithoutJobPostInput>
  }

  export type UserCreateWithoutJobPostsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutReportsInput
    reports?: UserCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseCreateNestedManyWithoutApproverInput
    payrolls?: PayrollCreateNestedManyWithoutUserInput
    generatedPays?: PayrollCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetCreateNestedManyWithoutAssignedToInput
    applications?: ApplicationCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
  }

  export type UserUncheckedCreateWithoutJobPostsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    departmentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: UserUncheckedCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveUncheckedCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseUncheckedCreateNestedManyWithoutApproverInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutUserInput
    generatedPays?: PayrollUncheckedCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewUncheckedCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetUncheckedCreateNestedManyWithoutAssignedToInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventUncheckedCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeUncheckedCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentUncheckedCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
  }

  export type UserCreateOrConnectWithoutJobPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutJobPostsInput, UserUncheckedCreateWithoutJobPostsInput>
  }

  export type ApplicationCreateWithoutJobPostInput = {
    id?: string
    applicantName: string
    applicantEmail: string
    resumeUrl?: string | null
    coverLetter?: string | null
    status?: $Enums.ApplicationStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    applicant?: UserCreateNestedOneWithoutApplicationsInput
  }

  export type ApplicationUncheckedCreateWithoutJobPostInput = {
    id?: string
    applicantUserId?: string | null
    applicantName: string
    applicantEmail: string
    resumeUrl?: string | null
    coverLetter?: string | null
    status?: $Enums.ApplicationStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApplicationCreateOrConnectWithoutJobPostInput = {
    where: ApplicationWhereUniqueInput
    create: XOR<ApplicationCreateWithoutJobPostInput, ApplicationUncheckedCreateWithoutJobPostInput>
  }

  export type ApplicationCreateManyJobPostInputEnvelope = {
    data: ApplicationCreateManyJobPostInput | ApplicationCreateManyJobPostInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentUpsertWithoutJobPostInput = {
    update: XOR<DepartmentUpdateWithoutJobPostInput, DepartmentUncheckedUpdateWithoutJobPostInput>
    create: XOR<DepartmentCreateWithoutJobPostInput, DepartmentUncheckedCreateWithoutJobPostInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutJobPostInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutJobPostInput, DepartmentUncheckedUpdateWithoutJobPostInput>
  }

  export type DepartmentUpdateWithoutJobPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    head?: UserUpdateOneWithoutHeadedDepartmentsNestedInput
    users?: UserUpdateManyWithoutDepartmentNestedInput
    Announcement?: AnnouncementUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutJobPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    headId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutDepartmentNestedInput
    Announcement?: AnnouncementUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type UserUpsertWithoutJobPostsInput = {
    update: XOR<UserUpdateWithoutJobPostsInput, UserUncheckedUpdateWithoutJobPostsInput>
    create: XOR<UserCreateWithoutJobPostsInput, UserUncheckedCreateWithoutJobPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutJobPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutJobPostsInput, UserUncheckedUpdateWithoutJobPostsInput>
  }

  export type UserUpdateWithoutJobPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutReportsNestedInput
    reports?: UserUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUpdateManyWithoutAssignedToNestedInput
    applications?: ApplicationUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
  }

  export type UserUncheckedUpdateWithoutJobPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUncheckedUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUncheckedUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUncheckedUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUncheckedUpdateManyWithoutAssignedToNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUncheckedUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUncheckedUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
  }

  export type ApplicationUpsertWithWhereUniqueWithoutJobPostInput = {
    where: ApplicationWhereUniqueInput
    update: XOR<ApplicationUpdateWithoutJobPostInput, ApplicationUncheckedUpdateWithoutJobPostInput>
    create: XOR<ApplicationCreateWithoutJobPostInput, ApplicationUncheckedCreateWithoutJobPostInput>
  }

  export type ApplicationUpdateWithWhereUniqueWithoutJobPostInput = {
    where: ApplicationWhereUniqueInput
    data: XOR<ApplicationUpdateWithoutJobPostInput, ApplicationUncheckedUpdateWithoutJobPostInput>
  }

  export type ApplicationUpdateManyWithWhereWithoutJobPostInput = {
    where: ApplicationScalarWhereInput
    data: XOR<ApplicationUpdateManyMutationInput, ApplicationUncheckedUpdateManyWithoutJobPostInput>
  }

  export type JobPostCreateWithoutApplicationsInput = {
    id?: string
    title: string
    type?: $Enums.JobType
    location?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutJobPostInput
    postedBy: UserCreateNestedOneWithoutJobPostsInput
  }

  export type JobPostUncheckedCreateWithoutApplicationsInput = {
    id?: string
    title: string
    departmentId?: string | null
    type?: $Enums.JobType
    location?: string | null
    description?: string | null
    postedById: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobPostCreateOrConnectWithoutApplicationsInput = {
    where: JobPostWhereUniqueInput
    create: XOR<JobPostCreateWithoutApplicationsInput, JobPostUncheckedCreateWithoutApplicationsInput>
  }

  export type UserCreateWithoutApplicationsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutReportsInput
    reports?: UserCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseCreateNestedManyWithoutApproverInput
    payrolls?: PayrollCreateNestedManyWithoutUserInput
    generatedPays?: PayrollCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostCreateNestedManyWithoutPostedByInput
    eventsOrganized?: CalendarEventCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
  }

  export type UserUncheckedCreateWithoutApplicationsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    departmentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: UserUncheckedCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveUncheckedCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseUncheckedCreateNestedManyWithoutApproverInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutUserInput
    generatedPays?: PayrollUncheckedCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewUncheckedCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetUncheckedCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostUncheckedCreateNestedManyWithoutPostedByInput
    eventsOrganized?: CalendarEventUncheckedCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeUncheckedCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentUncheckedCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
  }

  export type UserCreateOrConnectWithoutApplicationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApplicationsInput, UserUncheckedCreateWithoutApplicationsInput>
  }

  export type JobPostUpsertWithoutApplicationsInput = {
    update: XOR<JobPostUpdateWithoutApplicationsInput, JobPostUncheckedUpdateWithoutApplicationsInput>
    create: XOR<JobPostCreateWithoutApplicationsInput, JobPostUncheckedCreateWithoutApplicationsInput>
    where?: JobPostWhereInput
  }

  export type JobPostUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: JobPostWhereInput
    data: XOR<JobPostUpdateWithoutApplicationsInput, JobPostUncheckedUpdateWithoutApplicationsInput>
  }

  export type JobPostUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutJobPostNestedInput
    postedBy?: UserUpdateOneRequiredWithoutJobPostsNestedInput
  }

  export type JobPostUncheckedUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    postedById?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutApplicationsInput = {
    update: XOR<UserUpdateWithoutApplicationsInput, UserUncheckedUpdateWithoutApplicationsInput>
    create: XOR<UserCreateWithoutApplicationsInput, UserUncheckedCreateWithoutApplicationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApplicationsInput, UserUncheckedUpdateWithoutApplicationsInput>
  }

  export type UserUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutReportsNestedInput
    reports?: UserUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUpdateManyWithoutPostedByNestedInput
    eventsOrganized?: CalendarEventUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
  }

  export type UserUncheckedUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUncheckedUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUncheckedUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUncheckedUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUncheckedUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUncheckedUpdateManyWithoutPostedByNestedInput
    eventsOrganized?: CalendarEventUncheckedUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUncheckedUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
  }

  export type TrainingEnrollmentCreateWithoutTrainingInput = {
    id?: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    certificateUrl?: string | null
    user: UserCreateNestedOneWithoutTrainingEnrollmentsInput
  }

  export type TrainingEnrollmentUncheckedCreateWithoutTrainingInput = {
    id?: string
    userId: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    certificateUrl?: string | null
  }

  export type TrainingEnrollmentCreateOrConnectWithoutTrainingInput = {
    where: TrainingEnrollmentWhereUniqueInput
    create: XOR<TrainingEnrollmentCreateWithoutTrainingInput, TrainingEnrollmentUncheckedCreateWithoutTrainingInput>
  }

  export type TrainingEnrollmentCreateManyTrainingInputEnvelope = {
    data: TrainingEnrollmentCreateManyTrainingInput | TrainingEnrollmentCreateManyTrainingInput[]
    skipDuplicates?: boolean
  }

  export type TrainingEnrollmentUpsertWithWhereUniqueWithoutTrainingInput = {
    where: TrainingEnrollmentWhereUniqueInput
    update: XOR<TrainingEnrollmentUpdateWithoutTrainingInput, TrainingEnrollmentUncheckedUpdateWithoutTrainingInput>
    create: XOR<TrainingEnrollmentCreateWithoutTrainingInput, TrainingEnrollmentUncheckedCreateWithoutTrainingInput>
  }

  export type TrainingEnrollmentUpdateWithWhereUniqueWithoutTrainingInput = {
    where: TrainingEnrollmentWhereUniqueInput
    data: XOR<TrainingEnrollmentUpdateWithoutTrainingInput, TrainingEnrollmentUncheckedUpdateWithoutTrainingInput>
  }

  export type TrainingEnrollmentUpdateManyWithWhereWithoutTrainingInput = {
    where: TrainingEnrollmentScalarWhereInput
    data: XOR<TrainingEnrollmentUpdateManyMutationInput, TrainingEnrollmentUncheckedUpdateManyWithoutTrainingInput>
  }

  export type TrainingProgramCreateWithoutEnrollmentsInput = {
    id?: string
    title: string
    description?: string | null
    trainer?: string | null
    location?: string | null
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.TrainingStatus
    mode?: string | null
    maxSeats?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingProgramUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    title: string
    description?: string | null
    trainer?: string | null
    location?: string | null
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.TrainingStatus
    mode?: string | null
    maxSeats?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingProgramCreateOrConnectWithoutEnrollmentsInput = {
    where: TrainingProgramWhereUniqueInput
    create: XOR<TrainingProgramCreateWithoutEnrollmentsInput, TrainingProgramUncheckedCreateWithoutEnrollmentsInput>
  }

  export type UserCreateWithoutTrainingEnrollmentsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutReportsInput
    reports?: UserCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseCreateNestedManyWithoutApproverInput
    payrolls?: PayrollCreateNestedManyWithoutUserInput
    generatedPays?: PayrollCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostCreateNestedManyWithoutPostedByInput
    applications?: ApplicationCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
  }

  export type UserUncheckedCreateWithoutTrainingEnrollmentsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    departmentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: UserUncheckedCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveUncheckedCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseUncheckedCreateNestedManyWithoutApproverInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutUserInput
    generatedPays?: PayrollUncheckedCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewUncheckedCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetUncheckedCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostUncheckedCreateNestedManyWithoutPostedByInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventUncheckedCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeUncheckedCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
  }

  export type UserCreateOrConnectWithoutTrainingEnrollmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTrainingEnrollmentsInput, UserUncheckedCreateWithoutTrainingEnrollmentsInput>
  }

  export type TrainingProgramUpsertWithoutEnrollmentsInput = {
    update: XOR<TrainingProgramUpdateWithoutEnrollmentsInput, TrainingProgramUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<TrainingProgramCreateWithoutEnrollmentsInput, TrainingProgramUncheckedCreateWithoutEnrollmentsInput>
    where?: TrainingProgramWhereInput
  }

  export type TrainingProgramUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: TrainingProgramWhereInput
    data: XOR<TrainingProgramUpdateWithoutEnrollmentsInput, TrainingProgramUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type TrainingProgramUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainer?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    maxSeats?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingProgramUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainer?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    maxSeats?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutTrainingEnrollmentsInput = {
    update: XOR<UserUpdateWithoutTrainingEnrollmentsInput, UserUncheckedUpdateWithoutTrainingEnrollmentsInput>
    create: XOR<UserCreateWithoutTrainingEnrollmentsInput, UserUncheckedCreateWithoutTrainingEnrollmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTrainingEnrollmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTrainingEnrollmentsInput, UserUncheckedUpdateWithoutTrainingEnrollmentsInput>
  }

  export type UserUpdateWithoutTrainingEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutReportsNestedInput
    reports?: UserUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
  }

  export type UserUncheckedUpdateWithoutTrainingEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUncheckedUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUncheckedUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUncheckedUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUncheckedUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUncheckedUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUncheckedUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUncheckedUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
  }

  export type UserCreateWithoutEventsOrganizedInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutReportsInput
    reports?: UserCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseCreateNestedManyWithoutApproverInput
    payrolls?: PayrollCreateNestedManyWithoutUserInput
    generatedPays?: PayrollCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostCreateNestedManyWithoutPostedByInput
    applications?: ApplicationCreateNestedManyWithoutApplicantInput
    eventAttendees?: CalendarAttendeeCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
  }

  export type UserUncheckedCreateWithoutEventsOrganizedInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    departmentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: UserUncheckedCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveUncheckedCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseUncheckedCreateNestedManyWithoutApproverInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutUserInput
    generatedPays?: PayrollUncheckedCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewUncheckedCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetUncheckedCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostUncheckedCreateNestedManyWithoutPostedByInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutApplicantInput
    eventAttendees?: CalendarAttendeeUncheckedCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentUncheckedCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
  }

  export type UserCreateOrConnectWithoutEventsOrganizedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEventsOrganizedInput, UserUncheckedCreateWithoutEventsOrganizedInput>
  }

  export type CalendarAttendeeCreateWithoutEventInput = {
    id?: string
    response?: string | null
    user: UserCreateNestedOneWithoutEventAttendeesInput
  }

  export type CalendarAttendeeUncheckedCreateWithoutEventInput = {
    id?: string
    userId: string
    response?: string | null
  }

  export type CalendarAttendeeCreateOrConnectWithoutEventInput = {
    where: CalendarAttendeeWhereUniqueInput
    create: XOR<CalendarAttendeeCreateWithoutEventInput, CalendarAttendeeUncheckedCreateWithoutEventInput>
  }

  export type CalendarAttendeeCreateManyEventInputEnvelope = {
    data: CalendarAttendeeCreateManyEventInput | CalendarAttendeeCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutEventsOrganizedInput = {
    update: XOR<UserUpdateWithoutEventsOrganizedInput, UserUncheckedUpdateWithoutEventsOrganizedInput>
    create: XOR<UserCreateWithoutEventsOrganizedInput, UserUncheckedCreateWithoutEventsOrganizedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEventsOrganizedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEventsOrganizedInput, UserUncheckedUpdateWithoutEventsOrganizedInput>
  }

  export type UserUpdateWithoutEventsOrganizedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutReportsNestedInput
    reports?: UserUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUpdateManyWithoutApplicantNestedInput
    eventAttendees?: CalendarAttendeeUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
  }

  export type UserUncheckedUpdateWithoutEventsOrganizedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUncheckedUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUncheckedUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUncheckedUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUncheckedUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUncheckedUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    eventAttendees?: CalendarAttendeeUncheckedUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
  }

  export type CalendarAttendeeUpsertWithWhereUniqueWithoutEventInput = {
    where: CalendarAttendeeWhereUniqueInput
    update: XOR<CalendarAttendeeUpdateWithoutEventInput, CalendarAttendeeUncheckedUpdateWithoutEventInput>
    create: XOR<CalendarAttendeeCreateWithoutEventInput, CalendarAttendeeUncheckedCreateWithoutEventInput>
  }

  export type CalendarAttendeeUpdateWithWhereUniqueWithoutEventInput = {
    where: CalendarAttendeeWhereUniqueInput
    data: XOR<CalendarAttendeeUpdateWithoutEventInput, CalendarAttendeeUncheckedUpdateWithoutEventInput>
  }

  export type CalendarAttendeeUpdateManyWithWhereWithoutEventInput = {
    where: CalendarAttendeeScalarWhereInput
    data: XOR<CalendarAttendeeUpdateManyMutationInput, CalendarAttendeeUncheckedUpdateManyWithoutEventInput>
  }

  export type CalendarEventCreateWithoutAttendeesInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    source?: $Enums.EventSource
    googleMeetLink?: string | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organizer: UserCreateNestedOneWithoutEventsOrganizedInput
  }

  export type CalendarEventUncheckedCreateWithoutAttendeesInput = {
    id?: string
    title: string
    description?: string | null
    organizerId: string
    startTime: Date | string
    endTime: Date | string
    source?: $Enums.EventSource
    googleMeetLink?: string | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarEventCreateOrConnectWithoutAttendeesInput = {
    where: CalendarEventWhereUniqueInput
    create: XOR<CalendarEventCreateWithoutAttendeesInput, CalendarEventUncheckedCreateWithoutAttendeesInput>
  }

  export type UserCreateWithoutEventAttendeesInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutReportsInput
    reports?: UserCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseCreateNestedManyWithoutApproverInput
    payrolls?: PayrollCreateNestedManyWithoutUserInput
    generatedPays?: PayrollCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostCreateNestedManyWithoutPostedByInput
    applications?: ApplicationCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventCreateNestedManyWithoutOrganizerInput
    trainingEnrollments?: TrainingEnrollmentCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
  }

  export type UserUncheckedCreateWithoutEventAttendeesInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    departmentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: UserUncheckedCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveUncheckedCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseUncheckedCreateNestedManyWithoutApproverInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutUserInput
    generatedPays?: PayrollUncheckedCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewUncheckedCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetUncheckedCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostUncheckedCreateNestedManyWithoutPostedByInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventUncheckedCreateNestedManyWithoutOrganizerInput
    trainingEnrollments?: TrainingEnrollmentUncheckedCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
  }

  export type UserCreateOrConnectWithoutEventAttendeesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEventAttendeesInput, UserUncheckedCreateWithoutEventAttendeesInput>
  }

  export type CalendarEventUpsertWithoutAttendeesInput = {
    update: XOR<CalendarEventUpdateWithoutAttendeesInput, CalendarEventUncheckedUpdateWithoutAttendeesInput>
    create: XOR<CalendarEventCreateWithoutAttendeesInput, CalendarEventUncheckedCreateWithoutAttendeesInput>
    where?: CalendarEventWhereInput
  }

  export type CalendarEventUpdateToOneWithWhereWithoutAttendeesInput = {
    where?: CalendarEventWhereInput
    data: XOR<CalendarEventUpdateWithoutAttendeesInput, CalendarEventUncheckedUpdateWithoutAttendeesInput>
  }

  export type CalendarEventUpdateWithoutAttendeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumEventSourceFieldUpdateOperationsInput | $Enums.EventSource
    googleMeetLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizer?: UserUpdateOneRequiredWithoutEventsOrganizedNestedInput
  }

  export type CalendarEventUncheckedUpdateWithoutAttendeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizerId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumEventSourceFieldUpdateOperationsInput | $Enums.EventSource
    googleMeetLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutEventAttendeesInput = {
    update: XOR<UserUpdateWithoutEventAttendeesInput, UserUncheckedUpdateWithoutEventAttendeesInput>
    create: XOR<UserCreateWithoutEventAttendeesInput, UserUncheckedCreateWithoutEventAttendeesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEventAttendeesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEventAttendeesInput, UserUncheckedUpdateWithoutEventAttendeesInput>
  }

  export type UserUpdateWithoutEventAttendeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutReportsNestedInput
    reports?: UserUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUpdateManyWithoutOrganizerNestedInput
    trainingEnrollments?: TrainingEnrollmentUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
  }

  export type UserUncheckedUpdateWithoutEventAttendeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUncheckedUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUncheckedUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUncheckedUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUncheckedUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUncheckedUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUncheckedUpdateManyWithoutOrganizerNestedInput
    trainingEnrollments?: TrainingEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
  }

  export type UserCreateWithoutPreferencesInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutReportsInput
    reports?: UserCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseCreateNestedManyWithoutApproverInput
    payrolls?: PayrollCreateNestedManyWithoutUserInput
    generatedPays?: PayrollCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostCreateNestedManyWithoutPostedByInput
    applications?: ApplicationCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
  }

  export type UserUncheckedCreateWithoutPreferencesInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    departmentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: UserUncheckedCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveUncheckedCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseUncheckedCreateNestedManyWithoutApproverInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutUserInput
    generatedPays?: PayrollUncheckedCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewUncheckedCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetUncheckedCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostUncheckedCreateNestedManyWithoutPostedByInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventUncheckedCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeUncheckedCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentUncheckedCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
  }

  export type UserCreateOrConnectWithoutPreferencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
  }

  export type UserUpsertWithoutPreferencesInput = {
    update: XOR<UserUpdateWithoutPreferencesInput, UserUncheckedUpdateWithoutPreferencesInput>
    create: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPreferencesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPreferencesInput, UserUncheckedUpdateWithoutPreferencesInput>
  }

  export type UserUpdateWithoutPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutReportsNestedInput
    reports?: UserUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
  }

  export type UserUncheckedUpdateWithoutPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUncheckedUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUncheckedUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUncheckedUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUncheckedUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUncheckedUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUncheckedUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUncheckedUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutReportsInput
    reports?: UserCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseCreateNestedManyWithoutApproverInput
    payrolls?: PayrollCreateNestedManyWithoutUserInput
    generatedPays?: PayrollCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostCreateNestedManyWithoutPostedByInput
    applications?: ApplicationCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    departmentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: UserUncheckedCreateNestedManyWithoutManagerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TaskTimeLogUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveUncheckedCreateNestedManyWithoutApproverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    messagesRecv?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroups?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    companyDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutOwnerInput
    expensesApproved?: ExpenseUncheckedCreateNestedManyWithoutApproverInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutUserInput
    generatedPays?: PayrollUncheckedCreateNestedManyWithoutGeneratedByInput
    performanceReviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewerInput
    performanceReviewsGot?: PerformanceReviewUncheckedCreateNestedManyWithoutRevieweeInput
    assetsOwned?: AssetUncheckedCreateNestedManyWithoutAssignedToInput
    jobPosts?: JobPostUncheckedCreateNestedManyWithoutPostedByInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutApplicantInput
    eventsOrganized?: CalendarEventUncheckedCreateNestedManyWithoutOrganizerInput
    eventAttendees?: CalendarAttendeeUncheckedCreateNestedManyWithoutUserInput
    trainingEnrollments?: TrainingEnrollmentUncheckedCreateNestedManyWithoutUserInput
    announcementsMade?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutReportsNestedInput
    reports?: UserUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUncheckedUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUncheckedUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUncheckedUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUncheckedUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUncheckedUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUncheckedUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUncheckedUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
  }

  export type UserCreateManyManagerInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateManyCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.TaskPriority
    status?: $Enums.TaskStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskAssignmentCreateManyUserInput = {
    id?: string
    taskId: string
    assignedAt?: Date | string
  }

  export type TaskCommentCreateManyUserInput = {
    id?: string
    taskId: string
    content: string
    createdAt?: Date | string
  }

  export type TaskTimeLogCreateManyUserInput = {
    id?: string
    taskId: string
    startedAt: Date | string
    endedAt?: Date | string | null
    durationSeconds?: number | null
  }

  export type AttendanceRecordCreateManyUserInput = {
    id?: string
    date: Date | string
    clockIn?: Date | string | null
    clockOut?: Date | string | null
    status?: $Enums.AttendanceStatus
    ipAddress?: string | null
    location?: string | null
  }

  export type LeaveCreateManyUserInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    reason?: string | null
    status?: $Enums.LeaveStatus
    approverId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveCreateManyApproverInput = {
    id?: string
    userId: string
    startDate: Date | string
    endDate: Date | string
    reason?: string | null
    status?: $Enums.LeaveStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatMessageCreateManySenderInput = {
    id?: string
    receiverId?: string | null
    groupId?: string | null
    content: string
    timestamp?: Date | string
  }

  export type ChatMessageCreateManyReceiverInput = {
    id?: string
    senderId: string
    groupId?: string | null
    content: string
    timestamp?: Date | string
  }

  export type ChatGroupMemberCreateManyUserInput = {
    id?: string
    groupId: string
    joinedAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    title: string
    message: string
    type?: $Enums.NotificationType
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
  }

  export type DocumentCreateManyUserInput = {
    id?: string
    title: string
    fileUrl: string
    createdAt?: Date | string
  }

  export type CompanyDocumentCreateManyUploaderInput = {
    id?: string
    title: string
    description?: string | null
    fileUrl: string
    createdAt?: Date | string
  }

  export type ExpenseCreateManyOwnerInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    date: Date | string
    status?: $Enums.ExpenseStatus
    receiptUrl?: string | null
    submittedAt?: Date | string
    approvedAt?: Date | string | null
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateManyApproverInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    category?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    date: Date | string
    status?: $Enums.ExpenseStatus
    receiptUrl?: string | null
    submittedAt?: Date | string
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollCreateManyUserInput = {
    id?: string
    month: number
    year: number
    baseSalary: Decimal | DecimalJsLike | number | string
    allowances?: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
    netPay: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PayrollStatus
    generatedById?: string | null
    generatedAt?: Date | string | null
    paidAt?: Date | string | null
    slipUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollCreateManyGeneratedByInput = {
    id?: string
    userId: string
    month: number
    year: number
    baseSalary: Decimal | DecimalJsLike | number | string
    allowances?: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
    netPay: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PayrollStatus
    generatedAt?: Date | string | null
    paidAt?: Date | string | null
    slipUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PerformanceReviewCreateManyReviewerInput = {
    id?: string
    revieweeId: string
    periodStart: Date | string
    periodEnd: Date | string
    overallScore: number
    kpiScores?: NullableJsonNullValueInput | InputJsonValue
    feedback?: string | null
    createdAt?: Date | string
  }

  export type PerformanceReviewCreateManyRevieweeInput = {
    id?: string
    reviewerId: string
    periodStart: Date | string
    periodEnd: Date | string
    overallScore: number
    kpiScores?: NullableJsonNullValueInput | InputJsonValue
    feedback?: string | null
    createdAt?: Date | string
  }

  export type AssetCreateManyAssignedToInput = {
    id?: string
    tag: string
    name: string
    type?: string | null
    serialNumber?: string | null
    purchaseDate?: Date | string | null
    status?: $Enums.AssetStatus
    assignedAt?: Date | string | null
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobPostCreateManyPostedByInput = {
    id?: string
    title: string
    departmentId?: string | null
    type?: $Enums.JobType
    location?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApplicationCreateManyApplicantInput = {
    id?: string
    jobPostId: string
    applicantName: string
    applicantEmail: string
    resumeUrl?: string | null
    coverLetter?: string | null
    status?: $Enums.ApplicationStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarEventCreateManyOrganizerInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    source?: $Enums.EventSource
    googleMeetLink?: string | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarAttendeeCreateManyUserInput = {
    id?: string
    eventId: string
    response?: string | null
  }

  export type TrainingEnrollmentCreateManyUserInput = {
    id?: string
    trainingId: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    certificateUrl?: string | null
  }

  export type AnnouncementCreateManyAuthorInput = {
    id?: string
    title: string
    content: string
    departmentId?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateManyActorInput = {
    id?: string
    entity: string
    entityId: string
    action: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DepartmentCreateManyHeadInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    reports?: UserUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
  }

  export type UserUncheckedUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUncheckedUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUncheckedUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUncheckedUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUncheckedUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUncheckedUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUncheckedUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUncheckedUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
  }

  export type UserUncheckedUpdateManyWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: TaskAssignmentUpdateManyWithoutTaskNestedInput
    comments?: TaskCommentUpdateManyWithoutTaskNestedInput
    timeLogs?: TaskTimeLogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: TaskAssignmentUncheckedUpdateManyWithoutTaskNestedInput
    comments?: TaskCommentUncheckedUpdateManyWithoutTaskNestedInput
    timeLogs?: TaskTimeLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssignmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type TaskAssignmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssignmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type TaskCommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskTimeLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    task?: TaskUpdateOneRequiredWithoutTimeLogsNestedInput
  }

  export type TaskTimeLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TaskTimeLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AttendanceRecordUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    clockIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttendanceRecordUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    clockIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    clockIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LeaveUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approver?: UserUpdateOneWithoutLeavesToApproveNestedInput
  }

  export type LeaveUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    approverId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    approverId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLeavesNestedInput
  }

  export type LeaveUncheckedUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveUncheckedUpdateManyWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneWithoutMessagesRecvNestedInput
    group?: ChatGroupUpdateOneWithoutMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiverId?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiverId?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUpdateWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutMessagesSentNestedInput
    group?: ChatGroupUpdateOneWithoutMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatGroupMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: ChatGroupUpdateOneRequiredWithoutMembersNestedInput
  }

  export type ChatGroupMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatGroupMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyDocumentUpdateWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyDocumentUncheckedUpdateWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyDocumentUncheckedUpdateManyWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approver?: UserUpdateOneWithoutExpensesApprovedNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPayrollStatusFieldUpdateOperationsInput | $Enums.PayrollStatus
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slipUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedBy?: UserUpdateOneWithoutGeneratedPaysNestedInput
  }

  export type PayrollUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPayrollStatusFieldUpdateOperationsInput | $Enums.PayrollStatus
    generatedById?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slipUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPayrollStatusFieldUpdateOperationsInput | $Enums.PayrollStatus
    generatedById?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slipUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollUpdateWithoutGeneratedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPayrollStatusFieldUpdateOperationsInput | $Enums.PayrollStatus
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slipUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPayrollsNestedInput
  }

  export type PayrollUncheckedUpdateWithoutGeneratedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPayrollStatusFieldUpdateOperationsInput | $Enums.PayrollStatus
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slipUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollUncheckedUpdateManyWithoutGeneratedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPayrollStatusFieldUpdateOperationsInput | $Enums.PayrollStatus
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slipUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceReviewUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    overallScore?: IntFieldUpdateOperationsInput | number
    kpiScores?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewee?: UserUpdateOneRequiredWithoutPerformanceReviewsGotNestedInput
  }

  export type PerformanceReviewUncheckedUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    revieweeId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    overallScore?: IntFieldUpdateOperationsInput | number
    kpiScores?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceReviewUncheckedUpdateManyWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    revieweeId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    overallScore?: IntFieldUpdateOperationsInput | number
    kpiScores?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceReviewUpdateWithoutRevieweeInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    overallScore?: IntFieldUpdateOperationsInput | number
    kpiScores?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewer?: UserUpdateOneRequiredWithoutPerformanceReviewsGivenNestedInput
  }

  export type PerformanceReviewUncheckedUpdateWithoutRevieweeInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    overallScore?: IntFieldUpdateOperationsInput | number
    kpiScores?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceReviewUncheckedUpdateManyWithoutRevieweeInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    overallScore?: IntFieldUpdateOperationsInput | number
    kpiScores?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUncheckedUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUncheckedUpdateManyWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobPostUpdateWithoutPostedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutJobPostNestedInput
    applications?: ApplicationUpdateManyWithoutJobPostNestedInput
  }

  export type JobPostUncheckedUpdateWithoutPostedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: ApplicationUncheckedUpdateManyWithoutJobPostNestedInput
  }

  export type JobPostUncheckedUpdateManyWithoutPostedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationUpdateWithoutApplicantInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantName?: StringFieldUpdateOperationsInput | string
    applicantEmail?: StringFieldUpdateOperationsInput | string
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobPost?: JobPostUpdateOneRequiredWithoutApplicationsNestedInput
  }

  export type ApplicationUncheckedUpdateWithoutApplicantInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobPostId?: StringFieldUpdateOperationsInput | string
    applicantName?: StringFieldUpdateOperationsInput | string
    applicantEmail?: StringFieldUpdateOperationsInput | string
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationUncheckedUpdateManyWithoutApplicantInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobPostId?: StringFieldUpdateOperationsInput | string
    applicantName?: StringFieldUpdateOperationsInput | string
    applicantEmail?: StringFieldUpdateOperationsInput | string
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventUpdateWithoutOrganizerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumEventSourceFieldUpdateOperationsInput | $Enums.EventSource
    googleMeetLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendees?: CalendarAttendeeUpdateManyWithoutEventNestedInput
  }

  export type CalendarEventUncheckedUpdateWithoutOrganizerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumEventSourceFieldUpdateOperationsInput | $Enums.EventSource
    googleMeetLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendees?: CalendarAttendeeUncheckedUpdateManyWithoutEventNestedInput
  }

  export type CalendarEventUncheckedUpdateManyWithoutOrganizerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumEventSourceFieldUpdateOperationsInput | $Enums.EventSource
    googleMeetLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarAttendeeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    event?: CalendarEventUpdateOneRequiredWithoutAttendeesNestedInput
  }

  export type CalendarAttendeeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CalendarAttendeeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrainingEnrollmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    training?: TrainingProgramUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type TrainingEnrollmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrainingEnrollmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnnouncementUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutAnnouncementNestedInput
  }

  export type AnnouncementUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUpdateWithoutHeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutDepartmentNestedInput
    Announcement?: AnnouncementUpdateManyWithoutDepartmentNestedInput
    JobPost?: JobPostUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutHeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutDepartmentNestedInput
    Announcement?: AnnouncementUncheckedUpdateManyWithoutDepartmentNestedInput
    JobPost?: JobPostUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateManyWithoutHeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyDepartmentInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    employment?: $Enums.EmploymentStatus
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnouncementCreateManyDepartmentInput = {
    id?: string
    title: string
    content: string
    authorId: string
    createdAt?: Date | string
  }

  export type JobPostCreateManyDepartmentInput = {
    id?: string
    title: string
    type?: $Enums.JobType
    location?: string | null
    description?: string | null
    postedById: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: UserUpdateOneWithoutReportsNestedInput
    reports?: UserUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
  }

  export type UserUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TaskTimeLogUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveUncheckedUpdateManyWithoutApproverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesRecv?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroups?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    companyDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutOwnerNestedInput
    expensesApproved?: ExpenseUncheckedUpdateManyWithoutApproverNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    generatedPays?: PayrollUncheckedUpdateManyWithoutGeneratedByNestedInput
    performanceReviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewerNestedInput
    performanceReviewsGot?: PerformanceReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    assetsOwned?: AssetUncheckedUpdateManyWithoutAssignedToNestedInput
    jobPosts?: JobPostUncheckedUpdateManyWithoutPostedByNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    eventsOrganized?: CalendarEventUncheckedUpdateManyWithoutOrganizerNestedInput
    eventAttendees?: CalendarAttendeeUncheckedUpdateManyWithoutUserNestedInput
    trainingEnrollments?: TrainingEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    announcementsMade?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
  }

  export type UserUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    employment?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutAnnouncementsMadeNestedInput
  }

  export type AnnouncementUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobPostUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedBy?: UserUpdateOneRequiredWithoutJobPostsNestedInput
    applications?: ApplicationUpdateManyWithoutJobPostNestedInput
  }

  export type JobPostUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    postedById?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: ApplicationUncheckedUpdateManyWithoutJobPostNestedInput
  }

  export type JobPostUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    postedById?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssignmentCreateManyTaskInput = {
    id?: string
    userId: string
    assignedAt?: Date | string
  }

  export type TaskCommentCreateManyTaskInput = {
    id?: string
    userId: string
    content: string
    createdAt?: Date | string
  }

  export type TaskTimeLogCreateManyTaskInput = {
    id?: string
    userId: string
    startedAt: Date | string
    endedAt?: Date | string | null
    durationSeconds?: number | null
  }

  export type TaskAssignmentUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTaskAssignmentsNestedInput
  }

  export type TaskAssignmentUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssignmentUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCommentUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTaskCommentsNestedInput
  }

  export type TaskCommentUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCommentUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskTimeLogUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutTimeLogsNestedInput
  }

  export type TaskTimeLogUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TaskTimeLogUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ChatMessageCreateManyGroupInput = {
    id?: string
    senderId: string
    receiverId?: string | null
    content: string
    timestamp?: Date | string
  }

  export type ChatGroupMemberCreateManyGroupInput = {
    id?: string
    userId: string
    joinedAt?: Date | string
  }

  export type ChatMessageUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutMessagesSentNestedInput
    receiver?: UserUpdateOneWithoutMessagesRecvNestedInput
  }

  export type ChatMessageUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatGroupMemberUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutChatGroupsNestedInput
  }

  export type ChatGroupMemberUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatGroupMemberUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationCreateManyJobPostInput = {
    id?: string
    applicantUserId?: string | null
    applicantName: string
    applicantEmail: string
    resumeUrl?: string | null
    coverLetter?: string | null
    status?: $Enums.ApplicationStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApplicationUpdateWithoutJobPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantName?: StringFieldUpdateOperationsInput | string
    applicantEmail?: StringFieldUpdateOperationsInput | string
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant?: UserUpdateOneWithoutApplicationsNestedInput
  }

  export type ApplicationUncheckedUpdateWithoutJobPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantUserId?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: StringFieldUpdateOperationsInput | string
    applicantEmail?: StringFieldUpdateOperationsInput | string
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationUncheckedUpdateManyWithoutJobPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantUserId?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: StringFieldUpdateOperationsInput | string
    applicantEmail?: StringFieldUpdateOperationsInput | string
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingEnrollmentCreateManyTrainingInput = {
    id?: string
    userId: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    certificateUrl?: string | null
  }

  export type TrainingEnrollmentUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTrainingEnrollmentsNestedInput
  }

  export type TrainingEnrollmentUncheckedUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrainingEnrollmentUncheckedUpdateManyWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CalendarAttendeeCreateManyEventInput = {
    id?: string
    userId: string
    response?: string | null
  }

  export type CalendarAttendeeUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutEventAttendeesNestedInput
  }

  export type CalendarAttendeeUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CalendarAttendeeUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}